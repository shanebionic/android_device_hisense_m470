diff -Naur a/frameworks/av/media/libstagefright/ACodec.cpp b/frameworks/av/media/libstagefright/ACodec.cpp
--- a/frameworks/av/media/libstagefright/ACodec.cpp	2014-03-23 23:08:08.031581000 -0400
+++ b/frameworks/av/media/libstagefright/ACodec.cpp	2013-08-14 04:13:30.000000000 -0400
@@ -26,32 +26,17 @@
 #include <media/stagefright/foundation/ADebug.h>
 #include <media/stagefright/foundation/AMessage.h>
 
-#include <media/stagefright/BufferProducerWrapper.h>
 #include <media/stagefright/MediaCodecList.h>
 #include <media/stagefright/MediaDefs.h>
 #include <media/stagefright/NativeWindowWrapper.h>
 #include <media/stagefright/OMXClient.h>
 #include <media/stagefright/OMXCodec.h>
-#ifdef QCOM_HARDWARE
-#include <media/stagefright/ExtendedCodec.h>
-#endif
 
 #include <media/hardware/HardwareAPI.h>
 
 #include <OMX_Component.h>
 
-#ifdef USE_SAMSUNG_COLORFORMAT
-#include <sec_format.h>
-#endif
-
-#ifdef USE_TI_CUSTOM_DOMX
-#include <OMX_TI_IVCommon.h>
-#endif
-
 #include "include/avc_utils.h"
-#ifdef QCOM_HARDWARE
-#include "include/ExtendedUtils.h"
-#endif
 
 namespace android {
 
@@ -180,24 +165,6 @@
 
 ////////////////////////////////////////////////////////////////////////////////
 
-struct ACodec::DeathNotifier : public IBinder::DeathRecipient {
-    DeathNotifier(const sp<AMessage> &notify)
-        : mNotify(notify) {
-    }
-
-    virtual void binderDied(const wp<IBinder> &) {
-        mNotify->post();
-    }
-
-protected:
-    virtual ~DeathNotifier() {}
-
-private:
-    sp<AMessage> mNotify;
-
-    DISALLOW_EVIL_CONSTRUCTORS(DeathNotifier);
-};
-
 struct ACodec::UninitializedState : public ACodec::BaseState {
     UninitializedState(ACodec *codec);
 
@@ -209,8 +176,6 @@
     void onSetup(const sp<AMessage> &msg);
     bool onAllocateComponent(const sp<AMessage> &msg);
 
-    sp<DeathNotifier> mDeathNotifier;
-
     DISALLOW_EVIL_CONSTRUCTORS(UninitializedState);
 };
 
@@ -227,7 +192,6 @@
     friend struct ACodec::UninitializedState;
 
     bool onConfigureComponent(const sp<AMessage> &msg);
-    void onCreateInputSurface(const sp<AMessage> &msg);
     void onStart();
     void onShutdown(bool keepComponentAllocated);
 
@@ -269,8 +233,6 @@
 struct ACodec::ExecutingState : public ACodec::BaseState {
     ExecutingState(ACodec *codec);
 
-    void submitRegularOutputBuffers();
-    void submitOutputMetaBuffers();
     void submitOutputBuffers();
 
     // Submit output buffers to the decoder, submit input buffers to client
@@ -375,16 +337,11 @@
       mNode(NULL),
       mSentFormat(false),
       mIsEncoder(false),
-      mUseMetadataOnEncoderOutput(false),
       mShutdownInProgress(false),
       mEncoderDelay(0),
       mEncoderPadding(0),
       mChannelMaskPresent(false),
-      mChannelMask(0),
-      mDequeueCounter(0),
-      mStoreMetaDataInOutputBuffers(false),
-      mMetaDataBuffersToSubmit(0),
-      mRepeatFrameDelayUs(-1ll) {
+      mChannelMask(0) {
     mUninitializedState = new UninitializedState(this);
     mLoadedState = new LoadedState(this);
     mLoadedToIdleState = new LoadedToIdleState(this);
@@ -417,12 +374,6 @@
     msg->post();
 }
 
-void ACodec::signalSetParameters(const sp<AMessage> &params) {
-    sp<AMessage> msg = new AMessage(kWhatSetParameters, id());
-    msg->setMessage("params", params);
-    msg->post();
-}
-
 void ACodec::initiateAllocateComponent(const sp<AMessage> &msg) {
     msg->setWhat(kWhatAllocateComponent);
     msg->setTarget(id());
@@ -435,14 +386,6 @@
     msg->post();
 }
 
-void ACodec::initiateCreateInputSurface() {
-    (new AMessage(kWhatCreateInputSurface, id()))->post();
-}
-
-void ACodec::signalEndOfInputStream() {
-    (new AMessage(kWhatSignalEndOfInputStream, id()))->post();
-}
-
 void ACodec::initiateStart() {
     (new AMessage(kWhatStart, id()))->post();
 }
@@ -466,18 +409,6 @@
     (new AMessage(kWhatRequestIDRFrame, id()))->post();
 }
 
-// *** NOTE: THE FOLLOWING WORKAROUND WILL BE REMOVED ***
-// Some codecs may return input buffers before having them processed.
-// This causes a halt if we already signaled an EOS on the input
-// port.  For now keep submitting an output buffer if there was an
-// EOS on the input port, but not yet on the output port.
-void ACodec::signalSubmitOutputMetaDataBufferIfEOS_workaround() {
-    if (mPortEOS[kPortIndexInput] && !mPortEOS[kPortIndexOutput] &&
-            mMetaDataBuffersToSubmit > 0) {
-        (new AMessage(kWhatSubmitOutputMetaDataBufferIfEOS, id()))->post();
-    }
-}
-
 status_t ACodec::allocateBuffersOnPort(OMX_U32 portIndex) {
     CHECK(portIndex == kPortIndexInput || portIndex == kPortIndexOutput);
 
@@ -486,11 +417,7 @@
 
     status_t err;
     if (mNativeWindow != NULL && portIndex == kPortIndexOutput) {
-        if (mStoreMetaDataInOutputBuffers) {
-            err = allocateOutputMetaDataBuffers();
-        } else {
-            err = allocateOutputBuffersFromNativeWindow();
-        }
+        err = allocateOutputBuffersFromNativeWindow();
     } else {
         OMX_PARAM_PORTDEFINITIONTYPE def;
         InitOMXParams(&def);
@@ -520,8 +447,7 @@
                         ? OMXCodec::kRequiresAllocateBufferOnInputPorts
                         : OMXCodec::kRequiresAllocateBufferOnOutputPorts;
 
-                if ((portIndex == kPortIndexInput && (mFlags & kFlagIsSecure))
-                        || mUseMetadataOnEncoderOutput) {
+                if (portIndex == kPortIndexInput && (mFlags & kFlagIsSecure)) {
                     mem.clear();
 
                     void *ptr;
@@ -529,10 +455,7 @@
                             mNode, portIndex, def.nBufferSize, &info.mBufferID,
                             &ptr);
 
-                    int32_t bufSize = mUseMetadataOnEncoderOutput ?
-                            (4 + sizeof(buffer_handle_t)) : def.nBufferSize;
-
-                    info.mData = new ABuffer(ptr, bufSize);
+                    info.mData = new ABuffer(ptr, def.nBufferSize);
                 } else if (mQuirks & requiresAllocateBufferBit) {
                     err = mOMX->allocateBufferWithBackup(
                             mNode, portIndex, mem, &info.mBufferID);
@@ -572,9 +495,7 @@
     return OK;
 }
 
-status_t ACodec::configureOutputBuffersFromNativeWindow(
-        OMX_U32 *bufferCount, OMX_U32 *bufferSize,
-        OMX_U32 *minUndequeuedBuffers) {
+status_t ACodec::allocateOutputBuffersFromNativeWindow() {
     OMX_PARAM_PORTDEFINITIONTYPE def;
     InitOMXParams(&def);
     def.nPortIndex = kPortIndexOutput;
@@ -586,22 +507,11 @@
         return err;
     }
 
-#ifdef USE_SAMSUNG_COLORFORMAT
-    OMX_COLOR_FORMATTYPE eNativeColorFormat = def.format.video.eColorFormat;
-    setNativeWindowColorFormat(eNativeColorFormat);
-
-    err = native_window_set_buffers_geometry(
-    mNativeWindow.get(),
-    def.format.video.nFrameWidth,
-    def.format.video.nFrameHeight,
-    eNativeColorFormat);
-#else
     err = native_window_set_buffers_geometry(
             mNativeWindow.get(),
             def.format.video.nFrameWidth,
             def.format.video.nFrameHeight,
             def.format.video.eColorFormat);
-#endif
 
     if (err != 0) {
         ALOGE("native_window_set_buffers_geometry failed: %s (%d)",
@@ -650,10 +560,10 @@
         return err;
     }
 
-    *minUndequeuedBuffers = 0;
+    int minUndequeuedBufs = 0;
     err = mNativeWindow->query(
             mNativeWindow.get(), NATIVE_WINDOW_MIN_UNDEQUEUED_BUFFERS,
-            (int *)minUndequeuedBuffers);
+            &minUndequeuedBufs);
 
     if (err != 0) {
         ALOGE("NATIVE_WINDOW_MIN_UNDEQUEUED_BUFFERS query failed: %s (%d)",
@@ -664,8 +574,8 @@
     // XXX: Is this the right logic to use?  It's not clear to me what the OMX
     // buffer counts refer to - how do they account for the renderer holding on
     // to buffers?
-    if (def.nBufferCountActual < def.nBufferCountMin + *minUndequeuedBuffers) {
-        OMX_U32 newBufferCount = def.nBufferCountMin + *minUndequeuedBuffers;
+    if (def.nBufferCountActual < def.nBufferCountMin + minUndequeuedBufs) {
+        OMX_U32 newBufferCount = def.nBufferCountMin + minUndequeuedBufs;
         def.nBufferCountActual = newBufferCount;
         err = mOMX->setParameter(
                 mNode, OMX_IndexParamPortDefinition, &def, sizeof(def));
@@ -686,24 +596,12 @@
         return err;
     }
 
-    *bufferCount = def.nBufferCountActual;
-    *bufferSize =  def.nBufferSize;
-    return err;
-}
-
-status_t ACodec::allocateOutputBuffersFromNativeWindow() {
-    OMX_U32 bufferCount, bufferSize, minUndequeuedBuffers;
-    status_t err = configureOutputBuffersFromNativeWindow(
-            &bufferCount, &bufferSize, &minUndequeuedBuffers);
-    if (err != 0)
-        return err;
-
     ALOGV("[%s] Allocating %lu buffers from a native window of size %lu on "
          "output port",
-         mComponentName.c_str(), bufferCount, bufferSize);
+         mComponentName.c_str(), def.nBufferCountActual, def.nBufferSize);
 
     // Dequeue buffers and send them to OMX
-    for (OMX_U32 i = 0; i < bufferCount; i++) {
+    for (OMX_U32 i = 0; i < def.nBufferCountActual; i++) {
         ANativeWindowBuffer *buf;
         err = native_window_dequeue_buffer_and_wait(mNativeWindow.get(), &buf);
         if (err != 0) {
@@ -714,7 +612,7 @@
         sp<GraphicBuffer> graphicBuffer(new GraphicBuffer(buf, false));
         BufferInfo info;
         info.mStatus = BufferInfo::OWNED_BY_US;
-        info.mData = new ABuffer(NULL /* data */, bufferSize /* capacity */);
+        info.mData = new ABuffer(0);
         info.mGraphicBuffer = graphicBuffer;
         mBuffers[kPortIndexOutput].push(info);
 
@@ -743,9 +641,9 @@
         cancelStart = 0;
         cancelEnd = mBuffers[kPortIndexOutput].size();
     } else {
-        // Return the required minimum undequeued buffers to the native window.
-        cancelStart = bufferCount - minUndequeuedBuffers;
-        cancelEnd = bufferCount;
+        // Return the last two buffers to the native window.
+        cancelStart = def.nBufferCountActual - minUndequeuedBufs;
+        cancelEnd = def.nBufferCountActual;
     }
 
     for (OMX_U32 i = cancelStart; i < cancelEnd; i++) {
@@ -756,84 +654,6 @@
     return err;
 }
 
-status_t ACodec::allocateOutputMetaDataBuffers() {
-    OMX_U32 bufferCount, bufferSize, minUndequeuedBuffers;
-    status_t err = configureOutputBuffersFromNativeWindow(
-            &bufferCount, &bufferSize, &minUndequeuedBuffers);
-    if (err != 0)
-        return err;
-
-    ALOGV("[%s] Allocating %lu meta buffers on output port",
-         mComponentName.c_str(), bufferCount);
-
-    size_t totalSize = bufferCount * 8;
-    mDealer[kPortIndexOutput] = new MemoryDealer(totalSize, "ACodec");
-
-    // Dequeue buffers and send them to OMX
-    for (OMX_U32 i = 0; i < bufferCount; i++) {
-        BufferInfo info;
-        info.mStatus = BufferInfo::OWNED_BY_NATIVE_WINDOW;
-        info.mGraphicBuffer = NULL;
-        info.mDequeuedAt = mDequeueCounter;
-
-        sp<IMemory> mem = mDealer[kPortIndexOutput]->allocate(
-                sizeof(struct VideoDecoderOutputMetaData));
-        CHECK(mem.get() != NULL);
-        info.mData = new ABuffer(mem->pointer(), mem->size());
-
-        // we use useBuffer for metadata regardless of quirks
-        err = mOMX->useBuffer(
-                mNode, kPortIndexOutput, mem, &info.mBufferID);
-
-        mBuffers[kPortIndexOutput].push(info);
-
-        ALOGV("[%s] allocated meta buffer with ID %p (pointer = %p)",
-             mComponentName.c_str(), info.mBufferID, mem->pointer());
-    }
-
-    mMetaDataBuffersToSubmit = bufferCount - minUndequeuedBuffers;
-    return err;
-}
-
-status_t ACodec::submitOutputMetaDataBuffer() {
-    CHECK(mStoreMetaDataInOutputBuffers);
-    if (mMetaDataBuffersToSubmit == 0)
-        return OK;
-
-    BufferInfo *info = dequeueBufferFromNativeWindow();
-    if (info == NULL)
-        return ERROR_IO;
-
-    ALOGV("[%s] submitting output meta buffer ID %p for graphic buffer %p",
-          mComponentName.c_str(), info->mBufferID, info->mGraphicBuffer.get());
-
-    --mMetaDataBuffersToSubmit;
-    CHECK_EQ(mOMX->fillBuffer(mNode, info->mBufferID),
-             (status_t)OK);
-
-    info->mStatus = BufferInfo::OWNED_BY_COMPONENT;
-    return OK;
-}
-
-#ifdef USE_SAMSUNG_COLORFORMAT
-void ACodec::setNativeWindowColorFormat(OMX_COLOR_FORMATTYPE &eNativeColorFormat)
-{
-    // In case of Samsung decoders, we set proper native color format for the Native Window
-    if (!strcasecmp(mComponentName.c_str(), "OMX.SEC.AVC.Decoder")
-        || !strcasecmp(mComponentName.c_str(), "OMX.SEC.FP.AVC.Decoder")) {
-        switch (eNativeColorFormat) {
-            case OMX_COLOR_FormatYUV420SemiPlanar:
-                eNativeColorFormat = (OMX_COLOR_FORMATTYPE)HAL_PIXEL_FORMAT_YCbCr_420_SP;
-                break;
-            case OMX_COLOR_FormatYUV420Planar:
-            default:
-                eNativeColorFormat = (OMX_COLOR_FORMATTYPE)HAL_PIXEL_FORMAT_YCbCr_420_P;
-                break;
-        }
-    }
-}
-#endif
-
 status_t ACodec::cancelBufferToNativeWindow(BufferInfo *info) {
     CHECK_EQ((int)info->mStatus, (int)BufferInfo::OWNED_BY_US);
 
@@ -853,19 +673,16 @@
 ACodec::BufferInfo *ACodec::dequeueBufferFromNativeWindow() {
     ANativeWindowBuffer *buf;
     int fenceFd = -1;
-    CHECK(mNativeWindow.get() != NULL);
     if (native_window_dequeue_buffer_and_wait(mNativeWindow.get(), &buf) != 0) {
         ALOGE("dequeueBuffer failed.");
         return NULL;
     }
 
-    BufferInfo *oldest = NULL;
     for (size_t i = mBuffers[kPortIndexOutput].size(); i-- > 0;) {
         BufferInfo *info =
             &mBuffers[kPortIndexOutput].editItemAt(i);
 
-        if (info->mGraphicBuffer != NULL &&
-            info->mGraphicBuffer->handle == buf->handle) {
+        if (info->mGraphicBuffer->handle == buf->handle) {
             CHECK_EQ((int)info->mStatus,
                      (int)BufferInfo::OWNED_BY_NATIVE_WINDOW);
 
@@ -873,39 +690,6 @@
 
             return info;
         }
-
-        if (info->mStatus == BufferInfo::OWNED_BY_NATIVE_WINDOW &&
-            (oldest == NULL ||
-             // avoid potential issues from counter rolling over
-             mDequeueCounter - info->mDequeuedAt >
-                    mDequeueCounter - oldest->mDequeuedAt)) {
-            oldest = info;
-        }
-    }
-
-    if (oldest) {
-        CHECK(mStoreMetaDataInOutputBuffers);
-
-        // discard buffer in LRU info and replace with new buffer
-        oldest->mGraphicBuffer = new GraphicBuffer(buf, false);
-        oldest->mStatus = BufferInfo::OWNED_BY_US;
-
-        mOMX->updateGraphicBufferInMeta(
-                mNode, kPortIndexOutput, oldest->mGraphicBuffer,
-                oldest->mBufferID);
-
-        VideoDecoderOutputMetaData *metaData =
-            reinterpret_cast<VideoDecoderOutputMetaData *>(
-                    oldest->mData->base());
-        CHECK_EQ(metaData->eType, kMetadataBufferTypeGrallocSource);
-
-        ALOGV("replaced oldest buffer #%u with age %u (%p/%p stored in %p)",
-                oldest - &mBuffers[kPortIndexOutput][0],
-                mDequeueCounter - oldest->mDequeuedAt,
-                metaData->pHandle,
-                oldest->mGraphicBuffer->handle, oldest->mData->base());
-
-        return oldest;
     }
 
     TRESPASS();
@@ -928,10 +712,12 @@
         BufferInfo *info =
             &mBuffers[kPortIndexOutput].editItemAt(i);
 
-        // At this time some buffers may still be with the component
-        // or being drained.
-        if (info->mStatus != BufferInfo::OWNED_BY_COMPONENT &&
-            info->mStatus != BufferInfo::OWNED_BY_DOWNSTREAM) {
+        if (info->mStatus !=
+                BufferInfo::OWNED_BY_COMPONENT) {
+            // We shouldn't have sent out any buffers to the client at this
+            // point.
+            CHECK_NE((int)info->mStatus, (int)BufferInfo::OWNED_BY_DOWNSTREAM);
+
             CHECK_EQ((status_t)OK, freeBuffer(kPortIndexOutput, i));
         }
     }
@@ -997,10 +783,6 @@
             "audio_decoder.amrnb", "audio_encoder.amrnb" },
         { MEDIA_MIMETYPE_AUDIO_AMR_WB,
             "audio_decoder.amrwb", "audio_encoder.amrwb" },
-#ifdef ENABLE_AV_ENHANCEMENTS
-        { MEDIA_MIMETYPE_AUDIO_AMR_WB_PLUS,
-            "audio_decoder.amrwbplus", "audio_encoder.amrwbplus" },
-#endif
         { MEDIA_MIMETYPE_AUDIO_AAC,
             "audio_decoder.aac", "audio_encoder.aac" },
         { MEDIA_MIMETYPE_AUDIO_VORBIS,
@@ -1015,16 +797,12 @@
             "video_decoder.mpeg4", "video_encoder.mpeg4" },
         { MEDIA_MIMETYPE_VIDEO_H263,
             "video_decoder.h263", "video_encoder.h263" },
-        { MEDIA_MIMETYPE_VIDEO_VP8,
-            "video_decoder.vp8", "video_encoder.vp8" },
-        { MEDIA_MIMETYPE_VIDEO_VP9,
-            "video_decoder.vp9", "video_encoder.vp9" },
+        { MEDIA_MIMETYPE_VIDEO_VPX,
+            "video_decoder.vpx", "video_encoder.vpx" },
         { MEDIA_MIMETYPE_AUDIO_RAW,
             "audio_decoder.raw", "audio_encoder.raw" },
         { MEDIA_MIMETYPE_AUDIO_FLAC,
             "audio_decoder.flac", "audio_encoder.flac" },
-        { MEDIA_MIMETYPE_AUDIO_MSGSM,
-            "audio_decoder.gsm", "audio_encoder.gsm" },
     };
 
     static const size_t kNumMimeToRole =
@@ -1038,11 +816,7 @@
     }
 
     if (i == kNumMimeToRole) {
-#ifdef QCOM_HARDWARE
-        return ExtendedCodec::setSupportedRole(mOMX, mNode, isEncoder, mime);
-#else
         return ERROR_UNSUPPORTED;
-#endif
     }
 
     const char *role =
@@ -1102,14 +876,14 @@
         err = mOMX->storeMetaDataInBuffers(mNode, kPortIndexInput, OMX_TRUE);
 
         if (err != OK) {
-              ALOGE("[%s] storeMetaDataInBuffers (input) failed w/ err %d",
-                    mComponentName.c_str(), err);
+            ALOGE("[%s] storeMetaDataInBuffers failed w/ err %d",
+                  mComponentName.c_str(), err);
 
-              return err;
-          }
-      }
+            return err;
+        }
+    }
 
-    int32_t prependSPSPPS = 0;
+    int32_t prependSPSPPS;
     if (encoder
             && msg->findInt32("prepend-sps-pps-to-idr-frames", &prependSPSPPS)
             && prependSPSPPS != 0) {
@@ -1136,119 +910,7 @@
         }
     }
 
-    // Only enable metadata mode on encoder output if encoder can prepend
-    // sps/pps to idr frames, since in metadata mode the bitstream is in an
-    // opaque handle, to which we don't have access.
-    int32_t video = !strncasecmp(mime, "video/", 6);
-    if (encoder && video) {
-        OMX_BOOL enable = (OMX_BOOL) (prependSPSPPS
-            && msg->findInt32("store-metadata-in-buffers-output", &storeMeta)
-            && storeMeta != 0);
-
-        err = mOMX->storeMetaDataInBuffers(mNode, kPortIndexOutput, enable);
-
-        if (err != OK) {
-            ALOGE("[%s] storeMetaDataInBuffers (output) failed w/ err %d",
-                mComponentName.c_str(), err);
-            mUseMetadataOnEncoderOutput = 0;
-        } else {
-            mUseMetadataOnEncoderOutput = enable;
-        }
-
-        if (!msg->findInt64(
-                    "repeat-previous-frame-after",
-                    &mRepeatFrameDelayUs)) {
-            mRepeatFrameDelayUs = -1ll;
-        }
-    }
-
-    // Always try to enable dynamic output buffers on native surface
-    sp<RefBase> obj;
-    int32_t haveNativeWindow = msg->findObject("native-window", &obj) &&
-            obj != NULL;
-    mStoreMetaDataInOutputBuffers = false;
-    bool bAdaptivePlaybackMode = false;
-    if (!encoder && video && haveNativeWindow) {
-        int32_t preferAdaptive = 0;
-        if (msg->findInt32("prefer-adaptive-playback", &preferAdaptive)
-                && preferAdaptive == 1) {
-            ALOGI("[%s] Adaptive playback preferred", mComponentName.c_str());
-        } else {
-            preferAdaptive = 0;
-            err = mOMX->storeMetaDataInBuffers(mNode, kPortIndexOutput, OMX_TRUE);
-        }
-        if (err != OK || preferAdaptive) {
-            if (!preferAdaptive) {
-                ALOGE("[%s] storeMetaDataInBuffers failed w/ err %d",
-                      mComponentName.c_str(), err);
-            }
-
-            // if adaptive playback has been requested, try JB fallback
-            // NOTE: THIS FALLBACK MECHANISM WILL BE REMOVED DUE TO ITS
-            // LARGE MEMORY REQUIREMENT
-
-            // we will not do adaptive playback on software accessed
-            // surfaces as they never had to respond to changes in the
-            // crop window, and we don't trust that they will be able to.
-            int usageBits = 0;
-            bool canDoAdaptivePlayback;
-
-            sp<NativeWindowWrapper> windowWrapper(
-                    static_cast<NativeWindowWrapper *>(obj.get()));
-            sp<ANativeWindow> nativeWindow = windowWrapper->getNativeWindow();
-
-            if (nativeWindow->query(
-                    nativeWindow.get(),
-                    NATIVE_WINDOW_CONSUMER_USAGE_BITS,
-                    &usageBits) != OK) {
-                canDoAdaptivePlayback = false;
-            } else {
-                canDoAdaptivePlayback =
-                    (usageBits &
-                            (GRALLOC_USAGE_SW_READ_MASK |
-                             GRALLOC_USAGE_SW_WRITE_MASK)) == 0;
-            }
-
-            int32_t maxWidth = 0, maxHeight = 0;
-            if (canDoAdaptivePlayback &&
-                msg->findInt32("max-width", &maxWidth) &&
-                msg->findInt32("max-height", &maxHeight)) {
-                ALOGI("[%s] prepareForAdaptivePlayback(%ldx%ld)",
-                      mComponentName.c_str(), maxWidth, maxHeight);
-
-                err = mOMX->prepareForAdaptivePlayback(
-                        mNode, kPortIndexOutput, OMX_TRUE, maxWidth, maxHeight);
-                ALOGW_IF(err != OK,
-                        "[%s] prepareForAdaptivePlayback failed w/ err %d",
-                        mComponentName.c_str(), err);
-                bAdaptivePlaybackMode = (err == OK);
-            }
-            // if Adaptive mode was tried first and codec failed it, try dynamic mode
-            if (err != OK && preferAdaptive) {
-                err = mOMX->storeMetaDataInBuffers(mNode, kPortIndexOutput, OMX_TRUE);
-                if (err != OK) {
-                    ALOGE("[%s] storeMetaDataInBuffers failed w/ err %d",
-                          mComponentName.c_str(), err);
-                }
-            }
-            // allow failure
-            err = OK;
-        } else {
-            ALOGV("[%s] storeMetaDataInBuffers succeeded", mComponentName.c_str());
-            mStoreMetaDataInOutputBuffers = true;
-        }
-
-        ALOGI("DRC Mode: %s",(mStoreMetaDataInOutputBuffers ? "Dynamic Buffer Mode" :
-                (bAdaptivePlaybackMode ? "Adaptive Mode" : "Port Reconfig Mode")));
-
-        int32_t push;
-        if (msg->findInt32("push-blank-buffers-on-shutdown", &push)
-                && push != 0) {
-            mFlags |= kFlagPushBlankBuffersToNativeWindowOnShutdown;
-        }
-    }
-
-    if (video) {
+    if (!strncasecmp(mime, "video/", 6)) {
         if (encoder) {
             err = setupVideoEncoder(mime, msg);
         } else {
@@ -1260,25 +922,6 @@
                 err = setupVideoDecoder(mime, width, height);
             }
         }
-#ifdef QCOM_HARDWARE
-        if (err == OK) {
-            const char* componentName = mComponentName.c_str();
-            ExtendedCodec::configureVideoDecoder(msg, mime, mOMX, 0, mNode, componentName);
-        }
-#endif
-    } else if (!strcasecmp(mime, MEDIA_MIMETYPE_AUDIO_MPEG)) {
-        int32_t numChannels, sampleRate;
-        if (!msg->findInt32("channel-count", &numChannels)
-                || !msg->findInt32("sample-rate", &sampleRate)) {
-            // Since we did not always check for these, leave them optional
-            // and have the decoder figure it all out.
-            err = OK;
-        } else {
-            err = setupRawAudioFormat(
-                    encoder ? kPortIndexInput : kPortIndexOutput,
-                    sampleRate,
-                    numChannels);
-        }
     } else if (!strcasecmp(mime, MEDIA_MIMETYPE_AUDIO_AAC)) {
         int32_t numChannels, sampleRate;
         if (!msg->findInt32("channel-count", &numChannels)
@@ -1321,23 +964,17 @@
             err = INVALID_OPERATION;
         } else {
             if (encoder) {
-                if (!msg->findInt32(
-                            "flac-compression-level", &compressionLevel)) {
+                if (!msg->findInt32("flac-compression-level", &compressionLevel)) {
                     compressionLevel = 5;// default FLAC compression level
                 } else if (compressionLevel < 0) {
-                    ALOGW("compression level %d outside [0..8] range, "
-                          "using 0",
-                          compressionLevel);
+                    ALOGW("compression level %d outside [0..8] range, using 0", compressionLevel);
                     compressionLevel = 0;
                 } else if (compressionLevel > 8) {
-                    ALOGW("compression level %d outside [0..8] range, "
-                          "using 8",
-                          compressionLevel);
+                    ALOGW("compression level %d outside [0..8] range, using 8", compressionLevel);
                     compressionLevel = 8;
                 }
             }
-            err = setupFlacCodec(
-                    encoder, numChannels, sampleRate, compressionLevel);
+            err = setupFlacCodec(encoder, numChannels, sampleRate, compressionLevel);
         }
     } else if (!strcasecmp(mime, MEDIA_MIMETYPE_AUDIO_RAW)) {
         int32_t numChannels, sampleRate;
@@ -1348,21 +985,6 @@
         } else {
             err = setupRawAudioFormat(kPortIndexInput, sampleRate, numChannels);
         }
-#ifdef QCOM_HARDWARE
-    } else {
-        if (encoder) {
-            int32_t numChannels, sampleRate;
-            if (msg->findInt32("channel-count", &numChannels)
-                  && msg->findInt32("sample-rate", &sampleRate)) {
-                setupRawAudioFormat(kPortIndexInput, sampleRate, numChannels);
-            }
-       }
-       err = ExtendedCodec::setAudioFormat(
-                 msg, mime, mOMX, mNode, mIsEncoder);
-       if(err != OK) {
-           return err;
-       }
-#endif
     }
 
     if (err != OK) {
@@ -1786,53 +1408,36 @@
     CHECK_EQ(err, (status_t)OK);
     CHECK_EQ((int)format.eCompressionFormat, (int)OMX_VIDEO_CodingUnused);
 
+    CHECK(format.eColorFormat == OMX_COLOR_FormatYUV420Planar
+           || format.eColorFormat == OMX_COLOR_FormatYUV420SemiPlanar
+           || format.eColorFormat == OMX_COLOR_FormatCbYCrY
+           || format.eColorFormat == OMX_TI_COLOR_FormatYUV420PackedSemiPlanar
+           || format.eColorFormat == OMX_QCOM_COLOR_FormatYVU420SemiPlanar
+           || format.eColorFormat == OMX_QCOM_COLOR_FormatYUV420PackedSemiPlanar64x32Tile2m8ka);
+
     return mOMX->setParameter(
             mNode, OMX_IndexParamVideoPortFormat,
             &format, sizeof(format));
 }
 
-static const struct VideoCodingMapEntry {
-    const char *mMime;
-    OMX_VIDEO_CODINGTYPE mVideoCodingType;
-} kVideoCodingMapEntry[] = {
-    { MEDIA_MIMETYPE_VIDEO_AVC, OMX_VIDEO_CodingAVC },
-    { MEDIA_MIMETYPE_VIDEO_MPEG4, OMX_VIDEO_CodingMPEG4 },
-    { MEDIA_MIMETYPE_VIDEO_H263, OMX_VIDEO_CodingH263 },
-    { MEDIA_MIMETYPE_VIDEO_MPEG2, OMX_VIDEO_CodingMPEG2 },
-    { MEDIA_MIMETYPE_VIDEO_VP8, OMX_VIDEO_CodingVP8 },
-    { MEDIA_MIMETYPE_VIDEO_VP9, OMX_VIDEO_CodingVP9 },
-};
-
 static status_t GetVideoCodingTypeFromMime(
         const char *mime, OMX_VIDEO_CODINGTYPE *codingType) {
-    for (size_t i = 0;
-         i < sizeof(kVideoCodingMapEntry) / sizeof(kVideoCodingMapEntry[0]);
-         ++i) {
-        if (!strcasecmp(mime, kVideoCodingMapEntry[i].mMime)) {
-            *codingType = kVideoCodingMapEntry[i].mVideoCodingType;
-            return OK;
-        }
-    }
-
-    *codingType = OMX_VIDEO_CodingUnused;
-
-    return ERROR_UNSUPPORTED;
-}
-
-static status_t GetMimeTypeForVideoCoding(
-        OMX_VIDEO_CODINGTYPE codingType, AString *mime) {
-    for (size_t i = 0;
-         i < sizeof(kVideoCodingMapEntry) / sizeof(kVideoCodingMapEntry[0]);
-         ++i) {
-        if (codingType == kVideoCodingMapEntry[i].mVideoCodingType) {
-            *mime = kVideoCodingMapEntry[i].mMime;
-            return OK;
-        }
+    if (!strcasecmp(MEDIA_MIMETYPE_VIDEO_AVC, mime)) {
+        *codingType = OMX_VIDEO_CodingAVC;
+    } else if (!strcasecmp(MEDIA_MIMETYPE_VIDEO_MPEG4, mime)) {
+        *codingType = OMX_VIDEO_CodingMPEG4;
+    } else if (!strcasecmp(MEDIA_MIMETYPE_VIDEO_H263, mime)) {
+        *codingType = OMX_VIDEO_CodingH263;
+    } else if (!strcasecmp(MEDIA_MIMETYPE_VIDEO_MPEG2, mime)) {
+        *codingType = OMX_VIDEO_CodingMPEG2;
+    } else if (!strcasecmp(MEDIA_MIMETYPE_VIDEO_VPX, mime)) {
+        *codingType = OMX_VIDEO_CodingVPX;
+    } else {
+        *codingType = OMX_VIDEO_CodingUnused;
+        return ERROR_UNSUPPORTED;
     }
 
-    mime->clear();
-
-    return ERROR_UNSUPPORTED;
+    return OK;
 }
 
 status_t ACodec::setupVideoDecoder(
@@ -1841,11 +1446,7 @@
     status_t err = GetVideoCodingTypeFromMime(mime, &compressionFormat);
 
     if (err != OK) {
-#ifdef QCOM_HARDWARE
-        err = ExtendedCodec::setVideoOutputFormat(mime, &compressionFormat);
-        if (err != OK)
-#endif
-            return err;
+        return err;
     }
 
     err = setVideoPortFormatType(
@@ -1968,15 +1569,7 @@
     err = GetVideoCodingTypeFromMime(mime, &compressionFormat);
 
     if (err != OK) {
-#ifdef QCOM_HARDWARE
-        err = ExtendedCodec::setVideoInputFormat(mime, &compressionFormat);
-        if (err != OK) {
-            ALOGE("Not a supported video mime type: %s", mime);
-#endif
-            return err;
-#ifdef QCOM_HARDWARE
-        }
-#endif
+        return err;
     }
 
     err = setVideoPortFormatType(
@@ -2028,11 +1621,6 @@
             err = setupAVCEncoderParameters(msg);
             break;
 
-        case OMX_VIDEO_CodingVP8:
-        case OMX_VIDEO_CodingVP9:
-            err = setupVPXEncoderParameters(msg);
-            break;
-
         default:
             break;
     }
@@ -2281,7 +1869,8 @@
         if (err != OK) {
             ALOGE("Setting intra macroblock refresh mode (%d) failed: 0x%x",
                     err, intraRefreshMode);
-            return err;
+            ALOGE("setupAVCEncoderParameters() SKIP!! intra-refresh-mode");
+            //return err;
         }
     }
 
@@ -2364,17 +1953,6 @@
     return configureBitrate(bitrate, bitrateMode);
 }
 
-status_t ACodec::setupVPXEncoderParameters(const sp<AMessage> &msg) {
-    int32_t bitrate;
-    if (!msg->findInt32("bitrate", &bitrate)) {
-        return INVALID_OPERATION;
-    }
-
-    OMX_VIDEO_CONTROLRATETYPE bitrateMode = getBitrateMode(msg);
-
-    return configureBitrate(bitrate, bitrateMode);
-}
-
 status_t ACodec::verifySupportForProfileAndLevel(
         int32_t profile, int32_t level) {
     OMX_VIDEO_PARAM_PROFILELEVELTYPE params;
@@ -2508,46 +2086,6 @@
     return n;
 }
 
-size_t ACodec::countBuffersOwnedByNativeWindow() const {
-    size_t n = 0;
-
-    for (size_t i = 0; i < mBuffers[kPortIndexOutput].size(); ++i) {
-        const BufferInfo &info = mBuffers[kPortIndexOutput].itemAt(i);
-
-        if (info.mStatus == BufferInfo::OWNED_BY_NATIVE_WINDOW) {
-            ++n;
-        }
-    }
-
-    return n;
-}
-
-void ACodec::waitUntilAllPossibleNativeWindowBuffersAreReturnedToUs() {
-    if (mNativeWindow == NULL) {
-        return;
-    }
-
-    int minUndequeuedBufs = 0;
-    status_t err = mNativeWindow->query(
-            mNativeWindow.get(), NATIVE_WINDOW_MIN_UNDEQUEUED_BUFFERS,
-            &minUndequeuedBufs);
-
-    if (err != OK) {
-        ALOGE("[%s] NATIVE_WINDOW_MIN_UNDEQUEUED_BUFFERS query failed: %s (%d)",
-                mComponentName.c_str(), strerror(-err), -err);
-
-        minUndequeuedBufs = 0;
-    }
-
-    while (countBuffersOwnedByNativeWindow() > (size_t)minUndequeuedBufs
-            && dequeueBufferFromNativeWindow() != NULL) {
-        // these buffers will be submitted as regular buffers; account for this
-        if (mStoreMetaDataInOutputBuffers && mMetaDataBuffersToSubmit > 0) {
-            --mMetaDataBuffersToSubmit;
-        }
-    }
-}
-
 bool ACodec::allYourBuffersAreBelongToUs(
         OMX_U32 portIndex) {
     for (size_t i = 0; i < mBuffers[portIndex].size(); ++i) {
@@ -2585,7 +2123,7 @@
     }
 }
 
-void ACodec::sendFormatChange(const sp<AMessage> &reply) {
+void ACodec::sendFormatChange() {
     sp<AMessage> notify = mNotify->dup();
     notify->setInt32("what", kWhatOutputFormatChanged);
 
@@ -2604,59 +2142,49 @@
         {
             OMX_VIDEO_PORTDEFINITIONTYPE *videoDef = &def.format.video;
 
-            AString mime;
-            if (!mIsEncoder) {
-                notify->setString("mime", MEDIA_MIMETYPE_VIDEO_RAW);
-            } else if (GetMimeTypeForVideoCoding(
-                        videoDef->eCompressionFormat, &mime) != OK) {
-                notify->setString("mime", "application/octet-stream");
-            } else {
-                notify->setString("mime", mime.c_str());
-            }
-
+            notify->setString("mime", MEDIA_MIMETYPE_VIDEO_RAW);
             notify->setInt32("width", videoDef->nFrameWidth);
             notify->setInt32("height", videoDef->nFrameHeight);
+            notify->setInt32("stride", videoDef->nStride);
+            notify->setInt32("slice-height", videoDef->nSliceHeight);
+            notify->setInt32("color-format", videoDef->eColorFormat);
+
+            OMX_CONFIG_RECTTYPE rect;
+            InitOMXParams(&rect);
+            rect.nPortIndex = kPortIndexOutput;
+
+            if (mOMX->getConfig(
+                        mNode, OMX_IndexConfigCommonOutputCrop,
+                        &rect, sizeof(rect)) != OK) {
+                rect.nLeft = 0;
+                rect.nTop = 0;
+                rect.nWidth = videoDef->nFrameWidth;
+                rect.nHeight = videoDef->nFrameHeight;
+            }
+
+            CHECK_GE(rect.nLeft, 0);
+            CHECK_GE(rect.nTop, 0);
+            CHECK_GE(rect.nWidth, 0u);
+            CHECK_GE(rect.nHeight, 0u);
+            CHECK_LE(rect.nLeft + rect.nWidth - 1, videoDef->nFrameWidth);
+            CHECK_LE(rect.nTop + rect.nHeight - 1, videoDef->nFrameHeight);
+
+            notify->setRect(
+                    "crop",
+                    rect.nLeft,
+                    rect.nTop,
+                    rect.nLeft + rect.nWidth - 1,
+                    rect.nTop + rect.nHeight - 1);
+
+            if (mNativeWindow != NULL) {
+                android_native_rect_t crop;
+                crop.left = rect.nLeft;
+                crop.top = rect.nTop;
+                crop.right = rect.nLeft + rect.nWidth;
+                crop.bottom = rect.nTop + rect.nHeight;
 
-            if (!mIsEncoder) {
-                notify->setInt32("stride", videoDef->nStride);
-                notify->setInt32("slice-height", videoDef->nSliceHeight);
-                notify->setInt32("color-format", videoDef->eColorFormat);
-
-                OMX_CONFIG_RECTTYPE rect;
-                InitOMXParams(&rect);
-                rect.nPortIndex = kPortIndexOutput;
-
-                if (mOMX->getConfig(
-                            mNode, OMX_IndexConfigCommonOutputCrop,
-                            &rect, sizeof(rect)) != OK) {
-                    rect.nLeft = 0;
-                    rect.nTop = 0;
-                    rect.nWidth = videoDef->nFrameWidth;
-                    rect.nHeight = videoDef->nFrameHeight;
-                }
-
-                CHECK_GE(rect.nLeft, 0);
-                CHECK_GE(rect.nTop, 0);
-                CHECK_GE(rect.nWidth, 0u);
-                CHECK_GE(rect.nHeight, 0u);
-                CHECK_LE(rect.nLeft + rect.nWidth - 1, videoDef->nFrameWidth);
-                CHECK_LE(rect.nTop + rect.nHeight - 1, videoDef->nFrameHeight);
-
-                notify->setRect(
-                        "crop",
-                        rect.nLeft,
-                        rect.nTop,
-                        rect.nLeft + rect.nWidth - 1,
-                        rect.nTop + rect.nHeight - 1);
-
-                if (mNativeWindow != NULL) {
-                    reply->setRect(
-                            "crop",
-                            rect.nLeft,
-                            rect.nTop,
-                            rect.nLeft + rect.nWidth,
-                            rect.nTop + rect.nHeight);
-                }
+                CHECK_EQ(0, native_window_set_crop(
+                            mNativeWindow.get(), &crop));
             }
             break;
         }
@@ -2664,135 +2192,41 @@
         case OMX_PortDomainAudio:
         {
             OMX_AUDIO_PORTDEFINITIONTYPE *audioDef = &def.format.audio;
+            CHECK_EQ((int)audioDef->eEncoding, (int)OMX_AUDIO_CodingPCM);
 
-            switch (audioDef->eEncoding) {
-                case OMX_AUDIO_CodingPCM:
-                {
-                    OMX_AUDIO_PARAM_PCMMODETYPE params;
-                    InitOMXParams(&params);
-                    params.nPortIndex = kPortIndexOutput;
-
-                    CHECK_EQ(mOMX->getParameter(
-                                mNode, OMX_IndexParamAudioPcm,
-                                &params, sizeof(params)),
-                             (status_t)OK);
-
-                    CHECK_GT(params.nChannels, 0);
-                    CHECK(params.nChannels == 1 || params.bInterleaved);
-                    CHECK_EQ(params.nBitPerSample, 16u);
-
-                    CHECK_EQ((int)params.eNumData,
-                             (int)OMX_NumericalDataSigned);
-
-                    CHECK_EQ((int)params.ePCMMode,
-                             (int)OMX_AUDIO_PCMModeLinear);
-
-                    notify->setString("mime", MEDIA_MIMETYPE_AUDIO_RAW);
-                    notify->setInt32("channel-count", params.nChannels);
-                    notify->setInt32("sample-rate", params.nSamplingRate);
-                    if (mEncoderDelay + mEncoderPadding) {
-                        size_t frameSize = params.nChannels * sizeof(int16_t);
-                        if (mSkipCutBuffer != NULL) {
-                            size_t prevbufsize = mSkipCutBuffer->size();
-                            if (prevbufsize != 0) {
-                                ALOGW("Replacing SkipCutBuffer holding %d "
-                                      "bytes",
-                                      prevbufsize);
-                            }
-                        }
-                        mSkipCutBuffer = new SkipCutBuffer(
-                                mEncoderDelay * frameSize,
-                                mEncoderPadding * frameSize);
-                    }
-
-                    if (mChannelMaskPresent) {
-                        notify->setInt32("channel-mask", mChannelMask);
-                    }
-                    break;
-                }
-
-                case OMX_AUDIO_CodingAAC:
-                {
-                    OMX_AUDIO_PARAM_AACPROFILETYPE params;
-                    InitOMXParams(&params);
-                    params.nPortIndex = kPortIndexOutput;
-
-                    CHECK_EQ(mOMX->getParameter(
-                                mNode, OMX_IndexParamAudioAac,
-                                &params, sizeof(params)),
-                             (status_t)OK);
-
-                    notify->setString("mime", MEDIA_MIMETYPE_AUDIO_AAC);
-                    notify->setInt32("channel-count", params.nChannels);
-                    notify->setInt32("sample-rate", params.nSampleRate);
-                    break;
-                }
-
-                case OMX_AUDIO_CodingAMR:
-                {
-                    OMX_AUDIO_PARAM_AMRTYPE params;
-                    InitOMXParams(&params);
-                    params.nPortIndex = kPortIndexOutput;
-
-                    CHECK_EQ(mOMX->getParameter(
-                                mNode, OMX_IndexParamAudioAmr,
-                                &params, sizeof(params)),
-                             (status_t)OK);
+            OMX_AUDIO_PARAM_PCMMODETYPE params;
+            InitOMXParams(&params);
+            params.nPortIndex = kPortIndexOutput;
 
-                    notify->setInt32("channel-count", 1);
-                    if (params.eAMRBandMode >= OMX_AUDIO_AMRBandModeWB0) {
-                        notify->setString(
-                                "mime", MEDIA_MIMETYPE_AUDIO_AMR_WB);
-
-                        notify->setInt32("sample-rate", 16000);
-                    } else {
-                        notify->setString(
-                                "mime", MEDIA_MIMETYPE_AUDIO_AMR_NB);
+            CHECK_EQ(mOMX->getParameter(
+                        mNode, OMX_IndexParamAudioPcm,
+                        &params, sizeof(params)),
+                     (status_t)OK);
 
-                        notify->setInt32("sample-rate", 8000);
+            CHECK(params.nChannels == 1 || params.bInterleaved);
+            CHECK_EQ(params.nBitPerSample, 16u);
+            CHECK_EQ((int)params.eNumData, (int)OMX_NumericalDataSigned);
+            CHECK_EQ((int)params.ePCMMode, (int)OMX_AUDIO_PCMModeLinear);
+
+            notify->setString("mime", MEDIA_MIMETYPE_AUDIO_RAW);
+            notify->setInt32("channel-count", params.nChannels);
+            notify->setInt32("sample-rate", params.nSamplingRate);
+            if (mEncoderDelay + mEncoderPadding) {
+                size_t frameSize = params.nChannels * sizeof(int16_t);
+                if (mSkipCutBuffer != NULL) {
+                    size_t prevbufsize = mSkipCutBuffer->size();
+                    if (prevbufsize != 0) {
+                        ALOGW("Replacing SkipCutBuffer holding %d bytes", prevbufsize);
                     }
-                    break;
-                }
-
-                case OMX_AUDIO_CodingFLAC:
-                {
-                    OMX_AUDIO_PARAM_FLACTYPE params;
-                    InitOMXParams(&params);
-                    params.nPortIndex = kPortIndexOutput;
-
-                    CHECK_EQ(mOMX->getParameter(
-                                mNode, OMX_IndexParamAudioFlac,
-                                &params, sizeof(params)),
-                             (status_t)OK);
-
-                    notify->setString("mime", MEDIA_MIMETYPE_AUDIO_FLAC);
-                    notify->setInt32("channel-count", params.nChannels);
-                    notify->setInt32("sample-rate", params.nSampleRate);
-                    break;
                 }
+                mSkipCutBuffer = new SkipCutBuffer(mEncoderDelay * frameSize,
+                                                   mEncoderPadding * frameSize);
+            }
 
-                default:
-                {
-#ifdef QCOM_HARDWARE
-                    AString mimeType;
-                    status_t err = ExtendedCodec::handleSupportedAudioFormats(
-                        audioDef->eEncoding, &mimeType);
-                    if (err == OK) {
-                        int channelCount;
-                        err = ExtendedCodec::getSupportedAudioFormatInfo(
-                                      &mimeType,
-                                      mOMX,
-                                      mNode,
-                                      kPortIndexOutput,
-                                      &channelCount);
-                        notify->setString("mime", mimeType.c_str());
-                        notify->setInt32("channel-count", channelCount);
-                        break;
-                    }
-#endif
-                    TRESPASS();
-                }
+            if (mChannelMaskPresent) {
+                notify->setInt32("channel-mask", mChannelMask);
             }
+
             break;
         }
 
@@ -2846,14 +2280,6 @@
         goto error;
     }
 
-    err = native_window_set_scaling_mode(mNativeWindow.get(),
-                NATIVE_WINDOW_SCALING_MODE_SCALE_TO_WINDOW);
-    if (err != NO_ERROR) {
-        ALOGE("error pushing blank_frames: set_scaling_mode failed: %s (%d)",
-              strerror(-err), -err);
-        goto error;
-    }
-
     err = native_window_set_usage(mNativeWindow.get(),
             GRALLOC_USAGE_SW_WRITE_OFTEN);
     if (err != NO_ERROR) {
@@ -3029,21 +2455,6 @@
             return onOMXMessage(msg);
         }
 
-        case ACodec::kWhatCreateInputSurface:
-        case ACodec::kWhatSignalEndOfInputStream:
-        {
-            ALOGE("Message 0x%x was not handled", msg->what());
-            mCodec->signalError(OMX_ErrorUndefined, INVALID_OPERATION);
-            return true;
-        }
-
-        case ACodec::kWhatOMXDied:
-        {
-            ALOGE("OMX/mediaserver died, signalling error!");
-            mCodec->signalError(OMX_ErrorResourcesLost, DEAD_OBJECT);
-            break;
-        }
-
         default:
             return false;
     }
@@ -3220,22 +2631,16 @@
     sp<ABuffer> buffer;
     int32_t err = OK;
     bool eos = false;
-    PortMode mode = getPortMode(kPortIndexInput);
 
     if (!msg->findBuffer("buffer", &buffer)) {
-        /* these are unfilled buffers returned by client */
         CHECK(msg->findInt32("err", &err));
 
-        if (err == OK) {
-            /* buffers with no errors are returned on MediaCodec.flush */
-            mode = KEEP_BUFFERS;
-        } else {
-            ALOGV("[%s] saw error %d instead of an input buffer",
-                 mCodec->mComponentName.c_str(), err);
-            eos = true;
-        }
+        ALOGV("[%s] saw error %d instead of an input buffer",
+             mCodec->mComponentName.c_str(), err);
 
         buffer.clear();
+
+        eos = true;
     }
 
     int32_t tmp;
@@ -3249,6 +2654,8 @@
 
     info->mStatus = BufferInfo::OWNED_BY_US;
 
+    PortMode mode = getPortMode(kPortIndexInput);
+
     switch (mode) {
         case KEEP_BUFFERS:
         {
@@ -3311,20 +2718,6 @@
                 mCodec->mBufferStats.add(timeUs, stats);
 #endif
 
-                if (mCodec->mStoreMetaDataInOutputBuffers) {
-                    // try to submit an output buffer for each input buffer
-                    PortMode outputMode = getPortMode(kPortIndexOutput);
-
-                    ALOGV("MetaDataBuffersToSubmit=%u portMode=%s",
-                            mCodec->mMetaDataBuffersToSubmit,
-                            (outputMode == FREE_BUFFERS ? "FREE" :
-                             outputMode == KEEP_BUFFERS ? "KEEP" : "RESUBMIT"));
-                    if (outputMode == RESUBMIT_BUFFERS) {
-                        CHECK_EQ(mCodec->submitOutputMetaDataBuffer(),
-                                (status_t)OK);
-                    }
-                }
-
                 CHECK_EQ(mCodec->mOMX->emptyBuffer(
                             mCodec->mNode,
                             bufferID,
@@ -3442,7 +2835,6 @@
 
     CHECK_EQ((int)info->mStatus, (int)BufferInfo::OWNED_BY_COMPONENT);
 
-    info->mDequeuedAt = ++mCodec->mDequeueCounter;
     info->mStatus = BufferInfo::OWNED_BY_US;
 
     PortMode mode = getPortMode(kPortIndexOutput);
@@ -3465,29 +2857,19 @@
                 break;
             }
 
-            sp<AMessage> reply =
-                new AMessage(kWhatOutputBufferDrained, mCodec->id());
-
-            if (!mCodec->mSentFormat) {
-                mCodec->sendFormatChange(reply);
+            if (!mCodec->mIsEncoder && !mCodec->mSentFormat) {
+                mCodec->sendFormatChange();
             }
 
-            if (mCodec->mUseMetadataOnEncoderOutput) {
-                native_handle_t* handle =
-                        *(native_handle_t**)(info->mData->data() + 4);
-                info->mData->meta()->setPointer("handle", handle);
-                info->mData->meta()->setInt32("rangeOffset", rangeOffset);
-                info->mData->meta()->setInt32("rangeLength", rangeLength);
-            } else {
+            if (mCodec->mNativeWindow == NULL) {
                 info->mData->setRange(rangeOffset, rangeLength);
-            }
+
 #if 0
-            if (mCodec->mNativeWindow == NULL) {
                 if (IsIDR(info->mData)) {
                     ALOGI("IDR frame");
                 }
-            }
 #endif
+            }
 
             if (mCodec->mSkipCutBuffer != NULL) {
                 mCodec->mSkipCutBuffer->submit(info->mData);
@@ -3500,6 +2882,9 @@
             notify->setBuffer("buffer", info->mData);
             notify->setInt32("flags", flags);
 
+            sp<AMessage> reply =
+                new AMessage(kWhatOutputBufferDrained, mCodec->id());
+
             reply->setPointer("buffer-id", info->mBufferID);
 
             notify->setMessage("reply", reply);
@@ -3543,17 +2928,9 @@
         mCodec->findBufferByID(kPortIndexOutput, bufferID, &index);
     CHECK_EQ((int)info->mStatus, (int)BufferInfo::OWNED_BY_DOWNSTREAM);
 
-    android_native_rect_t crop;
-    if (msg->findRect("crop",
-            &crop.left, &crop.top, &crop.right, &crop.bottom)) {
-        CHECK_EQ(0, native_window_set_crop(
-                mCodec->mNativeWindow.get(), &crop));
-    }
-
     int32_t render;
     if (mCodec->mNativeWindow != NULL
-            && msg->findInt32("render", &render) && render != 0
-            && (info->mData == NULL || info->mData->size() != 0)) {
+            && msg->findInt32("render", &render) && render != 0) {
         // The client wants this buffer to be rendered.
 
         status_t err;
@@ -3627,19 +3004,6 @@
 
 void ACodec::UninitializedState::stateEntered() {
     ALOGV("Now uninitialized");
-
-    if (mDeathNotifier != NULL) {
-        mCodec->mOMX->asBinder()->unlinkToDeath(mDeathNotifier);
-        mDeathNotifier.clear();
-    }
-
-    mCodec->mNativeWindow.clear();
-    mCodec->mNode = NULL;
-    mCodec->mOMX.clear();
-    mCodec->mQuirks = 0;
-    mCodec->mFlags = 0;
-    mCodec->mUseMetadataOnEncoderOutput = 0;
-    mCodec->mComponentName.clear();
 }
 
 bool ACodec::UninitializedState::onMessageReceived(const sp<AMessage> &msg) {
@@ -3711,15 +3075,6 @@
 
     sp<IOMX> omx = client.interface();
 
-    sp<AMessage> notify = new AMessage(kWhatOMXDied, mCodec->id());
-
-    mDeathNotifier = new DeathNotifier(notify);
-    if (omx->asBinder()->linkToDeath(mDeathNotifier) != OK) {
-        // This was a local binder, if it dies so do we, we won't care
-        // about any notifications in the afterlife.
-        mDeathNotifier.clear();
-    }
-
     Vector<OMXCodec::CodecNameAndQuirks> matchingCodecs;
 
     AString mime;
@@ -3758,9 +3113,6 @@
             ++matchIndex) {
         componentName = matchingCodecs.itemAt(matchIndex).mName.string();
         quirks = matchingCodecs.itemAt(matchIndex).mQuirks;
-#ifdef QCOM_HARDWARE
-        ExtendedCodec::overrideComponentName(quirks, msg, &componentName);
-#endif
 
         pid_t tid = androidGetTid();
         int prevPriority = androidGetThreadPriority(tid);
@@ -3787,7 +3139,7 @@
         return false;
     }
 
-    notify = new AMessage(kWhatOMXMessage, mCodec->id());
+    sp<AMessage> notify = new AMessage(kWhatOMXMessage, mCodec->id());
     observer->setNotificationMessage(notify);
 
     mCodec->mComponentName = componentName;
@@ -3795,13 +3147,17 @@
 
     if (componentName.endsWith(".secure")) {
         mCodec->mFlags |= kFlagIsSecure;
-        mCodec->mFlags |= kFlagPushBlankBuffersToNativeWindowOnShutdown;
     }
 
     mCodec->mQuirks = quirks;
     mCodec->mOMX = omx;
     mCodec->mNode = node;
 
+    mCodec->mPortEOS[kPortIndexInput] =
+        mCodec->mPortEOS[kPortIndexOutput] = false;
+
+    mCodec->mInputEOSResult = OK;
+
     {
         sp<AMessage> notify = mCodec->mNotify->dup();
         notify->setInt32("what", ACodec::kWhatComponentAllocated);
@@ -3823,15 +3179,6 @@
 void ACodec::LoadedState::stateEntered() {
     ALOGV("[%s] Now Loaded", mCodec->mComponentName.c_str());
 
-    mCodec->mPortEOS[kPortIndexInput] =
-        mCodec->mPortEOS[kPortIndexOutput] = false;
-
-    mCodec->mInputEOSResult = OK;
-
-    mCodec->mDequeueCounter = 0;
-    mCodec->mMetaDataBuffersToSubmit = 0;
-    mCodec->mRepeatFrameDelayUs = -1ll;
-
     if (mCodec->mShutdownInProgress) {
         bool keepComponentAllocated = mCodec->mKeepComponentAllocated;
 
@@ -3846,6 +3193,13 @@
     if (!keepComponentAllocated) {
         CHECK_EQ(mCodec->mOMX->freeNode(mCodec->mNode), (status_t)OK);
 
+        mCodec->mNativeWindow.clear();
+        mCodec->mNode = NULL;
+        mCodec->mOMX.clear();
+        mCodec->mQuirks = 0;
+        mCodec->mFlags = 0;
+        mCodec->mComponentName.clear();
+
         mCodec->changeState(mCodec->mUninitializedState);
     }
 
@@ -3865,13 +3219,6 @@
             break;
         }
 
-        case ACodec::kWhatCreateInputSurface:
-        {
-            onCreateInputSurface(msg);
-            handled = true;
-            break;
-        }
-
         case ACodec::kWhatStart:
         {
             onStart();
@@ -3950,49 +3297,6 @@
     return true;
 }
 
-void ACodec::LoadedState::onCreateInputSurface(
-        const sp<AMessage> &msg) {
-    ALOGV("onCreateInputSurface");
-
-    sp<AMessage> notify = mCodec->mNotify->dup();
-    notify->setInt32("what", ACodec::kWhatInputSurfaceCreated);
-
-    sp<IGraphicBufferProducer> bufferProducer;
-    status_t err;
-
-    err = mCodec->mOMX->createInputSurface(mCodec->mNode, kPortIndexInput,
-            &bufferProducer);
-
-    if (err == OK && mCodec->mRepeatFrameDelayUs > 0ll) {
-        err = mCodec->mOMX->setInternalOption(
-                mCodec->mNode,
-                kPortIndexInput,
-                IOMX::INTERNAL_OPTION_REPEAT_PREVIOUS_FRAME_DELAY,
-                &mCodec->mRepeatFrameDelayUs,
-                sizeof(mCodec->mRepeatFrameDelayUs));
-
-        if (err != OK) {
-            ALOGE("[%s] Unable to configure option to repeat previous "
-                  "frames (err %d)",
-                  mCodec->mComponentName.c_str(),
-                  err);
-        }
-    }
-
-    if (err == OK) {
-        notify->setObject("input-surface",
-                new BufferProducerWrapper(bufferProducer));
-    } else {
-        // Can't use mCodec->signalError() here -- MediaCodec won't forward
-        // the error through because it's in the "configured" state.  We
-        // send a kWhatInputSurfaceCreated with an error value instead.
-        ALOGE("[%s] onCreateInputSurface returning error %d",
-                mCodec->mComponentName.c_str(), err);
-        notify->setInt32("err", err);
-    }
-    notify->post();
-}
-
 void ACodec::LoadedState::onStart() {
     ALOGV("onStart");
 
@@ -4042,27 +3346,6 @@
             return true;
         }
 
-        case kWhatSignalEndOfInputStream:
-        {
-            mCodec->onSignalEndOfInputStream();
-            return true;
-        }
-
-        case kWhatResume:
-        {
-            // We'll be active soon enough.
-            return true;
-        }
-
-        case kWhatFlush:
-        {
-            // We haven't even started yet, so we're flushed alright...
-            sp<AMessage> notify = mCodec->mNotify->dup();
-            notify->setInt32("what", ACodec::kWhatFlushCompleted);
-            notify->post();
-            return true;
-        }
-
         default:
             return BaseState::onMessageReceived(msg);
     }
@@ -4108,28 +3391,6 @@
             return true;
         }
 
-        case kWhatResume:
-        {
-            // We'll be active soon enough.
-            return true;
-        }
-
-        case kWhatFlush:
-        {
-            // We haven't even started yet, so we're flushed alright...
-            sp<AMessage> notify = mCodec->mNotify->dup();
-            notify->setInt32("what", ACodec::kWhatFlushCompleted);
-            notify->post();
-
-            return true;
-        }
-
-        case kWhatSignalEndOfInputStream:
-        {
-            mCodec->onSignalEndOfInputStream();
-            return true;
-        }
-
         default:
             return BaseState::onMessageReceived(msg);
     }
@@ -4166,23 +3427,7 @@
     return RESUBMIT_BUFFERS;
 }
 
-void ACodec::ExecutingState::submitOutputMetaBuffers() {
-    // submit as many buffers as there are input buffers with the codec
-    // in case we are in port reconfiguring
-    for (size_t i = 0; i < mCodec->mBuffers[kPortIndexInput].size(); ++i) {
-        BufferInfo *info = &mCodec->mBuffers[kPortIndexInput].editItemAt(i);
-
-        if (info->mStatus == BufferInfo::OWNED_BY_COMPONENT) {
-            if (mCodec->submitOutputMetaDataBuffer() != OK)
-                break;
-        }
-    }
-
-    // *** NOTE: THE FOLLOWING WORKAROUND WILL BE REMOVED ***
-    mCodec->signalSubmitOutputMetaDataBufferIfEOS_workaround();
-}
-
-void ACodec::ExecutingState::submitRegularOutputBuffers() {
+void ACodec::ExecutingState::submitOutputBuffers() {
     for (size_t i = 0; i < mCodec->mBuffers[kPortIndexOutput].size(); ++i) {
         BufferInfo *info = &mCodec->mBuffers[kPortIndexOutput].editItemAt(i);
 
@@ -4207,13 +3452,6 @@
     }
 }
 
-void ACodec::ExecutingState::submitOutputBuffers() {
-    submitRegularOutputBuffers();
-    if (mCodec->mStoreMetaDataInOutputBuffers) {
-        submitOutputMetaBuffers();
-    }
-}
-
 void ACodec::ExecutingState::resume() {
     if (mActive) {
         ALOGV("[%s] We're already active, no need to resume.",
@@ -4281,6 +3519,7 @@
                      (status_t)OK);
 
             mCodec->changeState(mCodec->mFlushingState);
+
             handled = true;
             break;
         }
@@ -4304,43 +3543,6 @@
             break;
         }
 
-        case kWhatSetParameters:
-        {
-            sp<AMessage> params;
-            CHECK(msg->findMessage("params", &params));
-
-            status_t err = mCodec->setParameters(params);
-
-            sp<AMessage> reply;
-            if (msg->findMessage("reply", &reply)) {
-                reply->setInt32("err", err);
-                reply->post();
-            }
-
-            handled = true;
-            break;
-        }
-
-        case ACodec::kWhatSignalEndOfInputStream:
-        {
-            mCodec->onSignalEndOfInputStream();
-            handled = true;
-            break;
-        }
-
-        // *** NOTE: THE FOLLOWING WORKAROUND WILL BE REMOVED ***
-        case kWhatSubmitOutputMetaDataBufferIfEOS:
-        {
-            if (mCodec->mPortEOS[kPortIndexInput] &&
-                    !mCodec->mPortEOS[kPortIndexOutput]) {
-                status_t err = mCodec->submitOutputMetaDataBuffer();
-                if (err == OK) {
-                    mCodec->signalSubmitOutputMetaDataBufferIfEOS_workaround();
-                }
-            }
-            return true;
-        }
-
         default:
             handled = BaseState::onMessageReceived(msg);
             break;
@@ -4349,70 +3551,6 @@
     return handled;
 }
 
-status_t ACodec::setParameters(const sp<AMessage> &params) {
-    int32_t videoBitrate;
-    if (params->findInt32("video-bitrate", &videoBitrate)) {
-        OMX_VIDEO_CONFIG_BITRATETYPE configParams;
-        InitOMXParams(&configParams);
-        configParams.nPortIndex = kPortIndexOutput;
-        configParams.nEncodeBitrate = videoBitrate;
-
-        status_t err = mOMX->setConfig(
-                mNode,
-                OMX_IndexConfigVideoBitrate,
-                &configParams,
-                sizeof(configParams));
-
-        if (err != OK) {
-            ALOGE("setConfig(OMX_IndexConfigVideoBitrate, %d) failed w/ err %d",
-                   videoBitrate, err);
-
-            return err;
-        }
-    }
-
-    int32_t dropInputFrames;
-    if (params->findInt32("drop-input-frames", &dropInputFrames)) {
-        bool suspend = dropInputFrames != 0;
-
-        status_t err =
-            mOMX->setInternalOption(
-                     mNode,
-                     kPortIndexInput,
-                     IOMX::INTERNAL_OPTION_SUSPEND,
-                     &suspend,
-                     sizeof(suspend));
-
-        if (err != OK) {
-            ALOGE("Failed to set parameter 'drop-input-frames' (err %d)", err);
-            return err;
-        }
-    }
-
-    int32_t dummy;
-    if (params->findInt32("request-sync", &dummy)) {
-        status_t err = requestIDRFrame();
-
-        if (err != OK) {
-            ALOGE("Requesting a sync frame failed w/ err %d", err);
-            return err;
-        }
-    }
-
-    return OK;
-}
-
-void ACodec::onSignalEndOfInputStream() {
-    sp<AMessage> notify = mNotify->dup();
-    notify->setInt32("what", ACodec::kWhatSignaledInputEOS);
-
-    status_t err = mOMX->signalEndOfInputStream(mNode);
-    if (err != OK) {
-        notify->setInt32("err", err);
-    }
-    notify->post();
-}
-
 bool ACodec::ExecutingState::onOMXEvent(
         OMX_EVENTTYPE event, OMX_U32 data1, OMX_U32 data2) {
     switch (event) {
@@ -4421,7 +3559,6 @@
             CHECK_EQ(data1, (OMX_U32)kPortIndexOutput);
 
             if (data2 == 0 || data2 == OMX_IndexParamPortDefinition) {
-                mCodec->mMetaDataBuffersToSubmit = 0;
                 CHECK_EQ(mCodec->mOMX->sendCommand(
                             mCodec->mNode,
                             OMX_CommandPortDisable, kPortIndexOutput),
@@ -4640,8 +3777,7 @@
         CHECK_EQ(mCodec->freeBuffersOnPort(kPortIndexInput), (status_t)OK);
         CHECK_EQ(mCodec->freeBuffersOnPort(kPortIndexOutput), (status_t)OK);
 
-        if ((mCodec->mFlags & kFlagPushBlankBuffersToNativeWindowOnShutdown)
-                && mCodec->mNativeWindow != NULL) {
+        if (mCodec->mFlags & kFlagIsSecure && mCodec->mNativeWindow != NULL) {
             // We push enough 1x1 blank buffers to ensure that one of
             // them has made it to the display.  This allows the OMX
             // component teardown to zero out any protected buffers
@@ -4829,10 +3965,6 @@
     if (mFlushComplete[kPortIndexInput]
             && mFlushComplete[kPortIndexOutput]
             && mCodec->allYourBuffersAreBelongToUs()) {
-        // We now own all buffers except possibly those still queued with
-        // the native window for rendering. Let's get those back as well.
-        mCodec->waitUntilAllPossibleNativeWindowBuffersAreReturnedToUs();
-
         sp<AMessage> notify = mCodec->mNotify->dup();
         notify->setInt32("what", ACodec::kWhatFlushCompleted);
         notify->post();
@@ -4842,10 +3974,6 @@
 
         mCodec->mInputEOSResult = OK;
 
-        if (mCodec->mSkipCutBuffer != NULL) {
-            mCodec->mSkipCutBuffer->clear();
-        }
-
         mCodec->changeState(mCodec->mExecutingState);
     }
 }
diff -Naur a/frameworks/av/media/libstagefright/wifi-display/Android.mk b/frameworks/av/media/libstagefright/wifi-display/Android.mk
--- a/frameworks/av/media/libstagefright/wifi-display/Android.mk	2014-03-23 23:08:08.439581000 -0400
+++ b/frameworks/av/media/libstagefright/wifi-display/Android.mk	2014-03-24 10:33:44.992435504 -0400
@@ -3,9 +3,18 @@
 include $(CLEAR_VARS)
 
 LOCAL_SRC_FILES:= \
+        ANetworkSession.cpp             \
+        MediaReceiver.cpp               \
         MediaSender.cpp                 \
         Parameters.cpp                  \
+        ParsedMessage.cpp               \
+        rtp/RTPAssembler.cpp            \
+        rtp/RTPReceiver.cpp             \
         rtp/RTPSender.cpp               \
+        sink/DirectRenderer.cpp         \
+        sink/WifiDisplaySink.cpp        \
+        SNTPClient.cpp                  \
+        TimeSyncer.cpp                  \
         source/Converter.cpp            \
         source/MediaPuller.cpp          \
         source/PlaybackSession.cpp      \
@@ -40,3 +49,87 @@
 LOCAL_MODULE_TAGS:= optional
 
 include $(BUILD_SHARED_LIBRARY)
+
+################################################################################
+
+include $(CLEAR_VARS)
+
+LOCAL_SRC_FILES:= \
+        wfd.cpp                 \
+
+LOCAL_SHARED_LIBRARIES:= \
+        libbinder                       \
+        libgui                          \
+        libmedia                        \
+        libstagefright                  \
+        libstagefright_foundation       \
+        libstagefright_wfd              \
+        libutils                        \
+        liblog                          \
+
+LOCAL_MODULE:= wfd
+
+include $(BUILD_EXECUTABLE)
+
+################################################################################
+
+include $(CLEAR_VARS)
+
+LOCAL_SRC_FILES:= \
+        udptest.cpp                 \
+
+LOCAL_SHARED_LIBRARIES:= \
+        libbinder                       \
+        libgui                          \
+        libmedia                        \
+        libstagefright                  \
+        libstagefright_foundation       \
+        libstagefright_wfd              \
+        libutils                        \
+        liblog                          \
+
+LOCAL_MODULE:= udptest
+
+include $(BUILD_EXECUTABLE)
+
+################################################################################
+
+include $(CLEAR_VARS)
+
+LOCAL_SRC_FILES:= \
+        rtptest.cpp                 \
+
+LOCAL_SHARED_LIBRARIES:= \
+        libbinder                       \
+        libgui                          \
+        libmedia                        \
+        libstagefright                  \
+        libstagefright_foundation       \
+        libstagefright_wfd              \
+        libutils                        \
+        liblog                          \
+
+LOCAL_MODULE:= rtptest
+
+include $(BUILD_EXECUTABLE)
+
+################################################################################
+
+include $(CLEAR_VARS)
+
+LOCAL_SRC_FILES:= \
+        nettest.cpp                     \
+
+LOCAL_SHARED_LIBRARIES:= \
+        libbinder                       \
+        libgui                          \
+        libmedia                        \
+        libstagefright                  \
+        libstagefright_foundation       \
+        libstagefright_wfd              \
+        libutils                        \
+        liblog                          \
+
+LOCAL_MODULE:= nettest
+
+include $(BUILD_EXECUTABLE)
diff -Naur a/frameworks/av/media/libstagefright/wifi-display/ANetworkSession.cpp b/frameworks/av/media/libstagefright/wifi-display/ANetworkSession.cpp
--- a/frameworks/av/media/libstagefright/wifi-display/ANetworkSession.cpp	1969-12-31 19:00:00.000000000 -0500
+++ b/frameworks/av/media/libstagefright/wifi-display/ANetworkSession.cpp	2013-08-14 04:13:30.000000000 -0400
@@ -0,0 +1,1153 @@
+/*
+ * Copyright 2012, The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+//#define LOG_NDEBUG 0
+#define LOG_TAG "NetworkSession"
+#include <utils/Log.h>
+
+#include "ANetworkSession.h"
+#include "ParsedMessage.h"
+
+#include <arpa/inet.h>
+#include <fcntl.h>
+#include <net/if.h>
+#include <netdb.h>
+#include <netinet/in.h>
+#include <sys/socket.h>
+
+#include <media/stagefright/foundation/ABuffer.h>
+#include <media/stagefright/foundation/ADebug.h>
+#include <media/stagefright/foundation/AMessage.h>
+#include <media/stagefright/foundation/hexdump.h>
+#include <media/stagefright/Utils.h>
+
+#include <cutils/properties.h> // for property_get
+
+namespace android {
+
+static const size_t kMaxUDPSize = 1500;
+
+struct ANetworkSession::NetworkThread : public Thread {
+    NetworkThread(ANetworkSession *session);
+
+protected:
+    virtual ~NetworkThread();
+
+private:
+    ANetworkSession *mSession;
+
+    virtual bool threadLoop();
+
+    DISALLOW_EVIL_CONSTRUCTORS(NetworkThread);
+};
+
+struct ANetworkSession::Session : public RefBase {
+    enum State {
+        CONNECTING,
+        CONNECTED,
+        LISTENING_RTSP,
+        LISTENING_TCP_DGRAMS,
+        DATAGRAM,
+    };
+
+    Session(int32_t sessionID,
+            State state,
+            int s,
+            const sp<AMessage> &notify);
+
+    int32_t sessionID() const;
+    int socket() const;
+    sp<AMessage> getNotificationMessage() const;
+
+    bool isRTSPServer() const;
+    bool isTCPDatagramServer() const;
+
+    bool wantsToRead();
+    bool wantsToWrite();
+
+    status_t readMore();
+    status_t writeMore();
+
+    status_t sendRequest(const void *data, ssize_t size);
+
+    void setIsRTSPConnection(bool yesno);
+
+protected:
+    virtual ~Session();
+
+private:
+    int32_t mSessionID;
+    State mState;
+    bool mIsRTSPConnection;
+    int mSocket;
+    sp<AMessage> mNotify;
+    bool mSawReceiveFailure, mSawSendFailure;
+
+    // for TCP / stream data
+    AString mOutBuffer;
+
+    // for UDP / datagrams
+    List<sp<ABuffer> > mOutDatagrams;
+
+    AString mInBuffer;
+
+    void notifyError(bool send, status_t err, const char *detail);
+    void notify(NotificationReason reason);
+
+    DISALLOW_EVIL_CONSTRUCTORS(Session);
+};
+////////////////////////////////////////////////////////////////////////////////
+
+ANetworkSession::NetworkThread::NetworkThread(ANetworkSession *session)
+    : mSession(session) {
+}
+
+ANetworkSession::NetworkThread::~NetworkThread() {
+}
+
+bool ANetworkSession::NetworkThread::threadLoop() {
+    mSession->threadLoop();
+
+    return true;
+}
+
+////////////////////////////////////////////////////////////////////////////////
+
+ANetworkSession::Session::Session(
+        int32_t sessionID,
+        State state,
+        int s,
+        const sp<AMessage> &notify)
+    : mSessionID(sessionID),
+      mState(state),
+      mIsRTSPConnection(false),
+      mSocket(s),
+      mNotify(notify),
+      mSawReceiveFailure(false),
+      mSawSendFailure(false) {
+    if (mState == CONNECTED) {
+        struct sockaddr_in localAddr;
+        socklen_t localAddrLen = sizeof(localAddr);
+
+        int res = getsockname(
+                mSocket, (struct sockaddr *)&localAddr, &localAddrLen);
+        CHECK_GE(res, 0);
+
+        struct sockaddr_in remoteAddr;
+        socklen_t remoteAddrLen = sizeof(remoteAddr);
+
+        res = getpeername(
+                mSocket, (struct sockaddr *)&remoteAddr, &remoteAddrLen);
+        CHECK_GE(res, 0);
+
+        in_addr_t addr = ntohl(localAddr.sin_addr.s_addr);
+        AString localAddrString = StringPrintf(
+                "%d.%d.%d.%d",
+                (addr >> 24),
+                (addr >> 16) & 0xff,
+                (addr >> 8) & 0xff,
+                addr & 0xff);
+
+        addr = ntohl(remoteAddr.sin_addr.s_addr);
+        AString remoteAddrString = StringPrintf(
+                "%d.%d.%d.%d",
+                (addr >> 24),
+                (addr >> 16) & 0xff,
+                (addr >> 8) & 0xff,
+                addr & 0xff);
+
+        sp<AMessage> msg = mNotify->dup();
+        msg->setInt32("sessionID", mSessionID);
+        msg->setInt32("reason", kWhatClientConnected);
+        msg->setString("server-ip", localAddrString.c_str());
+        msg->setInt32("server-port", ntohs(localAddr.sin_port));
+        msg->setString("client-ip", remoteAddrString.c_str());
+        msg->setInt32("client-port", ntohs(remoteAddr.sin_port));
+        msg->post();
+    }
+}
+
+ANetworkSession::Session::~Session() {
+    ALOGV("Session %d gone", mSessionID);
+
+    close(mSocket);
+    mSocket = -1;
+}
+
+int32_t ANetworkSession::Session::sessionID() const {
+    return mSessionID;
+}
+
+int ANetworkSession::Session::socket() const {
+    return mSocket;
+}
+
+void ANetworkSession::Session::setIsRTSPConnection(bool yesno) {
+    mIsRTSPConnection = yesno;
+}
+
+sp<AMessage> ANetworkSession::Session::getNotificationMessage() const {
+    return mNotify;
+}
+
+bool ANetworkSession::Session::isRTSPServer() const {
+    return mState == LISTENING_RTSP;
+}
+
+bool ANetworkSession::Session::isTCPDatagramServer() const {
+    return mState == LISTENING_TCP_DGRAMS;
+}
+
+bool ANetworkSession::Session::wantsToRead() {
+    return !mSawReceiveFailure && mState != CONNECTING;
+}
+
+bool ANetworkSession::Session::wantsToWrite() {
+    return !mSawSendFailure
+        && (mState == CONNECTING
+            || (mState == CONNECTED && !mOutBuffer.empty())
+            || (mState == DATAGRAM && !mOutDatagrams.empty()));
+}
+
+status_t ANetworkSession::Session::readMore() {
+    if (mState == DATAGRAM) {
+        status_t err;
+        do {
+            sp<ABuffer> buf = new ABuffer(kMaxUDPSize);
+
+            struct sockaddr_in remoteAddr;
+            socklen_t remoteAddrLen = sizeof(remoteAddr);
+
+            ssize_t n;
+            do {
+                n = recvfrom(
+                        mSocket, buf->data(), buf->capacity(), 0,
+                        (struct sockaddr *)&remoteAddr, &remoteAddrLen);
+            } while (n < 0 && errno == EINTR);
+
+            err = OK;
+            if (n < 0) {
+                err = -errno;
+            } else if (n == 0) {
+                err = -ECONNRESET;
+            } else {
+                buf->setRange(0, n);
+
+                int64_t nowUs = ALooper::GetNowUs();
+                buf->meta()->setInt64("arrivalTimeUs", nowUs);
+
+                sp<AMessage> notify = mNotify->dup();
+                notify->setInt32("sessionID", mSessionID);
+                notify->setInt32("reason", kWhatDatagram);
+
+                uint32_t ip = ntohl(remoteAddr.sin_addr.s_addr);
+                notify->setString(
+                        "fromAddr",
+                        StringPrintf(
+                            "%u.%u.%u.%u",
+                            ip >> 24,
+                            (ip >> 16) & 0xff,
+                            (ip >> 8) & 0xff,
+                            ip & 0xff).c_str());
+
+                notify->setInt32("fromPort", ntohs(remoteAddr.sin_port));
+
+                notify->setBuffer("data", buf);
+                notify->post();
+            }
+        } while (err == OK);
+
+        if (err == -EAGAIN) {
+            err = OK;
+        }
+
+        if (err != OK) {
+            notifyError(false /* send */, err, "Recvfrom failed.");
+            mSawReceiveFailure = true;
+        }
+
+        return err;
+    }
+
+    char tmp[512];
+    ssize_t n;
+    do {
+        n = recv(mSocket, tmp, sizeof(tmp), 0);
+    } while (n < 0 && errno == EINTR);
+
+    status_t err = OK;
+
+    if (n > 0) {
+        mInBuffer.append(tmp, n);
+
+#if 0
+        ALOGI("in:");
+        hexdump(tmp, n);
+#endif
+    } else if (n < 0) {
+        err = -errno;
+    } else {
+        err = -ECONNRESET;
+    }
+
+    if (!mIsRTSPConnection) {
+        // TCP stream carrying 16-bit length-prefixed datagrams.
+
+        while (mInBuffer.size() >= 2) {
+            size_t packetSize = U16_AT((const uint8_t *)mInBuffer.c_str());
+
+            if (mInBuffer.size() < packetSize + 2) {
+                break;
+            }
+
+            sp<ABuffer> packet = new ABuffer(packetSize);
+            memcpy(packet->data(), mInBuffer.c_str() + 2, packetSize);
+
+            sp<AMessage> notify = mNotify->dup();
+            notify->setInt32("sessionID", mSessionID);
+            notify->setInt32("reason", kWhatDatagram);
+            notify->setBuffer("data", packet);
+            notify->post();
+
+            mInBuffer.erase(0, packetSize + 2);
+        }
+    } else {
+        for (;;) {
+            size_t length;
+
+            if (mInBuffer.size() > 0 && mInBuffer.c_str()[0] == '$') {
+                if (mInBuffer.size() < 4) {
+                    break;
+                }
+
+                length = U16_AT((const uint8_t *)mInBuffer.c_str() + 2);
+
+                if (mInBuffer.size() < 4 + length) {
+                    break;
+                }
+
+                sp<AMessage> notify = mNotify->dup();
+                notify->setInt32("sessionID", mSessionID);
+                notify->setInt32("reason", kWhatBinaryData);
+                notify->setInt32("channel", mInBuffer.c_str()[1]);
+
+                sp<ABuffer> data = new ABuffer(length);
+                memcpy(data->data(), mInBuffer.c_str() + 4, length);
+
+                int64_t nowUs = ALooper::GetNowUs();
+                data->meta()->setInt64("arrivalTimeUs", nowUs);
+
+                notify->setBuffer("data", data);
+                notify->post();
+
+                mInBuffer.erase(0, 4 + length);
+                continue;
+            }
+
+            sp<ParsedMessage> msg =
+                ParsedMessage::Parse(
+                        mInBuffer.c_str(), mInBuffer.size(), err != OK, &length);
+
+            if (msg == NULL) {
+                break;
+            }
+
+            sp<AMessage> notify = mNotify->dup();
+            notify->setInt32("sessionID", mSessionID);
+            notify->setInt32("reason", kWhatData);
+            notify->setObject("data", msg);
+            notify->post();
+
+#if 1
+            // XXX The (old) dongle sends the wrong content length header on a
+            // SET_PARAMETER request that signals a "wfd_idr_request".
+            // (17 instead of 19).
+            const char *content = msg->getContent();
+            if (content
+                    && !memcmp(content, "wfd_idr_request\r\n", 17)
+                    && length >= 19
+                    && mInBuffer.c_str()[length] == '\r'
+                    && mInBuffer.c_str()[length + 1] == '\n') {
+                length += 2;
+            }
+#endif
+
+            mInBuffer.erase(0, length);
+
+            if (err != OK) {
+                break;
+            }
+        }
+    }
+
+    if (err != OK) {
+        notifyError(false /* send */, err, "Recv failed.");
+        mSawReceiveFailure = true;
+    }
+
+    return err;
+}
+
+status_t ANetworkSession::Session::writeMore() {
+    if (mState == DATAGRAM) {
+        CHECK(!mOutDatagrams.empty());
+
+        status_t err;
+        do {
+            const sp<ABuffer> &datagram = *mOutDatagrams.begin();
+
+            uint8_t *data = datagram->data();
+            if (data[0] == 0x80 && (data[1] & 0x7f) == 33) {
+                int64_t nowUs = ALooper::GetNowUs();
+
+                uint32_t prevRtpTime = U32_AT(&data[4]);
+
+                // 90kHz time scale
+                uint32_t rtpTime = (nowUs * 9ll) / 100ll;
+                int32_t diffTime = (int32_t)rtpTime - (int32_t)prevRtpTime;
+
+                ALOGV("correcting rtpTime by %.0f ms", diffTime / 90.0);
+
+                data[4] = rtpTime >> 24;
+                data[5] = (rtpTime >> 16) & 0xff;
+                data[6] = (rtpTime >> 8) & 0xff;
+                data[7] = rtpTime & 0xff;
+            }
+
+            int n;
+            do {
+                n = send(mSocket, datagram->data(), datagram->size(), 0);
+            } while (n < 0 && errno == EINTR);
+
+            err = OK;
+
+            if (n > 0) {
+                mOutDatagrams.erase(mOutDatagrams.begin());
+            } else if (n < 0) {
+                err = -errno;
+            } else if (n == 0) {
+                err = -ECONNRESET;
+            }
+        } while (err == OK && !mOutDatagrams.empty());
+
+        if (err == -EAGAIN) {
+            if (!mOutDatagrams.empty()) {
+                ALOGI("%d datagrams remain queued.", mOutDatagrams.size());
+            }
+            err = OK;
+        }
+
+        if (err != OK) {
+            notifyError(true /* send */, err, "Send datagram failed.");
+            mSawSendFailure = true;
+        }
+
+        return err;
+    }
+
+    if (mState == CONNECTING) {
+        int err;
+        socklen_t optionLen = sizeof(err);
+        CHECK_EQ(getsockopt(mSocket, SOL_SOCKET, SO_ERROR, &err, &optionLen), 0);
+        CHECK_EQ(optionLen, (socklen_t)sizeof(err));
+
+        if (err != 0) {
+            notifyError(kWhatError, -err, "Connection failed");
+            mSawSendFailure = true;
+
+            return -err;
+        }
+
+        mState = CONNECTED;
+        notify(kWhatConnected);
+
+        return OK;
+    }
+
+    CHECK_EQ(mState, CONNECTED);
+    CHECK(!mOutBuffer.empty());
+
+    ssize_t n;
+    do {
+        n = send(mSocket, mOutBuffer.c_str(), mOutBuffer.size(), 0);
+    } while (n < 0 && errno == EINTR);
+
+    status_t err = OK;
+
+    if (n > 0) {
+#if 0
+        ALOGI("out:");
+        hexdump(mOutBuffer.c_str(), n);
+#endif
+
+        mOutBuffer.erase(0, n);
+    } else if (n < 0) {
+        err = -errno;
+    } else if (n == 0) {
+        err = -ECONNRESET;
+    }
+
+    if (err != OK) {
+        notifyError(true /* send */, err, "Send failed.");
+        mSawSendFailure = true;
+    }
+
+    return err;
+}
+
+status_t ANetworkSession::Session::sendRequest(const void *data, ssize_t size) {
+    CHECK(mState == CONNECTED || mState == DATAGRAM);
+
+    if (mState == DATAGRAM) {
+        CHECK_GE(size, 0);
+
+        sp<ABuffer> datagram = new ABuffer(size);
+        memcpy(datagram->data(), data, size);
+
+        mOutDatagrams.push_back(datagram);
+        return OK;
+    }
+
+    if (mState == CONNECTED && !mIsRTSPConnection) {
+        CHECK_LE(size, 65535);
+
+        uint8_t prefix[2];
+        prefix[0] = size >> 8;
+        prefix[1] = size & 0xff;
+
+        mOutBuffer.append((const char *)prefix, sizeof(prefix));
+    }
+
+    mOutBuffer.append(
+            (const char *)data,
+            (size >= 0) ? size : strlen((const char *)data));
+
+    return OK;
+}
+
+void ANetworkSession::Session::notifyError(
+        bool send, status_t err, const char *detail) {
+    sp<AMessage> msg = mNotify->dup();
+    msg->setInt32("sessionID", mSessionID);
+    msg->setInt32("reason", kWhatError);
+    msg->setInt32("send", send);
+    msg->setInt32("err", err);
+    msg->setString("detail", detail);
+    msg->post();
+}
+
+void ANetworkSession::Session::notify(NotificationReason reason) {
+    sp<AMessage> msg = mNotify->dup();
+    msg->setInt32("sessionID", mSessionID);
+    msg->setInt32("reason", reason);
+    msg->post();
+}
+
+////////////////////////////////////////////////////////////////////////////////
+
+ANetworkSession::ANetworkSession()
+    : mNextSessionID(1) {
+    mPipeFd[0] = mPipeFd[1] = -1;
+
+    // diabled send log output
+    char val[PROPERTY_VALUE_MAX];
+    mDiabledLog = property_get("persist.sys.wfd.disablelog", val, NULL) && strcmp("1", val) == 0;
+
+    ALOGD("ANetworkSession() mDiabledLog[%d] log-output[%s]", mDiabledLog, mDiabledLog?"false":"true");
+}
+
+ANetworkSession::~ANetworkSession() {
+    stop();
+}
+
+status_t ANetworkSession::start() {
+    if (mThread != NULL) {
+        return INVALID_OPERATION;
+    }
+
+    int res = pipe(mPipeFd);
+    if (res != 0) {
+        mPipeFd[0] = mPipeFd[1] = -1;
+        return -errno;
+    }
+
+    mThread = new NetworkThread(this);
+
+    status_t err = mThread->run("ANetworkSession", ANDROID_PRIORITY_AUDIO);
+
+    if (err != OK) {
+        mThread.clear();
+
+        close(mPipeFd[0]);
+        close(mPipeFd[1]);
+        mPipeFd[0] = mPipeFd[1] = -1;
+
+        return err;
+    }
+
+    return OK;
+}
+
+status_t ANetworkSession::stop() {
+    if (mThread == NULL) {
+        return INVALID_OPERATION;
+    }
+
+    mThread->requestExit();
+    interrupt();
+    mThread->requestExitAndWait();
+
+    mThread.clear();
+
+    close(mPipeFd[0]);
+    close(mPipeFd[1]);
+    mPipeFd[0] = mPipeFd[1] = -1;
+
+    return OK;
+}
+
+status_t ANetworkSession::createRTSPClient(
+        const char *host, unsigned port, const sp<AMessage> &notify,
+        int32_t *sessionID) {
+    return createClientOrServer(
+            kModeCreateRTSPClient,
+            NULL /* addr */,
+            0 /* port */,
+            host,
+            port,
+            notify,
+            sessionID);
+}
+
+status_t ANetworkSession::createRTSPServer(
+        const struct in_addr &addr, unsigned port,
+        const sp<AMessage> &notify, int32_t *sessionID) {
+    return createClientOrServer(
+            kModeCreateRTSPServer,
+            &addr,
+            port,
+            NULL /* remoteHost */,
+            0 /* remotePort */,
+            notify,
+            sessionID);
+}
+
+status_t ANetworkSession::createUDPSession(
+        unsigned localPort, const sp<AMessage> &notify, int32_t *sessionID) {
+    return createUDPSession(localPort, NULL, 0, notify, sessionID);
+}
+
+status_t ANetworkSession::createUDPSession(
+        unsigned localPort,
+        const char *remoteHost,
+        unsigned remotePort,
+        const sp<AMessage> &notify,
+        int32_t *sessionID) {
+    return createClientOrServer(
+            kModeCreateUDPSession,
+            NULL /* addr */,
+            localPort,
+            remoteHost,
+            remotePort,
+            notify,
+            sessionID);
+}
+
+status_t ANetworkSession::createTCPDatagramSession(
+        const struct in_addr &addr, unsigned port,
+        const sp<AMessage> &notify, int32_t *sessionID) {
+    return createClientOrServer(
+            kModeCreateTCPDatagramSessionPassive,
+            &addr,
+            port,
+            NULL /* remoteHost */,
+            0 /* remotePort */,
+            notify,
+            sessionID);
+}
+
+status_t ANetworkSession::createTCPDatagramSession(
+        unsigned localPort,
+        const char *remoteHost,
+        unsigned remotePort,
+        const sp<AMessage> &notify,
+        int32_t *sessionID) {
+    return createClientOrServer(
+            kModeCreateTCPDatagramSessionActive,
+            NULL /* addr */,
+            localPort,
+            remoteHost,
+            remotePort,
+            notify,
+            sessionID);
+}
+
+status_t ANetworkSession::destroySession(int32_t sessionID) {
+    Mutex::Autolock autoLock(mLock);
+
+    ssize_t index = mSessions.indexOfKey(sessionID);
+
+    if (index < 0) {
+        return -ENOENT;
+    }
+
+    mSessions.removeItemsAt(index);
+
+    interrupt();
+
+    return OK;
+}
+
+// static
+status_t ANetworkSession::MakeSocketNonBlocking(int s) {
+    int flags = fcntl(s, F_GETFL, 0);
+    if (flags < 0) {
+        flags = 0;
+    }
+
+    int res = fcntl(s, F_SETFL, flags | O_NONBLOCK);
+    if (res < 0) {
+        return -errno;
+    }
+
+    return OK;
+}
+
+status_t ANetworkSession::createClientOrServer(
+        Mode mode,
+        const struct in_addr *localAddr,
+        unsigned port,
+        const char *remoteHost,
+        unsigned remotePort,
+        const sp<AMessage> &notify,
+        int32_t *sessionID) {
+    Mutex::Autolock autoLock(mLock);
+
+    *sessionID = 0;
+    status_t err = OK;
+    int s, res;
+    sp<Session> session;
+
+    s = socket(
+            AF_INET,
+            (mode == kModeCreateUDPSession) ? SOCK_DGRAM : SOCK_STREAM,
+            0);
+
+    if (s < 0) {
+        err = -errno;
+        goto bail;
+    }
+
+    if (mode == kModeCreateRTSPServer
+            || mode == kModeCreateTCPDatagramSessionPassive) {
+        const int yes = 1;
+        res = setsockopt(s, SOL_SOCKET, SO_REUSEADDR, &yes, sizeof(yes));
+
+        if (res < 0) {
+            err = -errno;
+            goto bail2;
+        }
+    }
+
+    if (mode == kModeCreateUDPSession) {
+        int size = 256 * 1024;
+
+        res = setsockopt(s, SOL_SOCKET, SO_RCVBUF, &size, sizeof(size));
+
+        if (res < 0) {
+            err = -errno;
+            goto bail2;
+        }
+
+        res = setsockopt(s, SOL_SOCKET, SO_SNDBUF, &size, sizeof(size));
+
+        if (res < 0) {
+            err = -errno;
+            goto bail2;
+        }
+    }
+
+    err = MakeSocketNonBlocking(s);
+
+    if (err != OK) {
+        goto bail2;
+    }
+
+    struct sockaddr_in addr;
+    memset(addr.sin_zero, 0, sizeof(addr.sin_zero));
+    addr.sin_family = AF_INET;
+
+    if (mode == kModeCreateRTSPClient
+            || mode == kModeCreateTCPDatagramSessionActive) {
+        struct hostent *ent= gethostbyname(remoteHost);
+        if (ent == NULL) {
+            err = -h_errno;
+            goto bail2;
+        }
+
+        addr.sin_addr.s_addr = *(in_addr_t *)ent->h_addr;
+        addr.sin_port = htons(remotePort);
+    } else if (localAddr != NULL) {
+        addr.sin_addr = *localAddr;
+        addr.sin_port = htons(port);
+    } else {
+        addr.sin_addr.s_addr = htonl(INADDR_ANY);
+        addr.sin_port = htons(port);
+    }
+
+    if (mode == kModeCreateRTSPClient
+            || mode == kModeCreateTCPDatagramSessionActive) {
+        in_addr_t x = ntohl(addr.sin_addr.s_addr);
+        ALOGI("connecting socket %d to %d.%d.%d.%d:%d",
+              s,
+              (x >> 24),
+              (x >> 16) & 0xff,
+              (x >> 8) & 0xff,
+              x & 0xff,
+              ntohs(addr.sin_port));
+
+        res = connect(s, (const struct sockaddr *)&addr, sizeof(addr));
+
+        CHECK_LT(res, 0);
+        if (errno == EINPROGRESS) {
+            res = 0;
+        }
+    } else {
+        res = bind(s, (const struct sockaddr *)&addr, sizeof(addr));
+
+        if (res == 0) {
+            if (mode == kModeCreateRTSPServer
+                    || mode == kModeCreateTCPDatagramSessionPassive) {
+                res = listen(s, 4);
+            } else {
+                CHECK_EQ(mode, kModeCreateUDPSession);
+
+                if (remoteHost != NULL) {
+                    struct sockaddr_in remoteAddr;
+                    memset(remoteAddr.sin_zero, 0, sizeof(remoteAddr.sin_zero));
+                    remoteAddr.sin_family = AF_INET;
+                    remoteAddr.sin_port = htons(remotePort);
+
+                    struct hostent *ent= gethostbyname(remoteHost);
+                    if (ent == NULL) {
+                        err = -h_errno;
+                        goto bail2;
+                    }
+
+                    remoteAddr.sin_addr.s_addr = *(in_addr_t *)ent->h_addr;
+
+                    res = connect(
+                            s,
+                            (const struct sockaddr *)&remoteAddr,
+                            sizeof(remoteAddr));
+                }
+            }
+        }
+    }
+
+    if (res < 0) {
+        err = -errno;
+        goto bail2;
+    }
+
+    Session::State state;
+    switch (mode) {
+        case kModeCreateRTSPClient:
+            state = Session::CONNECTING;
+            break;
+
+        case kModeCreateTCPDatagramSessionActive:
+            state = Session::CONNECTING;
+            break;
+
+        case kModeCreateTCPDatagramSessionPassive:
+            state = Session::LISTENING_TCP_DGRAMS;
+            break;
+
+        case kModeCreateRTSPServer:
+            state = Session::LISTENING_RTSP;
+            break;
+
+        default:
+            CHECK_EQ(mode, kModeCreateUDPSession);
+            state = Session::DATAGRAM;
+            break;
+    }
+
+    session = new Session(
+            mNextSessionID++,
+            state,
+            s,
+            notify);
+
+    if (mode == kModeCreateTCPDatagramSessionActive) {
+        session->setIsRTSPConnection(false);
+    } else if (mode == kModeCreateRTSPClient) {
+        session->setIsRTSPConnection(true);
+    }
+
+    mSessions.add(session->sessionID(), session);
+
+    interrupt();
+
+    *sessionID = session->sessionID();
+
+    goto bail;
+
+bail2:
+    close(s);
+    s = -1;
+
+bail:
+    return err;
+}
+
+status_t ANetworkSession::connectUDPSession(
+        int32_t sessionID, const char *remoteHost, unsigned remotePort) {
+    Mutex::Autolock autoLock(mLock);
+
+    ssize_t index = mSessions.indexOfKey(sessionID);
+
+    if (index < 0) {
+        return -ENOENT;
+    }
+
+    const sp<Session> session = mSessions.valueAt(index);
+    int s = session->socket();
+
+    struct sockaddr_in remoteAddr;
+    memset(remoteAddr.sin_zero, 0, sizeof(remoteAddr.sin_zero));
+    remoteAddr.sin_family = AF_INET;
+    remoteAddr.sin_port = htons(remotePort);
+
+    status_t err = OK;
+    struct hostent *ent = gethostbyname(remoteHost);
+    if (ent == NULL) {
+        err = -h_errno;
+    } else {
+        remoteAddr.sin_addr.s_addr = *(in_addr_t *)ent->h_addr;
+
+        int res = connect(
+                s,
+                (const struct sockaddr *)&remoteAddr,
+                sizeof(remoteAddr));
+
+        if (res < 0) {
+            err = -errno;
+        }
+    }
+
+    return err;
+}
+
+status_t ANetworkSession::sendRequest(
+        int32_t sessionID, const void *data, ssize_t size) {
+    Mutex::Autolock autoLock(mLock);
+
+    ssize_t index = mSessions.indexOfKey(sessionID);
+
+    if (index < 0) {
+        return -ENOENT;
+    }
+
+    const sp<Session> session = mSessions.valueAt(index);
+
+    status_t err = session->sendRequest(data, size);
+
+    interrupt();
+
+    if (!mDiabledLog) {
+        ALOGD("--> --> --> sendRequest() session[%d] result[%d]", sessionID, err);
+        ALOGD("[%s]", (char*)data);
+    }
+
+    return err;
+}
+
+void ANetworkSession::interrupt() {
+    static const char dummy = 0;
+
+    ssize_t n;
+    do {
+        n = write(mPipeFd[1], &dummy, 1);
+    } while (n < 0 && errno == EINTR);
+
+    if (n < 0) {
+        ALOGW("Error writing to pipe (%s)", strerror(errno));
+    }
+}
+
+void ANetworkSession::threadLoop() {
+    fd_set rs, ws;
+    FD_ZERO(&rs);
+    FD_ZERO(&ws);
+
+    FD_SET(mPipeFd[0], &rs);
+    int maxFd = mPipeFd[0];
+
+    {
+        Mutex::Autolock autoLock(mLock);
+
+        for (size_t i = 0; i < mSessions.size(); ++i) {
+            const sp<Session> &session = mSessions.valueAt(i);
+
+            int s = session->socket();
+
+            if (s < 0) {
+                continue;
+            }
+
+            if (session->wantsToRead()) {
+                FD_SET(s, &rs);
+                if (s > maxFd) {
+                    maxFd = s;
+                }
+            }
+
+            if (session->wantsToWrite()) {
+                FD_SET(s, &ws);
+                if (s > maxFd) {
+                    maxFd = s;
+                }
+            }
+        }
+    }
+
+    int res = select(maxFd + 1, &rs, &ws, NULL, NULL /* tv */);
+
+    if (res == 0) {
+        return;
+    }
+
+    if (res < 0) {
+        if (errno == EINTR) {
+            return;
+        }
+
+        ALOGE("select failed w/ error %d (%s)", errno, strerror(errno));
+        return;
+    }
+
+    if (FD_ISSET(mPipeFd[0], &rs)) {
+        char c;
+        ssize_t n;
+        do {
+            n = read(mPipeFd[0], &c, 1);
+        } while (n < 0 && errno == EINTR);
+
+        if (n < 0) {
+            ALOGW("Error reading from pipe (%s)", strerror(errno));
+        }
+
+        --res;
+    }
+
+    {
+        Mutex::Autolock autoLock(mLock);
+
+        List<sp<Session> > sessionsToAdd;
+
+        for (size_t i = mSessions.size(); res > 0 && i-- > 0;) {
+            const sp<Session> &session = mSessions.valueAt(i);
+
+            int s = session->socket();
+
+            if (s < 0) {
+                continue;
+            }
+
+            if (FD_ISSET(s, &rs) || FD_ISSET(s, &ws)) {
+                --res;
+            }
+
+            if (FD_ISSET(s, &rs)) {
+                if (session->isRTSPServer() || session->isTCPDatagramServer()) {
+                    struct sockaddr_in remoteAddr;
+                    socklen_t remoteAddrLen = sizeof(remoteAddr);
+
+                    int clientSocket = accept(
+                            s, (struct sockaddr *)&remoteAddr, &remoteAddrLen);
+
+                    if (clientSocket >= 0) {
+                        status_t err = MakeSocketNonBlocking(clientSocket);
+
+                        if (err != OK) {
+                            ALOGE("Unable to make client socket non blocking, "
+                                  "failed w/ error %d (%s)",
+                                  err, strerror(-err));
+
+                            close(clientSocket);
+                            clientSocket = -1;
+                        } else {
+                            in_addr_t addr = ntohl(remoteAddr.sin_addr.s_addr);
+
+                            ALOGI("incoming connection from %d.%d.%d.%d:%d "
+                                  "(socket %d)",
+                                  (addr >> 24),
+                                  (addr >> 16) & 0xff,
+                                  (addr >> 8) & 0xff,
+                                  addr & 0xff,
+                                  ntohs(remoteAddr.sin_port),
+                                  clientSocket);
+
+                            sp<Session> clientSession =
+                                // using socket sd as sessionID
+                                new Session(
+                                        mNextSessionID++,
+                                        Session::CONNECTED,
+                                        clientSocket,
+                                        session->getNotificationMessage());
+
+                            clientSession->setIsRTSPConnection(
+                                    session->isRTSPServer());
+
+                            sessionsToAdd.push_back(clientSession);
+                        }
+                    } else {
+                        ALOGE("accept returned error %d (%s)",
+                              errno, strerror(errno));
+                    }
+                } else {
+                    status_t err = session->readMore();
+                    if (err != OK) {
+                        ALOGE("readMore on socket %d failed w/ error %d (%s)",
+                              s, err, strerror(-err));
+                    }
+                }
+            }
+
+            if (FD_ISSET(s, &ws)) {
+                status_t err = session->writeMore();
+                if (err != OK) {
+                    ALOGE("writeMore on socket %d failed w/ error %d (%s)",
+                          s, err, strerror(-err));
+                }
+            }
+        }
+
+        while (!sessionsToAdd.empty()) {
+            sp<Session> session = *sessionsToAdd.begin();
+            sessionsToAdd.erase(sessionsToAdd.begin());
+
+            mSessions.add(session->sessionID(), session);
+
+            ALOGI("added clientSession %d", session->sessionID());
+        }
+    }
+}
+
+}  // namespace android
+
diff -Naur a/frameworks/av/media/libstagefright/wifi-display/ANetworkSession.h b/frameworks/av/media/libstagefright/wifi-display/ANetworkSession.h
--- a/frameworks/av/media/libstagefright/wifi-display/ANetworkSession.h	1969-12-31 19:00:00.000000000 -0500
+++ b/frameworks/av/media/libstagefright/wifi-display/ANetworkSession.h	2013-08-14 04:13:30.000000000 -0400
@@ -0,0 +1,132 @@
+/*
+ * Copyright 2012, The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#ifndef A_NETWORK_SESSION_H_
+
+#define A_NETWORK_SESSION_H_
+
+#include <media/stagefright/foundation/ABase.h>
+#include <utils/KeyedVector.h>
+#include <utils/RefBase.h>
+#include <utils/Thread.h>
+
+#include <netinet/in.h>
+
+namespace android {
+
+struct AMessage;
+
+// Helper class to manage a number of live sockets (datagram and stream-based)
+// on a single thread. Clients are notified about activity through AMessages.
+struct ANetworkSession : public RefBase {
+    ANetworkSession();
+
+    status_t start();
+    status_t stop();
+
+    status_t createRTSPClient(
+            const char *host, unsigned port, const sp<AMessage> &notify,
+            int32_t *sessionID);
+
+    status_t createRTSPServer(
+            const struct in_addr &addr, unsigned port,
+            const sp<AMessage> &notify, int32_t *sessionID);
+
+    status_t createUDPSession(
+            unsigned localPort, const sp<AMessage> &notify, int32_t *sessionID);
+
+    status_t createUDPSession(
+            unsigned localPort,
+            const char *remoteHost,
+            unsigned remotePort,
+            const sp<AMessage> &notify,
+            int32_t *sessionID);
+
+    status_t connectUDPSession(
+            int32_t sessionID, const char *remoteHost, unsigned remotePort);
+
+    // passive
+    status_t createTCPDatagramSession(
+            const struct in_addr &addr, unsigned port,
+            const sp<AMessage> &notify, int32_t *sessionID);
+
+    // active
+    status_t createTCPDatagramSession(
+            unsigned localPort,
+            const char *remoteHost,
+            unsigned remotePort,
+            const sp<AMessage> &notify,
+            int32_t *sessionID);
+
+    status_t destroySession(int32_t sessionID);
+
+    status_t sendRequest(
+            int32_t sessionID, const void *data, ssize_t size = -1);
+
+    enum NotificationReason {
+        kWhatError,
+        kWhatConnected,
+        kWhatClientConnected,
+        kWhatData,
+        kWhatDatagram,
+        kWhatBinaryData,
+    };
+
+protected:
+    virtual ~ANetworkSession();
+
+private:
+    struct NetworkThread;
+    struct Session;
+
+    Mutex mLock;
+    sp<Thread> mThread;
+
+    int32_t mNextSessionID;
+
+    int mPipeFd[2];
+
+    KeyedVector<int32_t, sp<Session> > mSessions;
+
+    enum Mode {
+        kModeCreateUDPSession,
+        kModeCreateTCPDatagramSessionPassive,
+        kModeCreateTCPDatagramSessionActive,
+        kModeCreateRTSPServer,
+        kModeCreateRTSPClient,
+    };
+    status_t createClientOrServer(
+            Mode mode,
+            const struct in_addr *addr,
+            unsigned port,
+            const char *remoteHost,
+            unsigned remotePort,
+            const sp<AMessage> &notify,
+            int32_t *sessionID);
+
+    void threadLoop();
+    void interrupt();
+
+    static status_t MakeSocketNonBlocking(int s);
+
+    DISALLOW_EVIL_CONSTRUCTORS(ANetworkSession);
+
+    bool mDiabledLog;
+};
+
+}  // namespace android
+
+#endif  // A_NETWORK_SESSION_H_
diff -Naur a/frameworks/av/media/libstagefright/wifi-display/MediaReceiver.cpp b/frameworks/av/media/libstagefright/wifi-display/MediaReceiver.cpp
--- a/frameworks/av/media/libstagefright/wifi-display/MediaReceiver.cpp	1969-12-31 19:00:00.000000000 -0500
+++ b/frameworks/av/media/libstagefright/wifi-display/MediaReceiver.cpp	2014-03-24 09:49:48.600380753 -0400
@@ -0,0 +1,327 @@
+/*
+ * Copyright 2013, The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+//#define LOG_NDEBUG 0
+#define LOG_TAG "MediaReceiver"
+#include <utils/Log.h>
+
+#include "MediaReceiver.h"
+
+#include "AnotherPacketSource.h"
+#include "rtp/RTPReceiver.h"
+
+#include <media/stagefright/foundation/ABuffer.h>
+#include <media/stagefright/foundation/ADebug.h>
+#include <media/stagefright/foundation/AMessage.h>
+#include <media/stagefright/foundation/ANetworkSession.h>
+#include <media/stagefright/MetaData.h>
+#include <media/stagefright/Utils.h>
+
+namespace android {
+
+MediaReceiver::MediaReceiver(
+        const sp<ANetworkSession> &netSession,
+        const sp<AMessage> &notify)
+    : mNetSession(netSession),
+      mNotify(notify),
+      mMode(MODE_UNDEFINED),
+      mGeneration(0),
+      mInitStatus(OK),
+      mInitDoneCount(0) {
+}
+
+MediaReceiver::~MediaReceiver() {
+}
+
+ssize_t MediaReceiver::addTrack(
+        RTPReceiver::TransportMode rtpMode,
+        RTPReceiver::TransportMode rtcpMode,
+        int32_t *localRTPPort) {
+    if (mMode != MODE_UNDEFINED) {
+        return INVALID_OPERATION;
+    }
+
+    size_t trackIndex = mTrackInfos.size();
+
+    TrackInfo info;
+
+    sp<AMessage> notify = new AMessage(kWhatReceiverNotify, id());
+    notify->setInt32("generation", mGeneration);
+    notify->setSize("trackIndex", trackIndex);
+
+    info.mReceiver = new RTPReceiver(mNetSession, notify);
+    looper()->registerHandler(info.mReceiver);
+
+    info.mReceiver->registerPacketType(
+            33, RTPReceiver::PACKETIZATION_TRANSPORT_STREAM);
+
+    info.mReceiver->registerPacketType(
+            96, RTPReceiver::PACKETIZATION_AAC);
+
+    info.mReceiver->registerPacketType(
+            97, RTPReceiver::PACKETIZATION_H264);
+
+    status_t err = info.mReceiver->initAsync(
+            rtpMode,
+            rtcpMode,
+            localRTPPort);
+
+    if (err != OK) {
+        looper()->unregisterHandler(info.mReceiver->id());
+        info.mReceiver.clear();
+
+        return err;
+    }
+
+    mTrackInfos.push_back(info);
+
+    return trackIndex;
+}
+
+status_t MediaReceiver::connectTrack(
+        size_t trackIndex,
+        const char *remoteHost,
+        int32_t remoteRTPPort,
+        int32_t remoteRTCPPort) {
+    if (trackIndex >= mTrackInfos.size()) {
+        return -ERANGE;
+    }
+
+    TrackInfo *info = &mTrackInfos.editItemAt(trackIndex);
+    return info->mReceiver->connect(remoteHost, remoteRTPPort, remoteRTCPPort);
+}
+
+status_t MediaReceiver::initAsync(Mode mode) {
+    if ((mode == MODE_TRANSPORT_STREAM || mode == MODE_TRANSPORT_STREAM_RAW)
+            && mTrackInfos.size() > 1) {
+        return INVALID_OPERATION;
+    }
+
+    sp<AMessage> msg = new AMessage(kWhatInit, id());
+    msg->setInt32("mode", mode);
+    msg->post();
+
+    return OK;
+}
+
+void MediaReceiver::onMessageReceived(const sp<AMessage> &msg) {
+    switch (msg->what()) {
+        case kWhatInit:
+        {
+            int32_t mode;
+            CHECK(msg->findInt32("mode", &mode));
+
+            CHECK_EQ(mMode, MODE_UNDEFINED);
+            mMode = (Mode)mode;
+
+            if (mInitStatus != OK || mInitDoneCount == mTrackInfos.size()) {
+                notifyInitDone(mInitStatus);
+            }
+
+            mTSParser = new ATSParser(
+                    ATSParser::ALIGNED_VIDEO_DATA
+                        | ATSParser::TS_TIMESTAMPS_ARE_ABSOLUTE);
+
+            mFormatKnownMask = 0;
+            break;
+        }
+
+        case kWhatReceiverNotify:
+        {
+            int32_t generation;
+            CHECK(msg->findInt32("generation", &generation));
+            if (generation != mGeneration) {
+                break;
+            }
+
+            onReceiverNotify(msg);
+            break;
+        }
+
+        default:
+            TRESPASS();
+    }
+}
+
+void MediaReceiver::onReceiverNotify(const sp<AMessage> &msg) {
+    int32_t what;
+    CHECK(msg->findInt32("what", &what));
+
+    switch (what) {
+        case RTPReceiver::kWhatInitDone:
+        {
+            ++mInitDoneCount;
+
+            int32_t err;
+            CHECK(msg->findInt32("err", &err));
+
+            if (err != OK) {
+                mInitStatus = err;
+                ++mGeneration;
+            }
+
+            if (mMode != MODE_UNDEFINED) {
+                if (mInitStatus != OK || mInitDoneCount == mTrackInfos.size()) {
+                    notifyInitDone(mInitStatus);
+                }
+            }
+            break;
+        }
+
+        case RTPReceiver::kWhatError:
+        {
+            int32_t err;
+            CHECK(msg->findInt32("err", &err));
+
+            notifyError(err);
+            break;
+        }
+
+        case RTPReceiver::kWhatAccessUnit:
+        {
+            size_t trackIndex;
+            CHECK(msg->findSize("trackIndex", &trackIndex));
+
+            sp<ABuffer> accessUnit;
+            CHECK(msg->findBuffer("accessUnit", &accessUnit));
+
+            int32_t followsDiscontinuity;
+            if (!msg->findInt32(
+                        "followsDiscontinuity", &followsDiscontinuity)) {
+                followsDiscontinuity = 0;
+            }
+
+            if (mMode == MODE_TRANSPORT_STREAM) {
+                if (followsDiscontinuity) {
+                    mTSParser->signalDiscontinuity(
+                            ATSParser::DISCONTINUITY_TIME, NULL /* extra */);
+                }
+
+                for (size_t offset = 0;
+                        offset < accessUnit->size(); offset += 188) {
+                    status_t err = mTSParser->feedTSPacket(
+                             accessUnit->data() + offset, 188);
+
+                    if (err != OK) {
+                        notifyError(err);
+                        break;
+                    }
+                }
+
+                drainPackets(0 /* trackIndex */, ATSParser::VIDEO);
+                drainPackets(1 /* trackIndex */, ATSParser::AUDIO);
+            } else {
+                postAccessUnit(trackIndex, accessUnit, NULL);
+            }
+            break;
+        }
+
+        case RTPReceiver::kWhatPacketLost:
+        {
+            notifyPacketLost();
+            break;
+        }
+
+        default:
+            TRESPASS();
+    }
+}
+
+void MediaReceiver::drainPackets(
+        size_t trackIndex, ATSParser::SourceType type) {
+    sp<AnotherPacketSource> source =
+        static_cast<AnotherPacketSource *>(
+                mTSParser->getSource(type).get());
+
+    if (source == NULL) {
+        return;
+    }
+
+    sp<AMessage> format;
+    if (!(mFormatKnownMask & (1ul << trackIndex))) {
+        sp<MetaData> meta = source->getFormat();
+        CHECK(meta != NULL);
+
+        CHECK_EQ((status_t)OK, convertMetaDataToMessage(meta, &format));
+
+        mFormatKnownMask |= 1ul << trackIndex;
+    }
+
+    status_t finalResult;
+    while (source->hasBufferAvailable(&finalResult)) {
+        sp<ABuffer> accessUnit;
+        status_t err = source->dequeueAccessUnit(&accessUnit);
+        if (err == OK) {
+            postAccessUnit(trackIndex, accessUnit, format);
+            format.clear();
+        } else if (err != INFO_DISCONTINUITY) {
+            notifyError(err);
+        }
+    }
+
+    if (finalResult != OK) {
+        notifyError(finalResult);
+    }
+}
+
+void MediaReceiver::notifyInitDone(status_t err) {
+    sp<AMessage> notify = mNotify->dup();
+    notify->setInt32("what", kWhatInitDone);
+    notify->setInt32("err", err);
+    notify->post();
+}
+
+void MediaReceiver::notifyError(status_t err) {
+    sp<AMessage> notify = mNotify->dup();
+    notify->setInt32("what", kWhatError);
+    notify->setInt32("err", err);
+    notify->post();
+}
+
+void MediaReceiver::notifyPacketLost() {
+    sp<AMessage> notify = mNotify->dup();
+    notify->setInt32("what", kWhatPacketLost);
+    notify->post();
+}
+
+void MediaReceiver::postAccessUnit(
+        size_t trackIndex,
+        const sp<ABuffer> &accessUnit,
+        const sp<AMessage> &format) {
+    sp<AMessage> notify = mNotify->dup();
+    notify->setInt32("what", kWhatAccessUnit);
+    notify->setSize("trackIndex", trackIndex);
+    notify->setBuffer("accessUnit", accessUnit);
+
+    if (format != NULL) {
+        notify->setMessage("format", format);
+    }
+
+    notify->post();
+}
+
+status_t MediaReceiver::informSender(
+        size_t trackIndex, const sp<AMessage> &params) {
+    if (trackIndex >= mTrackInfos.size()) {
+        return -ERANGE;
+    }
+
+    TrackInfo *info = &mTrackInfos.editItemAt(trackIndex);
+    return info->mReceiver->informSender(params);
+}
+
+}  // namespace android
+
diff -Naur a/frameworks/av/media/libstagefright/wifi-display/MediaReceiver.h b/frameworks/av/media/libstagefright/wifi-display/MediaReceiver.h
--- a/frameworks/av/media/libstagefright/wifi-display/MediaReceiver.h	1969-12-31 19:00:00.000000000 -0500
+++ b/frameworks/av/media/libstagefright/wifi-display/MediaReceiver.h	2014-03-24 09:51:36.556382995 -0400
@@ -0,0 +1,111 @@
+/*
+ * Copyright 2013, The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#include <media/stagefright/foundation/AHandler.h>
+
+#include "ATSParser.h"
+#include "rtp/RTPReceiver.h"
+
+namespace android {
+
+struct ABuffer;
+struct ANetworkSession;
+struct AMessage;
+struct ATSParser;
+
+// This class facilitates receiving of media data for one or more tracks
+// over RTP. Either a 1:1 track to RTP channel mapping is used or a single
+// RTP channel provides the data for a transport stream that is consequently
+// demuxed and its track's data provided to the observer.
+struct MediaReceiver : public AHandler {
+    enum {
+        kWhatInitDone,
+        kWhatError,
+        kWhatAccessUnit,
+        kWhatPacketLost,
+    };
+
+    MediaReceiver(
+            const sp<ANetworkSession> &netSession,
+            const sp<AMessage> &notify);
+
+    ssize_t addTrack(
+            RTPReceiver::TransportMode rtpMode,
+            RTPReceiver::TransportMode rtcpMode,
+            int32_t *localRTPPort);
+
+    status_t connectTrack(
+            size_t trackIndex,
+            const char *remoteHost,
+            int32_t remoteRTPPort,
+            int32_t remoteRTCPPort);
+
+    enum Mode {
+        MODE_UNDEFINED,
+        MODE_TRANSPORT_STREAM,
+        MODE_TRANSPORT_STREAM_RAW,
+        MODE_ELEMENTARY_STREAMS,
+    };
+    status_t initAsync(Mode mode);
+
+    status_t informSender(size_t trackIndex, const sp<AMessage> &params);
+
+protected:
+    virtual void onMessageReceived(const sp<AMessage> &msg);
+    virtual ~MediaReceiver();
+
+private:
+    enum {
+        kWhatInit,
+        kWhatReceiverNotify,
+    };
+
+    struct TrackInfo {
+        sp<RTPReceiver> mReceiver;
+    };
+
+    sp<ANetworkSession> mNetSession;
+    sp<AMessage> mNotify;
+
+    Mode mMode;
+    int32_t mGeneration;
+
+    Vector<TrackInfo> mTrackInfos;
+
+    status_t mInitStatus;
+    size_t mInitDoneCount;
+
+    sp<ATSParser> mTSParser;
+    uint32_t mFormatKnownMask;
+
+    void onReceiverNotify(const sp<AMessage> &msg);
+
+    void drainPackets(size_t trackIndex, ATSParser::SourceType type);
+
+    void notifyInitDone(status_t err);
+    void notifyError(status_t err);
+    void notifyPacketLost();
+
+    void postAccessUnit(
+            size_t trackIndex,
+            const sp<ABuffer> &accessUnit,
+            const sp<AMessage> &format);
+
+    DISALLOW_EVIL_CONSTRUCTORS(MediaReceiver);
+};
+
+}  // namespace android
+
diff -Naur a/frameworks/av/media/libstagefright/wifi-display/nettest.cpp b/frameworks/av/media/libstagefright/wifi-display/nettest.cpp
--- a/frameworks/av/media/libstagefright/wifi-display/nettest.cpp	1969-12-31 19:00:00.000000000 -0500
+++ b/frameworks/av/media/libstagefright/wifi-display/nettest.cpp	2014-03-24 09:56:01.196388491 -0400
@@ -0,0 +1,400 @@
+/*
+ * Copyright 2013, The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+//#define LOG_NEBUG 0
+#define LOG_TAG "nettest"
+#include <utils/Log.h>
+
+#include "TimeSyncer.h"
+
+#include <binder/ProcessState.h>
+#include <media/stagefright/foundation/ABuffer.h>
+#include <media/stagefright/foundation/ADebug.h>
+#include <media/stagefright/foundation/AHandler.h>
+#include <media/stagefright/foundation/ALooper.h>
+#include <media/stagefright/foundation/AMessage.h>
+#include <media/stagefright/foundation/ANetworkSession.h>
+#include <media/stagefright/foundation/hexdump.h>
+#include <media/stagefright/DataSource.h>
+#include <media/stagefright/MediaDefs.h>
+#include <media/stagefright/NuMediaExtractor.h>
+#include <media/stagefright/Utils.h>
+
+namespace android {
+
+struct TestHandler : public AHandler {
+    TestHandler(const sp<ANetworkSession> &netSession);
+
+    void listen(int32_t port);
+    void connect(const char *host, int32_t port);
+
+protected:
+    virtual ~TestHandler();
+    virtual void onMessageReceived(const sp<AMessage> &msg);
+
+private:
+    enum {
+        kTimeSyncerPort = 8123,
+    };
+
+    enum {
+        kWhatListen,
+        kWhatConnect,
+        kWhatTimeSyncerNotify,
+        kWhatNetNotify,
+        kWhatSendMore,
+        kWhatStop,
+    };
+
+    sp<ANetworkSession> mNetSession;
+    sp<TimeSyncer> mTimeSyncer;
+
+    int32_t mServerSessionID;
+    int32_t mSessionID;
+
+    int64_t mTimeOffsetUs;
+    bool mTimeOffsetValid;
+
+    int32_t mCounter;
+
+    int64_t mMaxDelayMs;
+
+    void dumpDelay(int32_t counter, int64_t delayMs);
+
+    DISALLOW_EVIL_CONSTRUCTORS(TestHandler);
+};
+
+TestHandler::TestHandler(const sp<ANetworkSession> &netSession)
+    : mNetSession(netSession),
+      mServerSessionID(0),
+      mSessionID(0),
+      mTimeOffsetUs(-1ll),
+      mTimeOffsetValid(false),
+      mCounter(0),
+      mMaxDelayMs(-1ll) {
+}
+
+TestHandler::~TestHandler() {
+}
+
+void TestHandler::listen(int32_t port) {
+    sp<AMessage> msg = new AMessage(kWhatListen, id());
+    msg->setInt32("port", port);
+    msg->post();
+}
+
+void TestHandler::connect(const char *host, int32_t port) {
+    sp<AMessage> msg = new AMessage(kWhatConnect, id());
+    msg->setString("host", host);
+    msg->setInt32("port", port);
+    msg->post();
+}
+
+void TestHandler::dumpDelay(int32_t counter, int64_t delayMs) {
+    static const int64_t kMinDelayMs = 0;
+    static const int64_t kMaxDelayMs = 300;
+
+    const char *kPattern = "########################################";
+    size_t kPatternSize = strlen(kPattern);
+
+    int n = (kPatternSize * (delayMs - kMinDelayMs))
+                / (kMaxDelayMs - kMinDelayMs);
+
+    if (n < 0) {
+        n = 0;
+    } else if ((size_t)n > kPatternSize) {
+        n = kPatternSize;
+    }
+
+    if (delayMs > mMaxDelayMs) {
+        mMaxDelayMs = delayMs;
+    }
+
+    ALOGI("[%d] (%4lld ms / %4lld ms) %s",
+          counter,
+          delayMs,
+          mMaxDelayMs,
+          kPattern + kPatternSize - n);
+}
+
+void TestHandler::onMessageReceived(const sp<AMessage> &msg) {
+    switch (msg->what()) {
+        case kWhatListen:
+        {
+            sp<AMessage> notify = new AMessage(kWhatTimeSyncerNotify, id());
+            mTimeSyncer = new TimeSyncer(mNetSession, notify);
+            looper()->registerHandler(mTimeSyncer);
+
+            notify = new AMessage(kWhatNetNotify, id());
+
+            int32_t port;
+            CHECK(msg->findInt32("port", &port));
+
+            struct in_addr ifaceAddr;
+            ifaceAddr.s_addr = INADDR_ANY;
+
+            CHECK_EQ((status_t)OK,
+                     mNetSession->createTCPDatagramSession(
+                         ifaceAddr,
+                         port,
+                         notify,
+                         &mServerSessionID));
+            break;
+        }
+
+        case kWhatConnect:
+        {
+            sp<AMessage> notify = new AMessage(kWhatTimeSyncerNotify, id());
+            mTimeSyncer = new TimeSyncer(mNetSession, notify);
+            looper()->registerHandler(mTimeSyncer);
+            mTimeSyncer->startServer(kTimeSyncerPort);
+
+            AString host;
+            CHECK(msg->findString("host", &host));
+
+            int32_t port;
+            CHECK(msg->findInt32("port", &port));
+
+            notify = new AMessage(kWhatNetNotify, id());
+
+            CHECK_EQ((status_t)OK,
+                     mNetSession->createTCPDatagramSession(
+                         0 /* localPort */,
+                         host.c_str(),
+                         port,
+                         notify,
+                         &mSessionID));
+            break;
+        }
+
+        case kWhatNetNotify:
+        {
+            int32_t reason;
+            CHECK(msg->findInt32("reason", &reason));
+
+            switch (reason) {
+                case ANetworkSession::kWhatConnected:
+                {
+                    ALOGI("kWhatConnected");
+
+                    (new AMessage(kWhatSendMore, id()))->post();
+                    break;
+                }
+
+                case ANetworkSession::kWhatClientConnected:
+                {
+                    ALOGI("kWhatClientConnected");
+
+                    CHECK_EQ(mSessionID, 0);
+                    CHECK(msg->findInt32("sessionID", &mSessionID));
+
+                    AString clientIP;
+                    CHECK(msg->findString("client-ip", &clientIP));
+
+                    mTimeSyncer->startClient(clientIP.c_str(), kTimeSyncerPort);
+                    break;
+                }
+
+                case ANetworkSession::kWhatDatagram:
+                {
+                    sp<ABuffer> packet;
+                    CHECK(msg->findBuffer("data", &packet));
+
+                    CHECK_EQ(packet->size(), 12u);
+
+                    int32_t counter = U32_AT(packet->data());
+                    int64_t timeUs = U64_AT(packet->data() + 4);
+
+                    if (mTimeOffsetValid) {
+                        timeUs -= mTimeOffsetUs;
+                        int64_t nowUs = ALooper::GetNowUs();
+                        int64_t delayMs = (nowUs - timeUs) / 1000ll;
+
+                        dumpDelay(counter, delayMs);
+                    } else {
+                        ALOGI("received %d", counter);
+                    }
+                    break;
+                }
+
+                case ANetworkSession::kWhatError:
+                {
+                    ALOGE("kWhatError");
+                    break;
+                }
+
+                default:
+                    TRESPASS();
+            }
+            break;
+        }
+
+        case kWhatTimeSyncerNotify:
+        {
+            CHECK(msg->findInt64("offset", &mTimeOffsetUs));
+            mTimeOffsetValid = true;
+            break;
+        }
+
+        case kWhatSendMore:
+        {
+            uint8_t buffer[4 + 8];
+            buffer[0] = mCounter >> 24;
+            buffer[1] = (mCounter >> 16) & 0xff;
+            buffer[2] = (mCounter >> 8) & 0xff;
+            buffer[3] = mCounter & 0xff;
+
+            int64_t nowUs = ALooper::GetNowUs();
+
+            buffer[4] = nowUs >> 56;
+            buffer[5] = (nowUs >> 48) & 0xff;
+            buffer[6] = (nowUs >> 40) & 0xff;
+            buffer[7] = (nowUs >> 32) & 0xff;
+            buffer[8] = (nowUs >> 24) & 0xff;
+            buffer[9] = (nowUs >> 16) & 0xff;
+            buffer[10] = (nowUs >> 8) & 0xff;
+            buffer[11] = nowUs & 0xff;
+
+            ++mCounter;
+
+            CHECK_EQ((status_t)OK,
+                     mNetSession->sendRequest(
+                         mSessionID,
+                         buffer,
+                         sizeof(buffer),
+                         true /* timeValid */,
+                         nowUs));
+
+            msg->post(100000ll);
+            break;
+        }
+
+        case kWhatStop:
+        {
+            if (mSessionID != 0) {
+                mNetSession->destroySession(mSessionID);
+                mSessionID = 0;
+            }
+
+            if (mServerSessionID != 0) {
+                mNetSession->destroySession(mServerSessionID);
+                mServerSessionID = 0;
+            }
+
+            looper()->stop();
+            break;
+        }
+
+        default:
+            TRESPASS();
+    }
+}
+
+}  // namespace android
+
+static void usage(const char *me) {
+    fprintf(stderr,
+            "usage: %s -c host:port\tconnect to remote host\n"
+            "               -l port   \tlisten\n",
+            me);
+}
+
+int main(int argc, char **argv) {
+    using namespace android;
+
+    // srand(time(NULL));
+
+    ProcessState::self()->startThreadPool();
+
+    DataSource::RegisterDefaultSniffers();
+
+    int32_t connectToPort = -1;
+    AString connectToHost;
+
+    int32_t listenOnPort = -1;
+
+    int res;
+    while ((res = getopt(argc, argv, "hc:l:")) >= 0) {
+        switch (res) {
+            case 'c':
+            {
+                const char *colonPos = strrchr(optarg, ':');
+
+                if (colonPos == NULL) {
+                    usage(argv[0]);
+                    exit(1);
+                }
+
+                connectToHost.setTo(optarg, colonPos - optarg);
+
+                char *end;
+                connectToPort = strtol(colonPos + 1, &end, 10);
+
+                if (*end != '\0' || end == colonPos + 1
+                        || connectToPort < 0 || connectToPort > 65535) {
+                    fprintf(stderr, "Illegal port specified.\n");
+                    exit(1);
+                }
+                break;
+            }
+
+            case 'l':
+            {
+                char *end;
+                listenOnPort = strtol(optarg, &end, 10);
+
+                if (*end != '\0' || end == optarg
+                        || listenOnPort < 0 || listenOnPort > 65535) {
+                    fprintf(stderr, "Illegal port specified.\n");
+                    exit(1);
+                }
+                break;
+            }
+
+            case '?':
+            case 'h':
+                usage(argv[0]);
+                exit(1);
+        }
+    }
+
+    if ((listenOnPort < 0 && connectToPort < 0)
+            || (listenOnPort >= 0 && connectToPort >= 0)) {
+        fprintf(stderr,
+                "You need to select either client or server mode.\n");
+        exit(1);
+    }
+
+    sp<ANetworkSession> netSession = new ANetworkSession;
+    netSession->start();
+
+    sp<ALooper> looper = new ALooper;
+
+    sp<TestHandler> handler = new TestHandler(netSession);
+    looper->registerHandler(handler);
+
+    if (listenOnPort) {
+        handler->listen(listenOnPort);
+    }
+
+    if (connectToPort >= 0) {
+        handler->connect(connectToHost.c_str(), connectToPort);
+    }
+
+    looper->start(true /* runOnCallingThread */);
+
+    return 0;
+}
diff -Naur a/frameworks/av/media/libstagefright/wifi-display/ParsedMessage.cpp b/frameworks/av/media/libstagefright/wifi-display/ParsedMessage.cpp
--- a/frameworks/av/media/libstagefright/wifi-display/ParsedMessage.cpp	1969-12-31 19:00:00.000000000 -0500
+++ b/frameworks/av/media/libstagefright/wifi-display/ParsedMessage.cpp	2014-03-24 10:34:49.056436835 -0400
@@ -0,0 +1,283 @@
+/*
+ * Copyright 2012, The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#include "ParsedMessage.h"
+
+#include <ctype.h>
+#include <media/stagefright/foundation/ABuffer.h>
+#include <media/stagefright/foundation/ADebug.h>
+
+namespace android {
+
+// static
+sp<ParsedMessage> ParsedMessage::Parse(
+        const char *data, size_t size, bool noMoreData, size_t *length) {
+    sp<ParsedMessage> msg = new ParsedMessage;
+    ssize_t res = msg->parse(data, size, noMoreData);
+
+    if (res < 0) {
+        *length = 0;
+        return NULL;
+    }
+
+    *length = res;
+    return msg;
+}
+
+ParsedMessage::ParsedMessage() {
+}
+
+ParsedMessage::~ParsedMessage() {
+}
+
+bool ParsedMessage::findString(const char *name, AString *value) const {
+    AString key = name;
+    key.tolower();
+
+    ssize_t index = mDict.indexOfKey(key);
+
+    if (index < 0) {
+        value->clear();
+
+        return false;
+    }
+
+    *value = mDict.valueAt(index);
+    return true;
+}
+
+bool ParsedMessage::findInt32(const char *name, int32_t *value) const {
+    AString stringValue;
+
+    if (!findString(name, &stringValue)) {
+        return false;
+    }
+
+    char *end;
+    *value = strtol(stringValue.c_str(), &end, 10);
+
+    if (end == stringValue.c_str() || *end != '\0') {
+        *value = 0;
+        return false;
+    }
+
+    return true;
+}
+
+const char *ParsedMessage::getContent() const {
+    return mContent.c_str();
+}
+
+ssize_t ParsedMessage::parse(const char *data, size_t size, bool noMoreData) {
+    if (size == 0) {
+        return -1;
+    }
+
+    ssize_t lastDictIndex = -1;
+
+    size_t offset = 0;
+    while (offset < size) {
+        size_t lineEndOffset = offset;
+        while (lineEndOffset + 1 < size
+                && (data[lineEndOffset] != '\r'
+                        || data[lineEndOffset + 1] != '\n')) {
+            ++lineEndOffset;
+        }
+
+        if (lineEndOffset + 1 >= size) {
+            return -1;
+        }
+
+        AString line(&data[offset], lineEndOffset - offset);
+
+        if (offset == 0) {
+            // Special handling for the request/status line.
+
+            mDict.add(AString("_"), line);
+            offset = lineEndOffset + 2;
+
+            continue;
+        }
+
+        if (lineEndOffset == offset) {
+            offset += 2;
+            break;
+        }
+
+        if (line.c_str()[0] == ' ' || line.c_str()[0] == '\t') {
+            // Support for folded header values.
+
+            if (lastDictIndex >= 0) {
+                // Otherwise it's malformed since the first header line
+                // cannot continue anything...
+
+                AString &value = mDict.editValueAt(lastDictIndex);
+                value.append(line);
+            }
+
+            offset = lineEndOffset + 2;
+            continue;
+        }
+
+        ssize_t colonPos = line.find(":");
+        if (colonPos >= 0) {
+            AString key(line, 0, colonPos);
+            key.trim();
+            key.tolower();
+
+            line.erase(0, colonPos + 1);
+
+            lastDictIndex = mDict.add(key, line);
+        }
+
+        offset = lineEndOffset + 2;
+    }
+
+    for (size_t i = 0; i < mDict.size(); ++i) {
+        mDict.editValueAt(i).trim();
+    }
+
+    // Found the end of headers.
+
+    int32_t contentLength;
+    if (!findInt32("content-length", &contentLength) || contentLength < 0) {
+        contentLength = 0;
+    }
+
+    size_t totalLength = offset + contentLength;
+
+    if (size < totalLength) {
+        return -1;
+    }
+
+    mContent.setTo(&data[offset], contentLength);
+
+    return totalLength;
+}
+
+void ParsedMessage::getRequestField(size_t index, AString *field) const {
+    AString line;
+    CHECK(findString("_", &line));
+
+    size_t prevOffset = 0;
+    size_t offset = 0;
+    for (size_t i = 0; i <= index; ++i) {
+        ssize_t spacePos = line.find(" ", offset);
+
+        if (spacePos < 0) {
+            spacePos = line.size();
+        }
+
+        prevOffset = offset;
+        offset = spacePos + 1;
+    }
+
+    field->setTo(line, prevOffset, offset - prevOffset - 1);
+}
+
+bool ParsedMessage::getStatusCode(int32_t *statusCode) const {
+    AString statusCodeString;
+    getRequestField(1, &statusCodeString);
+
+    char *end;
+    *statusCode = strtol(statusCodeString.c_str(), &end, 10);
+
+    if (*end != '\0' || end == statusCodeString.c_str()
+            || (*statusCode) < 100 || (*statusCode) > 999) {
+        *statusCode = 0;
+        return false;
+    }
+
+    return true;
+}
+
+AString ParsedMessage::debugString() const {
+    AString line;
+    CHECK(findString("_", &line));
+
+    line.append("\n");
+
+    for (size_t i = 0; i < mDict.size(); ++i) {
+        const AString &key = mDict.keyAt(i);
+        const AString &value = mDict.valueAt(i);
+
+        if (key == AString("_")) {
+            continue;
+        }
+
+        line.append(key);
+        line.append(": ");
+        line.append(value);
+        line.append("\n");
+    }
+
+    line.append("\n");
+    line.append(mContent);
+
+    return line;
+}
+
+// static
+bool ParsedMessage::GetAttribute(
+        const char *s, const char *key, AString *value) {
+    value->clear();
+
+    size_t keyLen = strlen(key);
+
+    for (;;) {
+        while (isspace(*s)) {
+            ++s;
+        }
+
+        const char *colonPos = strchr(s, ';');
+
+        size_t len =
+            (colonPos == NULL) ? strlen(s) : colonPos - s;
+
+        if (len >= keyLen + 1 && s[keyLen] == '=' && !strncmp(s, key, keyLen)) {
+            value->setTo(&s[keyLen + 1], len - keyLen - 1);
+            return true;
+        }
+
+        if (colonPos == NULL) {
+            return false;
+        }
+
+        s = colonPos + 1;
+    }
+}
+
+// static
+bool ParsedMessage::GetInt32Attribute(
+        const char *s, const char *key, int32_t *value) {
+    AString stringValue;
+    if (!GetAttribute(s, key, &stringValue)) {
+        *value = 0;
+        return false;
+    }
+
+    char *end;
+    *value = strtol(stringValue.c_str(), &end, 10);
+
+    if (end == stringValue.c_str() || *end != '\0') {
+        *value = 0;
+        return false;
+    }
+
+    return true;
+}
+
+}  // namespace android
diff -Naur a/frameworks/av/media/libstagefright/wifi-display/ParsedMessage.h b/frameworks/av/media/libstagefright/wifi-display/ParsedMessage.h
--- a/frameworks/av/media/libstagefright/wifi-display/ParsedMessage.h	1969-12-31 19:00:00.000000000 -0500
+++ b/frameworks/av/media/libstagefright/wifi-display/ParsedMessage.h	2014-03-24 10:35:29.536437676 -0400
@@ -0,0 +1,60 @@
+/*
+ * Copyright 2012, The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#include <media/stagefright/foundation/ABase.h>
+#include <media/stagefright/foundation/AString.h>
+#include <utils/KeyedVector.h>
+#include <utils/RefBase.h>
+
+namespace android {
+
+// Encapsulates an "HTTP/RTSP style" response, i.e. a status line,
+// key/value pairs making up the headers and an optional body/content.
+struct ParsedMessage : public RefBase {
+    static sp<ParsedMessage> Parse(
+            const char *data, size_t size, bool noMoreData, size_t *length);
+
+    bool findString(const char *name, AString *value) const;
+    bool findInt32(const char *name, int32_t *value) const;
+
+    const char *getContent() const;
+
+    void getRequestField(size_t index, AString *field) const;
+    bool getStatusCode(int32_t *statusCode) const;
+
+    AString debugString() const;
+
+    static bool GetAttribute(const char *s, const char *key, AString *value);
+
+    static bool GetInt32Attribute(
+            const char *s, const char *key, int32_t *value);
+
+
+protected:
+    virtual ~ParsedMessage();
+
+private:
+    KeyedVector<AString, AString> mDict;
+    AString mContent;
+
+    ParsedMessage();
+
+    ssize_t parse(const char *data, size_t size, bool noMoreData);
+
+    DISALLOW_EVIL_CONSTRUCTORS(ParsedMessage);
+};
+
+}  // namespace android
diff -Naur a/frameworks/av/media/libstagefright/wifi-display/rtp/RTPAssembler.cpp b/frameworks/av/media/libstagefright/wifi-display/rtp/RTPAssembler.cpp
--- a/frameworks/av/media/libstagefright/wifi-display/rtp/RTPAssembler.cpp	1969-12-31 19:00:00.000000000 -0500
+++ b/frameworks/av/media/libstagefright/wifi-display/rtp/RTPAssembler.cpp	2014-03-24 09:57:09.100389901 -0400
@@ -0,0 +1,327 @@
+/*
+ * Copyright 2013, The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+//#define LOG_NDEBUG 0
+#define LOG_TAG "RTPAssembler"
+#include <utils/Log.h>
+
+#include "RTPAssembler.h"
+
+#include <media/stagefright/foundation/ABuffer.h>
+#include <media/stagefright/foundation/ADebug.h>
+#include <media/stagefright/foundation/AMessage.h>
+#include <media/stagefright/foundation/hexdump.h>
+#include <media/stagefright/MediaErrors.h>
+
+namespace android {
+
+RTPReceiver::Assembler::Assembler(const sp<AMessage> &notify)
+    : mNotify(notify) {
+}
+
+void RTPReceiver::Assembler::postAccessUnit(
+        const sp<ABuffer> &accessUnit, bool followsDiscontinuity) {
+    sp<AMessage> notify = mNotify->dup();
+    notify->setInt32("what", RTPReceiver::kWhatAccessUnit);
+    notify->setBuffer("accessUnit", accessUnit);
+    notify->setInt32("followsDiscontinuity", followsDiscontinuity);
+    notify->post();
+}
+////////////////////////////////////////////////////////////////////////////////
+
+RTPReceiver::TSAssembler::TSAssembler(const sp<AMessage> &notify)
+    : Assembler(notify),
+      mSawDiscontinuity(false) {
+}
+
+void RTPReceiver::TSAssembler::signalDiscontinuity() {
+    mSawDiscontinuity = true;
+}
+
+status_t RTPReceiver::TSAssembler::processPacket(const sp<ABuffer> &packet) {
+    int32_t rtpTime;
+    CHECK(packet->meta()->findInt32("rtp-time", &rtpTime));
+
+    packet->meta()->setInt64("timeUs", (rtpTime * 100ll) / 9);
+
+    postAccessUnit(packet, mSawDiscontinuity);
+
+    if (mSawDiscontinuity) {
+        mSawDiscontinuity = false;
+    }
+
+    return OK;
+}
+
+////////////////////////////////////////////////////////////////////////////////
+
+RTPReceiver::H264Assembler::H264Assembler(const sp<AMessage> &notify)
+    : Assembler(notify),
+      mState(0),
+      mIndicator(0),
+      mNALType(0),
+      mAccessUnitRTPTime(0) {
+}
+
+void RTPReceiver::H264Assembler::signalDiscontinuity() {
+    reset();
+}
+
+status_t RTPReceiver::H264Assembler::processPacket(const sp<ABuffer> &packet) {
+    status_t err = internalProcessPacket(packet);
+
+    if (err != OK) {
+        reset();
+    }
+
+    return err;
+}
+
+status_t RTPReceiver::H264Assembler::internalProcessPacket(
+        const sp<ABuffer> &packet) {
+    const uint8_t *data = packet->data();
+    size_t size = packet->size();
+
+    switch (mState) {
+        case 0:
+        {
+            if (size < 1 || (data[0] & 0x80)) {
+                ALOGV("Malformed H264 RTP packet (empty or F-bit set)");
+                return ERROR_MALFORMED;
+            }
+
+            unsigned nalType = data[0] & 0x1f;
+            if (nalType >= 1 && nalType <= 23) {
+                addSingleNALUnit(packet);
+                ALOGV("added single NAL packet");
+            } else if (nalType == 28) {
+                // FU-A
+                unsigned indicator = data[0];
+                CHECK((indicator & 0x1f) == 28);
+
+                if (size < 2) {
+                    ALOGV("Malformed H264 FU-A packet (single byte)");
+                    return ERROR_MALFORMED;
+                }
+
+                if (!(data[1] & 0x80)) {
+                    ALOGV("Malformed H264 FU-A packet (no start bit)");
+                    return ERROR_MALFORMED;
+                }
+
+                mIndicator = data[0];
+                mNALType = data[1] & 0x1f;
+                uint32_t nri = (data[0] >> 5) & 3;
+
+                clearAccumulator();
+
+                uint8_t byte = mNALType | (nri << 5);
+                appendToAccumulator(&byte, 1);
+                appendToAccumulator(data + 2, size - 2);
+
+                int32_t rtpTime;
+                CHECK(packet->meta()->findInt32("rtp-time", &rtpTime));
+                mAccumulator->meta()->setInt32("rtp-time", rtpTime);
+
+                if (data[1] & 0x40) {
+                    // Huh? End bit also set on the first buffer.
+                    addSingleNALUnit(mAccumulator);
+                    clearAccumulator();
+
+                    ALOGV("added FU-A");
+                    break;
+                }
+
+                mState = 1;
+            } else if (nalType == 24) {
+                // STAP-A
+
+                status_t err = addSingleTimeAggregationPacket(packet);
+                if (err != OK) {
+                    return err;
+                }
+            } else {
+                ALOGV("Malformed H264 packet (unknown type %d)", nalType);
+                return ERROR_UNSUPPORTED;
+            }
+            break;
+        }
+
+        case 1:
+        {
+            if (size < 2
+                    || data[0] != mIndicator
+                    || (data[1] & 0x1f) != mNALType
+                    || (data[1] & 0x80)) {
+                ALOGV("Malformed H264 FU-A packet (indicator, "
+                      "type or start bit mismatch)");
+
+                return ERROR_MALFORMED;
+            }
+
+            appendToAccumulator(data + 2, size - 2);
+
+            if (data[1] & 0x40) {
+                addSingleNALUnit(mAccumulator);
+
+                clearAccumulator();
+                mState = 0;
+
+                ALOGV("added FU-A");
+            }
+            break;
+        }
+
+        default:
+            TRESPASS();
+    }
+
+    int32_t marker;
+    CHECK(packet->meta()->findInt32("M", &marker));
+
+    if (marker) {
+        flushAccessUnit();
+    }
+
+    return OK;
+}
+
+void RTPReceiver::H264Assembler::reset() {
+    mNALUnits.clear();
+
+    clearAccumulator();
+    mState = 0;
+}
+
+void RTPReceiver::H264Assembler::clearAccumulator() {
+    if (mAccumulator != NULL) {
+        // XXX Too expensive.
+        mAccumulator.clear();
+    }
+}
+
+void RTPReceiver::H264Assembler::appendToAccumulator(
+        const void *data, size_t size) {
+    if (mAccumulator == NULL) {
+        mAccumulator = new ABuffer(size);
+        memcpy(mAccumulator->data(), data, size);
+        return;
+    }
+
+    if (mAccumulator->size() + size > mAccumulator->capacity()) {
+        sp<ABuffer> buf = new ABuffer(mAccumulator->size() + size);
+        memcpy(buf->data(), mAccumulator->data(), mAccumulator->size());
+        buf->setRange(0, mAccumulator->size());
+
+        int32_t rtpTime;
+        if (mAccumulator->meta()->findInt32("rtp-time", &rtpTime)) {
+            buf->meta()->setInt32("rtp-time", rtpTime);
+        }
+
+        mAccumulator = buf;
+    }
+
+    memcpy(mAccumulator->data() + mAccumulator->size(), data, size);
+    mAccumulator->setRange(0, mAccumulator->size() + size);
+}
+
+void RTPReceiver::H264Assembler::addSingleNALUnit(const sp<ABuffer> &packet) {
+    if (mNALUnits.empty()) {
+        int32_t rtpTime;
+        CHECK(packet->meta()->findInt32("rtp-time", &rtpTime));
+
+        mAccessUnitRTPTime = rtpTime;
+    }
+
+    mNALUnits.push_back(packet);
+}
+
+void RTPReceiver::H264Assembler::flushAccessUnit() {
+    if (mNALUnits.empty()) {
+        return;
+    }
+
+    size_t totalSize = 0;
+    for (List<sp<ABuffer> >::iterator it = mNALUnits.begin();
+            it != mNALUnits.end(); ++it) {
+        totalSize += 4 + (*it)->size();
+    }
+
+    sp<ABuffer> accessUnit = new ABuffer(totalSize);
+    size_t offset = 0;
+    for (List<sp<ABuffer> >::iterator it = mNALUnits.begin();
+            it != mNALUnits.end(); ++it) {
+        const sp<ABuffer> nalUnit = *it;
+
+        memcpy(accessUnit->data() + offset, "\x00\x00\x00\x01", 4);
+
+        memcpy(accessUnit->data() + offset + 4,
+               nalUnit->data(),
+               nalUnit->size());
+
+        offset += 4 + nalUnit->size();
+    }
+
+    mNALUnits.clear();
+
+    accessUnit->meta()->setInt64("timeUs", mAccessUnitRTPTime * 100ll / 9ll);
+    postAccessUnit(accessUnit, false /* followsDiscontinuity */);
+}
+
+status_t RTPReceiver::H264Assembler::addSingleTimeAggregationPacket(
+        const sp<ABuffer> &packet) {
+    const uint8_t *data = packet->data();
+    size_t size = packet->size();
+
+    if (size < 3) {
+        ALOGV("Malformed H264 STAP-A packet (too small)");
+        return ERROR_MALFORMED;
+    }
+
+    int32_t rtpTime;
+    CHECK(packet->meta()->findInt32("rtp-time", &rtpTime));
+
+    ++data;
+    --size;
+    while (size >= 2) {
+        size_t nalSize = (data[0] << 8) | data[1];
+
+        if (size < nalSize + 2) {
+            ALOGV("Malformed H264 STAP-A packet (incomplete NAL unit)");
+            return ERROR_MALFORMED;
+        }
+
+        sp<ABuffer> unit = new ABuffer(nalSize);
+        memcpy(unit->data(), &data[2], nalSize);
+
+        unit->meta()->setInt32("rtp-time", rtpTime);
+
+        addSingleNALUnit(unit);
+
+        data += 2 + nalSize;
+        size -= 2 + nalSize;
+    }
+
+    if (size != 0) {
+        ALOGV("Unexpected padding at end of STAP-A packet.");
+    }
+
+    ALOGV("added STAP-A");
+
+    return OK;
+}
+
+}  // namespace android
diff -Naur a/frameworks/av/media/libstagefright/wifi-display/rtp/RTPAssembler.h b/frameworks/av/media/libstagefright/wifi-display/rtp/RTPAssembler.h
--- a/frameworks/av/media/libstagefright/wifi-display/rtp/RTPAssembler.h	1969-12-31 19:00:00.000000000 -0500
+++ b/frameworks/av/media/libstagefright/wifi-display/rtp/RTPAssembler.h	2014-03-24 09:58:15.528391281 -0400
@@ -0,0 +1,91 @@
+/*
+ * Copyright 2013, The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#ifndef RTP_ASSEMBLER_H_
+
+#define RTP_ASSEMBLER_H_
+
+#include "RTPReceiver.h"
+
+namespace android {
+
+// A helper class to reassemble the payload of RTP packets into access
+// units depending on the packetization scheme.
+struct RTPReceiver::Assembler : public RefBase {
+    Assembler(const sp<AMessage> &notify);
+
+    virtual void signalDiscontinuity() = 0;
+    virtual status_t processPacket(const sp<ABuffer> &packet) = 0;
+
+protected:
+    virtual ~Assembler() {}
+
+    void postAccessUnit(
+            const sp<ABuffer> &accessUnit, bool followsDiscontinuity);
+
+private:
+    sp<AMessage> mNotify;
+
+    DISALLOW_EVIL_CONSTRUCTORS(Assembler);
+};
+
+struct RTPReceiver::TSAssembler : public RTPReceiver::Assembler {
+    TSAssembler(const sp<AMessage> &notify);
+
+    virtual void signalDiscontinuity();
+    virtual status_t processPacket(const sp<ABuffer> &packet);
+
+private:
+    bool mSawDiscontinuity;
+
+    DISALLOW_EVIL_CONSTRUCTORS(TSAssembler);
+};
+
+struct RTPReceiver::H264Assembler : public RTPReceiver::Assembler {
+    H264Assembler(const sp<AMessage> &notify);
+
+    virtual void signalDiscontinuity();
+    virtual status_t processPacket(const sp<ABuffer> &packet);
+
+private:
+    int32_t mState;
+
+    uint8_t mIndicator;
+    uint8_t mNALType;
+
+    sp<ABuffer> mAccumulator;
+
+    List<sp<ABuffer> > mNALUnits;
+    int32_t mAccessUnitRTPTime;
+
+    status_t internalProcessPacket(const sp<ABuffer> &packet);
+
+    void addSingleNALUnit(const sp<ABuffer> &packet);
+    status_t addSingleTimeAggregationPacket(const sp<ABuffer> &packet);
+
+    void flushAccessUnit();
+
+    void clearAccumulator();
+    void appendToAccumulator(const void *data, size_t size);
+
+    void reset();
+
+    DISALLOW_EVIL_CONSTRUCTORS(H264Assembler);
+};
+
+}  // namespace android
+
+#endif  // RTP_ASSEMBLER_H_
diff -Naur a/frameworks/av/media/libstagefright/wifi-display/rtp/RTPReceiver.cpp b/frameworks/av/media/libstagefright/wifi-display/rtp/RTPReceiver.cpp
--- a/frameworks/av/media/libstagefright/wifi-display/rtp/RTPReceiver.cpp	1969-12-31 19:00:00.000000000 -0500
+++ b/frameworks/av/media/libstagefright/wifi-display/rtp/RTPReceiver.cpp	2014-03-24 09:59:11.876392451 -0400
@@ -0,0 +1,1151 @@
+/*
+ * Copyright 2013, The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+//#define LOG_NDEBUG 0
+#define LOG_TAG "RTPReceiver"
+#include <utils/Log.h>
+
+#include "RTPAssembler.h"
+#include "RTPReceiver.h"
+
+#include <media/stagefright/foundation/ABuffer.h>
+#include <media/stagefright/foundation/ADebug.h>
+#include <media/stagefright/foundation/AMessage.h>
+#include <media/stagefright/foundation/ANetworkSession.h>
+#include <media/stagefright/foundation/hexdump.h>
+#include <media/stagefright/MediaErrors.h>
+#include <media/stagefright/Utils.h>
+
+#define TRACK_PACKET_LOSS       0
+
+namespace android {
+
+////////////////////////////////////////////////////////////////////////////////
+
+struct RTPReceiver::Source : public AHandler {
+    Source(RTPReceiver *receiver, uint32_t ssrc);
+
+    void onPacketReceived(uint16_t seq, const sp<ABuffer> &buffer);
+
+    void addReportBlock(uint32_t ssrc, const sp<ABuffer> &buf);
+
+protected:
+    virtual ~Source();
+
+    virtual void onMessageReceived(const sp<AMessage> &msg);
+
+private:
+    enum {
+        kWhatRetransmit,
+        kWhatDeclareLost,
+    };
+
+    static const uint32_t kMinSequential = 2;
+    static const uint32_t kMaxDropout = 3000;
+    static const uint32_t kMaxMisorder = 100;
+    static const uint32_t kRTPSeqMod = 1u << 16;
+    static const int64_t kReportIntervalUs = 10000000ll;
+
+    RTPReceiver *mReceiver;
+    uint32_t mSSRC;
+    bool mFirst;
+    uint16_t mMaxSeq;
+    uint32_t mCycles;
+    uint32_t mBaseSeq;
+    uint32_t mReceived;
+    uint32_t mExpectedPrior;
+    uint32_t mReceivedPrior;
+
+    int64_t mFirstArrivalTimeUs;
+    int64_t mFirstRTPTimeUs;
+
+    // Ordered by extended seq number.
+    List<sp<ABuffer> > mPackets;
+
+    enum StatusBits {
+        STATUS_DECLARED_LOST            = 1,
+        STATUS_REQUESTED_RETRANSMISSION = 2,
+        STATUS_ARRIVED_LATE             = 4,
+    };
+#if TRACK_PACKET_LOSS
+    KeyedVector<int32_t, uint32_t> mLostPackets;
+#endif
+
+    void modifyPacketStatus(int32_t extSeqNo, uint32_t mask);
+
+    int32_t mAwaitingExtSeqNo;
+    bool mRequestedRetransmission;
+
+    int32_t mActivePacketType;
+    sp<Assembler> mActiveAssembler;
+
+    int64_t mNextReportTimeUs;
+
+    int32_t mNumDeclaredLost;
+    int32_t mNumDeclaredLostPrior;
+
+    int32_t mRetransmitGeneration;
+    int32_t mDeclareLostGeneration;
+    bool mDeclareLostTimerPending;
+
+    void queuePacket(const sp<ABuffer> &packet);
+    void dequeueMore();
+
+    sp<ABuffer> getNextPacket();
+    void resync();
+
+    void postRetransmitTimer(int64_t delayUs);
+    void postDeclareLostTimer(int64_t delayUs);
+    void cancelTimers();
+
+    DISALLOW_EVIL_CONSTRUCTORS(Source);
+};
+
+////////////////////////////////////////////////////////////////////////////////
+
+RTPReceiver::Source::Source(RTPReceiver *receiver, uint32_t ssrc)
+    : mReceiver(receiver),
+      mSSRC(ssrc),
+      mFirst(true),
+      mMaxSeq(0),
+      mCycles(0),
+      mBaseSeq(0),
+      mReceived(0),
+      mExpectedPrior(0),
+      mReceivedPrior(0),
+      mFirstArrivalTimeUs(-1ll),
+      mFirstRTPTimeUs(-1ll),
+      mAwaitingExtSeqNo(-1),
+      mRequestedRetransmission(false),
+      mActivePacketType(-1),
+      mNextReportTimeUs(-1ll),
+      mNumDeclaredLost(0),
+      mNumDeclaredLostPrior(0),
+      mRetransmitGeneration(0),
+      mDeclareLostGeneration(0),
+      mDeclareLostTimerPending(false) {
+}
+
+RTPReceiver::Source::~Source() {
+}
+
+void RTPReceiver::Source::onMessageReceived(const sp<AMessage> &msg) {
+    switch (msg->what()) {
+        case kWhatRetransmit:
+        {
+            int32_t generation;
+            CHECK(msg->findInt32("generation", &generation));
+
+            if (generation != mRetransmitGeneration) {
+                break;
+            }
+
+            mRequestedRetransmission = true;
+            mReceiver->requestRetransmission(mSSRC, mAwaitingExtSeqNo);
+
+            modifyPacketStatus(
+                    mAwaitingExtSeqNo, STATUS_REQUESTED_RETRANSMISSION);
+            break;
+        }
+
+        case kWhatDeclareLost:
+        {
+            int32_t generation;
+            CHECK(msg->findInt32("generation", &generation));
+
+            if (generation != mDeclareLostGeneration) {
+                break;
+            }
+
+            cancelTimers();
+
+            ALOGV("Lost packet extSeqNo %d %s",
+                  mAwaitingExtSeqNo,
+                  mRequestedRetransmission ? "*" : "");
+
+            mRequestedRetransmission = false;
+            if (mActiveAssembler != NULL) {
+                mActiveAssembler->signalDiscontinuity();
+            }
+
+            modifyPacketStatus(mAwaitingExtSeqNo, STATUS_DECLARED_LOST);
+
+            // resync();
+            ++mAwaitingExtSeqNo;
+            ++mNumDeclaredLost;
+
+            mReceiver->notifyPacketLost();
+
+            dequeueMore();
+            break;
+        }
+
+        default:
+            TRESPASS();
+    }
+}
+
+void RTPReceiver::Source::onPacketReceived(
+        uint16_t seq, const sp<ABuffer> &buffer) {
+    if (mFirst) {
+        buffer->setInt32Data(mCycles | seq);
+        queuePacket(buffer);
+
+        mFirst = false;
+        mBaseSeq = seq;
+        mMaxSeq = seq;
+        ++mReceived;
+        return;
+    }
+
+    uint16_t udelta = seq - mMaxSeq;
+
+    if (udelta < kMaxDropout) {
+        // In order, with permissible gap.
+
+        if (seq < mMaxSeq) {
+            // Sequence number wrapped - count another 64K cycle
+            mCycles += kRTPSeqMod;
+        }
+
+        mMaxSeq = seq;
+
+        ++mReceived;
+    } else if (udelta <= kRTPSeqMod - kMaxMisorder) {
+        // The sequence number made a very large jump
+        return;
+    } else {
+        // Duplicate or reordered packet.
+    }
+
+    buffer->setInt32Data(mCycles | seq);
+    queuePacket(buffer);
+}
+
+void RTPReceiver::Source::queuePacket(const sp<ABuffer> &packet) {
+    int32_t newExtendedSeqNo = packet->int32Data();
+
+    if (mFirstArrivalTimeUs < 0ll) {
+        mFirstArrivalTimeUs = ALooper::GetNowUs();
+
+        uint32_t rtpTime;
+        CHECK(packet->meta()->findInt32("rtp-time", (int32_t *)&rtpTime));
+
+        mFirstRTPTimeUs = (rtpTime * 100ll) / 9ll;
+    }
+
+    if (mAwaitingExtSeqNo >= 0 && newExtendedSeqNo < mAwaitingExtSeqNo) {
+        // We're no longer interested in these. They're old.
+        ALOGV("dropping stale extSeqNo %d", newExtendedSeqNo);
+
+        modifyPacketStatus(newExtendedSeqNo, STATUS_ARRIVED_LATE);
+        return;
+    }
+
+    if (mPackets.empty()) {
+        mPackets.push_back(packet);
+        dequeueMore();
+        return;
+    }
+
+    List<sp<ABuffer> >::iterator firstIt = mPackets.begin();
+    List<sp<ABuffer> >::iterator it = --mPackets.end();
+    for (;;) {
+        int32_t extendedSeqNo = (*it)->int32Data();
+
+        if (extendedSeqNo == newExtendedSeqNo) {
+            // Duplicate packet.
+            return;
+        }
+
+        if (extendedSeqNo < newExtendedSeqNo) {
+            // Insert new packet after the one at "it".
+            mPackets.insert(++it, packet);
+            break;
+        }
+
+        if (it == firstIt) {
+            // Insert new packet before the first existing one.
+            mPackets.insert(it, packet);
+            break;
+        }
+
+        --it;
+    }
+
+    dequeueMore();
+}
+
+void RTPReceiver::Source::dequeueMore() {
+    int64_t nowUs = ALooper::GetNowUs();
+    if (mNextReportTimeUs < 0ll || nowUs >= mNextReportTimeUs) {
+        if (mNextReportTimeUs >= 0ll) {
+            uint32_t expected = (mMaxSeq | mCycles) - mBaseSeq + 1;
+
+            uint32_t expectedInterval = expected - mExpectedPrior;
+            mExpectedPrior = expected;
+
+            uint32_t receivedInterval = mReceived - mReceivedPrior;
+            mReceivedPrior = mReceived;
+
+            int64_t lostInterval =
+                (int64_t)expectedInterval - (int64_t)receivedInterval;
+
+            int32_t declaredLostInterval =
+                mNumDeclaredLost - mNumDeclaredLostPrior;
+
+            mNumDeclaredLostPrior = mNumDeclaredLost;
+
+            if (declaredLostInterval > 0) {
+                ALOGI("lost %lld packets (%.2f %%), declared %d lost\n",
+                      lostInterval,
+                      100.0f * lostInterval / expectedInterval,
+                      declaredLostInterval);
+            }
+        }
+
+        mNextReportTimeUs = nowUs + kReportIntervalUs;
+
+#if TRACK_PACKET_LOSS
+        for (size_t i = 0; i < mLostPackets.size(); ++i) {
+            int32_t key = mLostPackets.keyAt(i);
+            uint32_t value = mLostPackets.valueAt(i);
+
+            AString status;
+            if (value & STATUS_REQUESTED_RETRANSMISSION) {
+                status.append("retrans ");
+            }
+            if (value & STATUS_ARRIVED_LATE) {
+                status.append("arrived-late ");
+            }
+            ALOGI("Packet %d declared lost %s", key, status.c_str());
+        }
+#endif
+    }
+
+    sp<ABuffer> packet;
+    while ((packet = getNextPacket()) != NULL) {
+        if (mDeclareLostTimerPending) {
+            cancelTimers();
+        }
+
+        CHECK_GE(mAwaitingExtSeqNo, 0);
+#if TRACK_PACKET_LOSS
+        mLostPackets.removeItem(mAwaitingExtSeqNo);
+#endif
+
+        int32_t packetType;
+        CHECK(packet->meta()->findInt32("PT", &packetType));
+
+        if (packetType != mActivePacketType) {
+            mActiveAssembler = mReceiver->makeAssembler(packetType);
+            mActivePacketType = packetType;
+        }
+
+        if (mActiveAssembler != NULL) {
+            status_t err = mActiveAssembler->processPacket(packet);
+            if (err != OK) {
+                ALOGV("assembler returned error %d", err);
+            }
+        }
+
+        ++mAwaitingExtSeqNo;
+    }
+
+    if (mDeclareLostTimerPending) {
+        return;
+    }
+
+    if (mPackets.empty()) {
+        return;
+    }
+
+    CHECK_GE(mAwaitingExtSeqNo, 0);
+
+    const sp<ABuffer> &firstPacket = *mPackets.begin();
+
+    uint32_t rtpTime;
+    CHECK(firstPacket->meta()->findInt32(
+                "rtp-time", (int32_t *)&rtpTime));
+
+
+    int64_t rtpUs = (rtpTime * 100ll) / 9ll;
+
+    int64_t maxArrivalTimeUs =
+        mFirstArrivalTimeUs + rtpUs - mFirstRTPTimeUs;
+
+    nowUs = ALooper::GetNowUs();
+
+    CHECK_LT(mAwaitingExtSeqNo, firstPacket->int32Data());
+
+    ALOGV("waiting for %d, comparing against %d, %lld us left",
+          mAwaitingExtSeqNo,
+          firstPacket->int32Data(),
+          maxArrivalTimeUs - nowUs);
+
+    postDeclareLostTimer(maxArrivalTimeUs + kPacketLostAfterUs);
+
+    if (kRequestRetransmissionAfterUs > 0ll) {
+        postRetransmitTimer(
+                maxArrivalTimeUs + kRequestRetransmissionAfterUs);
+    }
+}
+
+sp<ABuffer> RTPReceiver::Source::getNextPacket() {
+    if (mPackets.empty()) {
+        return NULL;
+    }
+
+    int32_t extSeqNo = (*mPackets.begin())->int32Data();
+
+    if (mAwaitingExtSeqNo < 0) {
+        mAwaitingExtSeqNo = extSeqNo;
+    } else if (extSeqNo != mAwaitingExtSeqNo) {
+        return NULL;
+    }
+
+    sp<ABuffer> packet = *mPackets.begin();
+    mPackets.erase(mPackets.begin());
+
+    return packet;
+}
+
+void RTPReceiver::Source::resync() {
+    mAwaitingExtSeqNo = -1;
+}
+
+void RTPReceiver::Source::addReportBlock(
+        uint32_t ssrc, const sp<ABuffer> &buf) {
+    uint32_t extMaxSeq = mMaxSeq | mCycles;
+    uint32_t expected = extMaxSeq - mBaseSeq + 1;
+
+    int64_t lost = (int64_t)expected - (int64_t)mReceived;
+    if (lost > 0x7fffff) {
+        lost = 0x7fffff;
+    } else if (lost < -0x800000) {
+        lost = -0x800000;
+    }
+
+    uint32_t expectedInterval = expected - mExpectedPrior;
+    mExpectedPrior = expected;
+
+    uint32_t receivedInterval = mReceived - mReceivedPrior;
+    mReceivedPrior = mReceived;
+
+    int64_t lostInterval = expectedInterval - receivedInterval;
+
+    uint8_t fractionLost;
+    if (expectedInterval == 0 || lostInterval <=0) {
+        fractionLost = 0;
+    } else {
+        fractionLost = (lostInterval << 8) / expectedInterval;
+    }
+
+    uint8_t *ptr = buf->data() + buf->size();
+
+    ptr[0] = ssrc >> 24;
+    ptr[1] = (ssrc >> 16) & 0xff;
+    ptr[2] = (ssrc >> 8) & 0xff;
+    ptr[3] = ssrc & 0xff;
+
+    ptr[4] = fractionLost;
+
+    ptr[5] = (lost >> 16) & 0xff;
+    ptr[6] = (lost >> 8) & 0xff;
+    ptr[7] = lost & 0xff;
+
+    ptr[8] = extMaxSeq >> 24;
+    ptr[9] = (extMaxSeq >> 16) & 0xff;
+    ptr[10] = (extMaxSeq >> 8) & 0xff;
+    ptr[11] = extMaxSeq & 0xff;
+
+    // XXX TODO:
+
+    ptr[12] = 0x00;  // interarrival jitter
+    ptr[13] = 0x00;
+    ptr[14] = 0x00;
+    ptr[15] = 0x00;
+
+    ptr[16] = 0x00;  // last SR
+    ptr[17] = 0x00;
+    ptr[18] = 0x00;
+    ptr[19] = 0x00;
+
+    ptr[20] = 0x00;  // delay since last SR
+    ptr[21] = 0x00;
+    ptr[22] = 0x00;
+    ptr[23] = 0x00;
+
+    buf->setRange(buf->offset(), buf->size() + 24);
+}
+
+////////////////////////////////////////////////////////////////////////////////
+
+RTPReceiver::RTPReceiver(
+        const sp<ANetworkSession> &netSession,
+        const sp<AMessage> &notify,
+        uint32_t flags)
+    : mNetSession(netSession),
+      mNotify(notify),
+      mFlags(flags),
+      mRTPMode(TRANSPORT_UNDEFINED),
+      mRTCPMode(TRANSPORT_UNDEFINED),
+      mRTPSessionID(0),
+      mRTCPSessionID(0),
+      mRTPConnected(false),
+      mRTCPConnected(false),
+      mRTPClientSessionID(0),
+      mRTCPClientSessionID(0) {
+}
+
+RTPReceiver::~RTPReceiver() {
+    if (mRTCPClientSessionID != 0) {
+        mNetSession->destroySession(mRTCPClientSessionID);
+        mRTCPClientSessionID = 0;
+    }
+
+    if (mRTPClientSessionID != 0) {
+        mNetSession->destroySession(mRTPClientSessionID);
+        mRTPClientSessionID = 0;
+    }
+
+    if (mRTCPSessionID != 0) {
+        mNetSession->destroySession(mRTCPSessionID);
+        mRTCPSessionID = 0;
+    }
+
+    if (mRTPSessionID != 0) {
+        mNetSession->destroySession(mRTPSessionID);
+        mRTPSessionID = 0;
+    }
+}
+
+status_t RTPReceiver::initAsync(
+        TransportMode rtpMode,
+        TransportMode rtcpMode,
+        int32_t *outLocalRTPPort) {
+    if (mRTPMode != TRANSPORT_UNDEFINED
+            || rtpMode == TRANSPORT_UNDEFINED
+            || rtpMode == TRANSPORT_NONE
+            || rtcpMode == TRANSPORT_UNDEFINED) {
+        return INVALID_OPERATION;
+    }
+
+    CHECK_NE(rtpMode, TRANSPORT_TCP_INTERLEAVED);
+    CHECK_NE(rtcpMode, TRANSPORT_TCP_INTERLEAVED);
+
+    sp<AMessage> rtpNotify = new AMessage(kWhatRTPNotify, id());
+
+    sp<AMessage> rtcpNotify;
+    if (rtcpMode != TRANSPORT_NONE) {
+        rtcpNotify = new AMessage(kWhatRTCPNotify, id());
+    }
+
+    CHECK_EQ(mRTPSessionID, 0);
+    CHECK_EQ(mRTCPSessionID, 0);
+
+    int32_t localRTPPort;
+
+    struct in_addr ifaceAddr;
+    ifaceAddr.s_addr = INADDR_ANY;
+
+    for (;;) {
+        localRTPPort = PickRandomRTPPort();
+
+        status_t err;
+        if (rtpMode == TRANSPORT_UDP) {
+            err = mNetSession->createUDPSession(
+                    localRTPPort,
+                    rtpNotify,
+                    &mRTPSessionID);
+        } else {
+            CHECK_EQ(rtpMode, TRANSPORT_TCP);
+            err = mNetSession->createTCPDatagramSession(
+                    ifaceAddr,
+                    localRTPPort,
+                    rtpNotify,
+                    &mRTPSessionID);
+        }
+
+        if (err != OK) {
+            continue;
+        }
+
+        if (rtcpMode == TRANSPORT_NONE) {
+            break;
+        } else if (rtcpMode == TRANSPORT_UDP) {
+            err = mNetSession->createUDPSession(
+                    localRTPPort + 1,
+                    rtcpNotify,
+                    &mRTCPSessionID);
+        } else {
+            CHECK_EQ(rtpMode, TRANSPORT_TCP);
+            err = mNetSession->createTCPDatagramSession(
+                    ifaceAddr,
+                    localRTPPort + 1,
+                    rtcpNotify,
+                    &mRTCPSessionID);
+        }
+
+        if (err == OK) {
+            break;
+        }
+
+        mNetSession->destroySession(mRTPSessionID);
+        mRTPSessionID = 0;
+    }
+
+    mRTPMode = rtpMode;
+    mRTCPMode = rtcpMode;
+    *outLocalRTPPort = localRTPPort;
+
+    return OK;
+}
+
+status_t RTPReceiver::connect(
+        const char *remoteHost, int32_t remoteRTPPort, int32_t remoteRTCPPort) {
+    status_t err;
+
+    if (mRTPMode == TRANSPORT_UDP) {
+        CHECK(!mRTPConnected);
+
+        err = mNetSession->connectUDPSession(
+                mRTPSessionID, remoteHost, remoteRTPPort);
+
+        if (err != OK) {
+            notifyInitDone(err);
+            return err;
+        }
+
+        ALOGI("connectUDPSession RTP successful.");
+
+        mRTPConnected = true;
+    }
+
+    if (mRTCPMode == TRANSPORT_UDP) {
+        CHECK(!mRTCPConnected);
+
+        err = mNetSession->connectUDPSession(
+                mRTCPSessionID, remoteHost, remoteRTCPPort);
+
+        if (err != OK) {
+            notifyInitDone(err);
+            return err;
+        }
+
+        scheduleSendRR();
+
+        ALOGI("connectUDPSession RTCP successful.");
+
+        mRTCPConnected = true;
+    }
+
+    if (mRTPConnected
+            && (mRTCPConnected || mRTCPMode == TRANSPORT_NONE)) {
+        notifyInitDone(OK);
+    }
+
+    return OK;
+}
+
+status_t RTPReceiver::informSender(const sp<AMessage> &params) {
+    if (!mRTCPConnected) {
+        return INVALID_OPERATION;
+    }
+
+    int64_t avgLatencyUs;
+    CHECK(params->findInt64("avgLatencyUs", &avgLatencyUs));
+
+    int64_t maxLatencyUs;
+    CHECK(params->findInt64("maxLatencyUs", &maxLatencyUs));
+
+    sp<ABuffer> buf = new ABuffer(28);
+
+    uint8_t *ptr = buf->data();
+    ptr[0] = 0x80 | 0;
+    ptr[1] = 204;  // APP
+    ptr[2] = 0;
+
+    CHECK((buf->size() % 4) == 0u);
+    ptr[3] = (buf->size() / 4) - 1;
+
+    ptr[4] = kSourceID >> 24;  // SSRC
+    ptr[5] = (kSourceID >> 16) & 0xff;
+    ptr[6] = (kSourceID >> 8) & 0xff;
+    ptr[7] = kSourceID & 0xff;
+    ptr[8] = 'l';
+    ptr[9] = 'a';
+    ptr[10] = 't';
+    ptr[11] = 'e';
+
+    ptr[12] = avgLatencyUs >> 56;
+    ptr[13] = (avgLatencyUs >> 48) & 0xff;
+    ptr[14] = (avgLatencyUs >> 40) & 0xff;
+    ptr[15] = (avgLatencyUs >> 32) & 0xff;
+    ptr[16] = (avgLatencyUs >> 24) & 0xff;
+    ptr[17] = (avgLatencyUs >> 16) & 0xff;
+    ptr[18] = (avgLatencyUs >> 8) & 0xff;
+    ptr[19] = avgLatencyUs & 0xff;
+
+    ptr[20] = maxLatencyUs >> 56;
+    ptr[21] = (maxLatencyUs >> 48) & 0xff;
+    ptr[22] = (maxLatencyUs >> 40) & 0xff;
+    ptr[23] = (maxLatencyUs >> 32) & 0xff;
+    ptr[24] = (maxLatencyUs >> 24) & 0xff;
+    ptr[25] = (maxLatencyUs >> 16) & 0xff;
+    ptr[26] = (maxLatencyUs >> 8) & 0xff;
+    ptr[27] = maxLatencyUs & 0xff;
+
+    mNetSession->sendRequest(mRTCPSessionID, buf->data(), buf->size());
+
+    return OK;
+}
+
+void RTPReceiver::onMessageReceived(const sp<AMessage> &msg) {
+    switch (msg->what()) {
+        case kWhatRTPNotify:
+        case kWhatRTCPNotify:
+            onNetNotify(msg->what() == kWhatRTPNotify, msg);
+            break;
+
+        case kWhatSendRR:
+        {
+            onSendRR();
+            break;
+        }
+
+        default:
+            TRESPASS();
+    }
+}
+
+void RTPReceiver::onNetNotify(bool isRTP, const sp<AMessage> &msg) {
+    int32_t reason;
+    CHECK(msg->findInt32("reason", &reason));
+
+    switch (reason) {
+        case ANetworkSession::kWhatError:
+        {
+            int32_t sessionID;
+            CHECK(msg->findInt32("sessionID", &sessionID));
+
+            int32_t err;
+            CHECK(msg->findInt32("err", &err));
+
+            int32_t errorOccuredDuringSend;
+            CHECK(msg->findInt32("send", &errorOccuredDuringSend));
+
+            AString detail;
+            CHECK(msg->findString("detail", &detail));
+
+            ALOGE("An error occurred during %s in session %d "
+                  "(%d, '%s' (%s)).",
+                  errorOccuredDuringSend ? "send" : "receive",
+                  sessionID,
+                  err,
+                  detail.c_str(),
+                  strerror(-err));
+
+            mNetSession->destroySession(sessionID);
+
+            if (sessionID == mRTPSessionID) {
+                mRTPSessionID = 0;
+            } else if (sessionID == mRTCPSessionID) {
+                mRTCPSessionID = 0;
+            } else if (sessionID == mRTPClientSessionID) {
+                mRTPClientSessionID = 0;
+            } else if (sessionID == mRTCPClientSessionID) {
+                mRTCPClientSessionID = 0;
+            }
+
+            if (!mRTPConnected
+                    || (mRTCPMode != TRANSPORT_NONE && !mRTCPConnected)) {
+                notifyInitDone(err);
+                break;
+            }
+
+            notifyError(err);
+            break;
+        }
+
+        case ANetworkSession::kWhatDatagram:
+        {
+            sp<ABuffer> data;
+            CHECK(msg->findBuffer("data", &data));
+
+            if (isRTP) {
+                if (mFlags & FLAG_AUTO_CONNECT) {
+                    AString fromAddr;
+                    CHECK(msg->findString("fromAddr", &fromAddr));
+
+                    int32_t fromPort;
+                    CHECK(msg->findInt32("fromPort", &fromPort));
+
+                    CHECK_EQ((status_t)OK,
+                             connect(
+                                 fromAddr.c_str(), fromPort, fromPort + 1));
+
+                    mFlags &= ~FLAG_AUTO_CONNECT;
+                }
+
+                onRTPData(data);
+            } else {
+                onRTCPData(data);
+            }
+            break;
+        }
+
+        case ANetworkSession::kWhatClientConnected:
+        {
+            int32_t sessionID;
+            CHECK(msg->findInt32("sessionID", &sessionID));
+
+            if (isRTP) {
+                CHECK_EQ(mRTPMode, TRANSPORT_TCP);
+
+                if (mRTPClientSessionID != 0) {
+                    // We only allow a single client connection.
+                    mNetSession->destroySession(sessionID);
+                    sessionID = 0;
+                    break;
+                }
+
+                mRTPClientSessionID = sessionID;
+                mRTPConnected = true;
+            } else {
+                CHECK_EQ(mRTCPMode, TRANSPORT_TCP);
+
+                if (mRTCPClientSessionID != 0) {
+                    // We only allow a single client connection.
+                    mNetSession->destroySession(sessionID);
+                    sessionID = 0;
+                    break;
+                }
+
+                mRTCPClientSessionID = sessionID;
+                mRTCPConnected = true;
+            }
+
+            if (mRTPConnected
+                    && (mRTCPConnected || mRTCPMode == TRANSPORT_NONE)) {
+                notifyInitDone(OK);
+            }
+            break;
+        }
+    }
+}
+
+void RTPReceiver::notifyInitDone(status_t err) {
+    sp<AMessage> notify = mNotify->dup();
+    notify->setInt32("what", kWhatInitDone);
+    notify->setInt32("err", err);
+    notify->post();
+}
+
+void RTPReceiver::notifyError(status_t err) {
+    sp<AMessage> notify = mNotify->dup();
+    notify->setInt32("what", kWhatError);
+    notify->setInt32("err", err);
+    notify->post();
+}
+
+void RTPReceiver::notifyPacketLost() {
+    sp<AMessage> notify = mNotify->dup();
+    notify->setInt32("what", kWhatPacketLost);
+    notify->post();
+}
+
+status_t RTPReceiver::onRTPData(const sp<ABuffer> &buffer) {
+    size_t size = buffer->size();
+    if (size < 12) {
+        // Too short to be a valid RTP header.
+        return ERROR_MALFORMED;
+    }
+
+    const uint8_t *data = buffer->data();
+
+    if ((data[0] >> 6) != 2) {
+        // Unsupported version.
+        return ERROR_UNSUPPORTED;
+    }
+
+    if (data[0] & 0x20) {
+        // Padding present.
+
+        size_t paddingLength = data[size - 1];
+
+        if (paddingLength + 12 > size) {
+            // If we removed this much padding we'd end up with something
+            // that's too short to be a valid RTP header.
+            return ERROR_MALFORMED;
+        }
+
+        size -= paddingLength;
+    }
+
+    int numCSRCs = data[0] & 0x0f;
+
+    size_t payloadOffset = 12 + 4 * numCSRCs;
+
+    if (size < payloadOffset) {
+        // Not enough data to fit the basic header and all the CSRC entries.
+        return ERROR_MALFORMED;
+    }
+
+    if (data[0] & 0x10) {
+        // Header eXtension present.
+
+        if (size < payloadOffset + 4) {
+            // Not enough data to fit the basic header, all CSRC entries
+            // and the first 4 bytes of the extension header.
+
+            return ERROR_MALFORMED;
+        }
+
+        const uint8_t *extensionData = &data[payloadOffset];
+
+        size_t extensionLength =
+            4 * (extensionData[2] << 8 | extensionData[3]);
+
+        if (size < payloadOffset + 4 + extensionLength) {
+            return ERROR_MALFORMED;
+        }
+
+        payloadOffset += 4 + extensionLength;
+    }
+
+    uint32_t srcId = U32_AT(&data[8]);
+    uint32_t rtpTime = U32_AT(&data[4]);
+    uint16_t seqNo = U16_AT(&data[2]);
+
+    sp<AMessage> meta = buffer->meta();
+    meta->setInt32("ssrc", srcId);
+    meta->setInt32("rtp-time", rtpTime);
+    meta->setInt32("PT", data[1] & 0x7f);
+    meta->setInt32("M", data[1] >> 7);
+
+    buffer->setRange(payloadOffset, size - payloadOffset);
+
+    ssize_t index = mSources.indexOfKey(srcId);
+    sp<Source> source;
+    if (index < 0) {
+        source = new Source(this, srcId);
+        looper()->registerHandler(source);
+
+        mSources.add(srcId, source);
+    } else {
+        source = mSources.valueAt(index);
+    }
+
+    source->onPacketReceived(seqNo, buffer);
+
+    return OK;
+}
+
+status_t RTPReceiver::onRTCPData(const sp<ABuffer> &data) {
+    ALOGI("onRTCPData");
+    return OK;
+}
+
+void RTPReceiver::addSDES(const sp<ABuffer> &buffer) {
+    uint8_t *data = buffer->data() + buffer->size();
+    data[0] = 0x80 | 1;
+    data[1] = 202;  // SDES
+    data[4] = kSourceID >> 24;  // SSRC
+    data[5] = (kSourceID >> 16) & 0xff;
+    data[6] = (kSourceID >> 8) & 0xff;
+    data[7] = kSourceID & 0xff;
+
+    size_t offset = 8;
+
+    data[offset++] = 1;  // CNAME
+
+    AString cname = "stagefright@somewhere";
+    data[offset++] = cname.size();
+
+    memcpy(&data[offset], cname.c_str(), cname.size());
+    offset += cname.size();
+
+    data[offset++] = 6;  // TOOL
+
+    AString tool = "stagefright/1.0";
+    data[offset++] = tool.size();
+
+    memcpy(&data[offset], tool.c_str(), tool.size());
+    offset += tool.size();
+
+    data[offset++] = 0;
+
+    if ((offset % 4) > 0) {
+        size_t count = 4 - (offset % 4);
+        switch (count) {
+            case 3:
+                data[offset++] = 0;
+            case 2:
+                data[offset++] = 0;
+            case 1:
+                data[offset++] = 0;
+        }
+    }
+
+    size_t numWords = (offset / 4) - 1;
+    data[2] = numWords >> 8;
+    data[3] = numWords & 0xff;
+
+    buffer->setRange(buffer->offset(), buffer->size() + offset);
+}
+
+void RTPReceiver::scheduleSendRR() {
+    (new AMessage(kWhatSendRR, id()))->post(5000000ll);
+}
+
+void RTPReceiver::onSendRR() {
+    sp<ABuffer> buf = new ABuffer(kMaxUDPPacketSize);
+    buf->setRange(0, 0);
+
+    uint8_t *ptr = buf->data();
+    ptr[0] = 0x80 | 0;
+    ptr[1] = 201;  // RR
+    ptr[2] = 0;
+    ptr[3] = 1;
+    ptr[4] = kSourceID >> 24;  // SSRC
+    ptr[5] = (kSourceID >> 16) & 0xff;
+    ptr[6] = (kSourceID >> 8) & 0xff;
+    ptr[7] = kSourceID & 0xff;
+
+    buf->setRange(0, 8);
+
+    size_t numReportBlocks = 0;
+    for (size_t i = 0; i < mSources.size(); ++i) {
+        uint32_t ssrc = mSources.keyAt(i);
+        sp<Source> source = mSources.valueAt(i);
+
+        if (numReportBlocks > 31 || buf->size() + 24 > buf->capacity()) {
+            // Cannot fit another report block.
+            break;
+        }
+
+        source->addReportBlock(ssrc, buf);
+        ++numReportBlocks;
+    }
+
+    ptr[0] |= numReportBlocks;  // 5 bit
+
+    size_t sizeInWordsMinus1 = 1 + 6 * numReportBlocks;
+    ptr[2] = sizeInWordsMinus1 >> 8;
+    ptr[3] = sizeInWordsMinus1 & 0xff;
+
+    buf->setRange(0, (sizeInWordsMinus1 + 1) * 4);
+
+    addSDES(buf);
+
+    mNetSession->sendRequest(mRTCPSessionID, buf->data(), buf->size());
+
+    scheduleSendRR();
+}
+
+status_t RTPReceiver::registerPacketType(
+        uint8_t packetType, PacketizationMode mode) {
+    mPacketTypes.add(packetType, mode);
+
+    return OK;
+}
+
+sp<RTPReceiver::Assembler> RTPReceiver::makeAssembler(uint8_t packetType) {
+    ssize_t index = mPacketTypes.indexOfKey(packetType);
+    if (index < 0) {
+        return NULL;
+    }
+
+    PacketizationMode mode = mPacketTypes.valueAt(index);
+
+    switch (mode) {
+        case PACKETIZATION_NONE:
+        case PACKETIZATION_TRANSPORT_STREAM:
+            return new TSAssembler(mNotify);
+
+        case PACKETIZATION_H264:
+            return new H264Assembler(mNotify);
+
+        default:
+            return NULL;
+    }
+}
+
+void RTPReceiver::requestRetransmission(uint32_t senderSSRC, int32_t extSeqNo) {
+    int32_t blp = 0;
+
+    sp<ABuffer> buf = new ABuffer(16);
+    buf->setRange(0, 0);
+
+    uint8_t *ptr = buf->data();
+    ptr[0] = 0x80 | 1;  // generic NACK
+    ptr[1] = 205;  // TSFB
+    ptr[2] = 0;
+    ptr[3] = 3;
+    ptr[8] = (senderSSRC >> 24) & 0xff;
+    ptr[9] = (senderSSRC >> 16) & 0xff;
+    ptr[10] = (senderSSRC >> 8) & 0xff;
+    ptr[11] = (senderSSRC & 0xff);
+    ptr[8] = (kSourceID >> 24) & 0xff;
+    ptr[9] = (kSourceID >> 16) & 0xff;
+    ptr[10] = (kSourceID >> 8) & 0xff;
+    ptr[11] = (kSourceID & 0xff);
+    ptr[12] = (extSeqNo >> 8) & 0xff;
+    ptr[13] = (extSeqNo & 0xff);
+    ptr[14] = (blp >> 8) & 0xff;
+    ptr[15] = (blp & 0xff);
+
+    buf->setRange(0, 16);
+
+     mNetSession->sendRequest(mRTCPSessionID, buf->data(), buf->size());
+}
+
+void RTPReceiver::Source::modifyPacketStatus(int32_t extSeqNo, uint32_t mask) {
+#if TRACK_PACKET_LOSS
+    ssize_t index = mLostPackets.indexOfKey(extSeqNo);
+    if (index < 0) {
+        mLostPackets.add(extSeqNo, mask);
+    } else {
+        mLostPackets.editValueAt(index) |= mask;
+    }
+#endif
+}
+
+void RTPReceiver::Source::postRetransmitTimer(int64_t timeUs) {
+    int64_t delayUs = timeUs - ALooper::GetNowUs();
+    sp<AMessage> msg = new AMessage(kWhatRetransmit, id());
+    msg->setInt32("generation", mRetransmitGeneration);
+    msg->post(delayUs);
+}
+
+void RTPReceiver::Source::postDeclareLostTimer(int64_t timeUs) {
+    CHECK(!mDeclareLostTimerPending);
+    mDeclareLostTimerPending = true;
+
+    int64_t delayUs = timeUs - ALooper::GetNowUs();
+    sp<AMessage> msg = new AMessage(kWhatDeclareLost, id());
+    msg->setInt32("generation", mDeclareLostGeneration);
+    msg->post(delayUs);
+}
+
+void RTPReceiver::Source::cancelTimers() {
+    ++mRetransmitGeneration;
+    ++mDeclareLostGeneration;
+    mDeclareLostTimerPending = false;
+}
+
+}  // namespace android
diff -Naur a/frameworks/av/media/libstagefright/wifi-display/rtp/RTPReceiver.h b/frameworks/av/media/libstagefright/wifi-display/rtp/RTPReceiver.h
--- a/frameworks/av/media/libstagefright/wifi-display/rtp/RTPReceiver.h	1969-12-31 19:00:00.000000000 -0500
+++ b/frameworks/av/media/libstagefright/wifi-display/rtp/RTPReceiver.h	2014-03-24 10:00:17.272393809 -0400
@@ -0,0 +1,125 @@
+/*
+ * Copyright 2013, The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#ifndef RTP_RECEIVER_H_
+
+#define RTP_RECEIVER_H_
+
+#include "RTPBase.h"
+
+#include <media/stagefright/foundation/AHandler.h>
+
+namespace android {
+
+struct ABuffer;
+struct ANetworkSession;
+
+// An object of this class facilitates receiving of media data on an RTP
+// channel. The channel is established over a UDP or TCP connection depending
+// on which "TransportMode" was chosen. In addition different RTP packetization
+// schemes are supported such as "Transport Stream Packets over RTP",
+// or "AVC/H.264 encapsulation as specified in RFC 3984 (non-interleaved mode)"
+struct RTPReceiver : public RTPBase, public AHandler {
+    enum {
+        kWhatInitDone,
+        kWhatError,
+        kWhatAccessUnit,
+        kWhatPacketLost,
+    };
+
+    enum Flags {
+        FLAG_AUTO_CONNECT = 1,
+    };
+    RTPReceiver(
+            const sp<ANetworkSession> &netSession,
+            const sp<AMessage> &notify,
+            uint32_t flags = 0);
+
+    status_t registerPacketType(
+            uint8_t packetType, PacketizationMode mode);
+
+    status_t initAsync(
+            TransportMode rtpMode,
+            TransportMode rtcpMode,
+            int32_t *outLocalRTPPort);
+
+    status_t connect(
+            const char *remoteHost,
+            int32_t remoteRTPPort,
+            int32_t remoteRTCPPort);
+
+    status_t informSender(const sp<AMessage> &params);
+
+protected:
+    virtual ~RTPReceiver();
+    virtual void onMessageReceived(const sp<AMessage> &msg);
+
+private:
+    enum {
+        kWhatRTPNotify,
+        kWhatRTCPNotify,
+        kWhatSendRR,
+    };
+
+    enum {
+        kSourceID                       = 0xdeadbeef,
+        kPacketLostAfterUs              = 100000,
+        kRequestRetransmissionAfterUs   = -1,
+    };
+
+    struct Assembler;
+    struct H264Assembler;
+    struct Source;
+    struct TSAssembler;
+
+    sp<ANetworkSession> mNetSession;
+    sp<AMessage> mNotify;
+    uint32_t mFlags;
+    TransportMode mRTPMode;
+    TransportMode mRTCPMode;
+    int32_t mRTPSessionID;
+    int32_t mRTCPSessionID;
+    bool mRTPConnected;
+    bool mRTCPConnected;
+
+    int32_t mRTPClientSessionID;  // in TRANSPORT_TCP mode.
+    int32_t mRTCPClientSessionID;  // in TRANSPORT_TCP mode.
+
+    KeyedVector<uint8_t, PacketizationMode> mPacketTypes;
+    KeyedVector<uint32_t, sp<Source> > mSources;
+
+    void onNetNotify(bool isRTP, const sp<AMessage> &msg);
+    status_t onRTPData(const sp<ABuffer> &data);
+    status_t onRTCPData(const sp<ABuffer> &data);
+    void onSendRR();
+
+    void scheduleSendRR();
+    void addSDES(const sp<ABuffer> &buffer);
+
+    void notifyInitDone(status_t err);
+    void notifyError(status_t err);
+    void notifyPacketLost();
+
+    sp<Assembler> makeAssembler(uint8_t packetType);
+
+    void requestRetransmission(uint32_t senderSSRC, int32_t extSeqNo);
+
+    DISALLOW_EVIL_CONSTRUCTORS(RTPReceiver);
+};
+
+}  // namespace android
+
+#endif  // RTP_RECEIVER_H_
diff -Naur a/frameworks/av/media/libstagefright/wifi-display/rtptest.cpp b/frameworks/av/media/libstagefright/wifi-display/rtptest.cpp
--- a/frameworks/av/media/libstagefright/wifi-display/rtptest.cpp	1969-12-31 19:00:00.000000000 -0500
+++ b/frameworks/av/media/libstagefright/wifi-display/rtptest.cpp	2014-03-24 10:01:27.400395266 -0400
@@ -0,0 +1,564 @@
+/*
+ * Copyright 2013, The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+//#define LOG_NEBUG 0
+#define LOG_TAG "rtptest"
+#include <utils/Log.h>
+
+#include "rtp/RTPSender.h"
+#include "rtp/RTPReceiver.h"
+#include "TimeSyncer.h"
+
+#include <binder/ProcessState.h>
+#include <media/stagefright/foundation/ABuffer.h>
+#include <media/stagefright/foundation/ADebug.h>
+#include <media/stagefright/foundation/AHandler.h>
+#include <media/stagefright/foundation/ALooper.h>
+#include <media/stagefright/foundation/AMessage.h>
+#include <media/stagefright/foundation/ANetworkSession.h>
+#include <media/stagefright/foundation/hexdump.h>
+#include <media/stagefright/DataSource.h>
+#include <media/stagefright/MediaDefs.h>
+#include <media/stagefright/NuMediaExtractor.h>
+#include <media/stagefright/Utils.h>
+
+#define MEDIA_FILENAME "/sdcard/Frame Counter HD 30FPS_1080p.mp4"
+
+namespace android {
+
+struct PacketSource : public RefBase {
+    PacketSource() {}
+
+    virtual sp<ABuffer> getNextAccessUnit() = 0;
+
+protected:
+    virtual ~PacketSource() {}
+
+private:
+    DISALLOW_EVIL_CONSTRUCTORS(PacketSource);
+};
+
+struct MediaPacketSource : public PacketSource {
+    MediaPacketSource()
+        : mMaxSampleSize(1024 * 1024) {
+        mExtractor = new NuMediaExtractor;
+        CHECK_EQ((status_t)OK,
+                 mExtractor->setDataSource(MEDIA_FILENAME));
+
+        bool haveVideo = false;
+        for (size_t i = 0; i < mExtractor->countTracks(); ++i) {
+            sp<AMessage> format;
+            CHECK_EQ((status_t)OK, mExtractor->getTrackFormat(i, &format));
+
+            AString mime;
+            CHECK(format->findString("mime", &mime));
+
+            if (!strcasecmp(MEDIA_MIMETYPE_VIDEO_AVC, mime.c_str())) {
+                mExtractor->selectTrack(i);
+                haveVideo = true;
+                break;
+            }
+        }
+
+        CHECK(haveVideo);
+    }
+
+    virtual sp<ABuffer> getNextAccessUnit() {
+        int64_t timeUs;
+        status_t err = mExtractor->getSampleTime(&timeUs);
+
+        if (err != OK) {
+            return NULL;
+        }
+
+        sp<ABuffer> accessUnit = new ABuffer(mMaxSampleSize);
+        CHECK_EQ((status_t)OK, mExtractor->readSampleData(accessUnit));
+
+        accessUnit->meta()->setInt64("timeUs", timeUs);
+
+        CHECK_EQ((status_t)OK, mExtractor->advance());
+
+        return accessUnit;
+    }
+
+protected:
+    virtual ~MediaPacketSource() {
+    }
+
+private:
+    sp<NuMediaExtractor> mExtractor;
+    size_t mMaxSampleSize;
+
+    DISALLOW_EVIL_CONSTRUCTORS(MediaPacketSource);
+};
+
+struct SimplePacketSource : public PacketSource {
+    SimplePacketSource()
+        : mCounter(0) {
+    }
+
+    virtual sp<ABuffer> getNextAccessUnit() {
+        sp<ABuffer> buffer = new ABuffer(4);
+        uint8_t *dst = buffer->data();
+        dst[0] = mCounter >> 24;
+        dst[1] = (mCounter >> 16) & 0xff;
+        dst[2] = (mCounter >> 8) & 0xff;
+        dst[3] = mCounter & 0xff;
+
+        buffer->meta()->setInt64("timeUs", mCounter * 1000000ll / kFrameRate);
+
+        ++mCounter;
+
+        return buffer;
+    }
+
+protected:
+    virtual ~SimplePacketSource() {
+    }
+
+private:
+    enum {
+        kFrameRate = 30
+    };
+
+    uint32_t mCounter;
+
+    DISALLOW_EVIL_CONSTRUCTORS(SimplePacketSource);
+};
+
+struct TestHandler : public AHandler {
+    TestHandler(const sp<ANetworkSession> &netSession);
+
+    void listen();
+    void connect(const char *host, int32_t port);
+
+protected:
+    virtual ~TestHandler();
+    virtual void onMessageReceived(const sp<AMessage> &msg);
+
+private:
+    enum {
+        kWhatListen,
+        kWhatConnect,
+        kWhatReceiverNotify,
+        kWhatSenderNotify,
+        kWhatSendMore,
+        kWhatStop,
+        kWhatTimeSyncerNotify,
+    };
+
+#if 1
+    static const RTPBase::TransportMode kRTPMode = RTPBase::TRANSPORT_UDP;
+    static const RTPBase::TransportMode kRTCPMode = RTPBase::TRANSPORT_UDP;
+#else
+    static const RTPBase::TransportMode kRTPMode = RTPBase::TRANSPORT_TCP;
+    static const RTPBase::TransportMode kRTCPMode = RTPBase::TRANSPORT_NONE;
+#endif
+
+#if 1
+    static const RTPBase::PacketizationMode kPacketizationMode
+        = RTPBase::PACKETIZATION_H264;
+#else
+    static const RTPBase::PacketizationMode kPacketizationMode
+        = RTPBase::PACKETIZATION_NONE;
+#endif
+
+    sp<ANetworkSession> mNetSession;
+    sp<PacketSource> mSource;
+    sp<RTPSender> mSender;
+    sp<RTPReceiver> mReceiver;
+
+    sp<TimeSyncer> mTimeSyncer;
+    bool mTimeSyncerStarted;
+
+    int64_t mFirstTimeRealUs;
+    int64_t mFirstTimeMediaUs;
+
+    int64_t mTimeOffsetUs;
+    bool mTimeOffsetValid;
+
+    status_t readMore();
+
+    DISALLOW_EVIL_CONSTRUCTORS(TestHandler);
+};
+
+TestHandler::TestHandler(const sp<ANetworkSession> &netSession)
+    : mNetSession(netSession),
+      mTimeSyncerStarted(false),
+      mFirstTimeRealUs(-1ll),
+      mFirstTimeMediaUs(-1ll),
+      mTimeOffsetUs(-1ll),
+      mTimeOffsetValid(false) {
+}
+
+TestHandler::~TestHandler() {
+}
+
+void TestHandler::listen() {
+    sp<AMessage> msg = new AMessage(kWhatListen, id());
+    msg->post();
+}
+
+void TestHandler::connect(const char *host, int32_t port) {
+    sp<AMessage> msg = new AMessage(kWhatConnect, id());
+    msg->setString("host", host);
+    msg->setInt32("port", port);
+    msg->post();
+}
+
+static void dumpDelay(int64_t delayMs) {
+    static const int64_t kMinDelayMs = 0;
+    static const int64_t kMaxDelayMs = 300;
+
+    const char *kPattern = "########################################";
+    size_t kPatternSize = strlen(kPattern);
+
+    int n = (kPatternSize * (delayMs - kMinDelayMs))
+                / (kMaxDelayMs - kMinDelayMs);
+
+    if (n < 0) {
+        n = 0;
+    } else if ((size_t)n > kPatternSize) {
+        n = kPatternSize;
+    }
+
+    ALOGI("(%4lld ms) %s\n",
+          delayMs,
+          kPattern + kPatternSize - n);
+}
+
+void TestHandler::onMessageReceived(const sp<AMessage> &msg) {
+    switch (msg->what()) {
+        case kWhatListen:
+        {
+            sp<AMessage> notify = new AMessage(kWhatTimeSyncerNotify, id());
+            mTimeSyncer = new TimeSyncer(mNetSession, notify);
+            looper()->registerHandler(mTimeSyncer);
+
+            notify = new AMessage(kWhatReceiverNotify, id());
+            mReceiver = new RTPReceiver(
+                    mNetSession, notify, RTPReceiver::FLAG_AUTO_CONNECT);
+            looper()->registerHandler(mReceiver);
+
+            CHECK_EQ((status_t)OK,
+                     mReceiver->registerPacketType(33, kPacketizationMode));
+
+            int32_t receiverRTPPort;
+            CHECK_EQ((status_t)OK,
+                     mReceiver->initAsync(
+                         kRTPMode,
+                         kRTCPMode,
+                         &receiverRTPPort));
+
+            printf("picked receiverRTPPort %d\n", receiverRTPPort);
+
+#if 0
+            CHECK_EQ((status_t)OK,
+                     mReceiver->connect(
+                         "127.0.0.1", senderRTPPort, senderRTPPort + 1));
+#endif
+            break;
+        }
+
+        case kWhatConnect:
+        {
+            AString host;
+            CHECK(msg->findString("host", &host));
+
+            sp<AMessage> notify = new AMessage(kWhatTimeSyncerNotify, id());
+            mTimeSyncer = new TimeSyncer(mNetSession, notify);
+            looper()->registerHandler(mTimeSyncer);
+            mTimeSyncer->startServer(8123);
+
+            int32_t receiverRTPPort;
+            CHECK(msg->findInt32("port", &receiverRTPPort));
+
+#if 1
+            mSource = new MediaPacketSource;
+#else
+            mSource = new SimplePacketSource;
+#endif
+
+            notify = new AMessage(kWhatSenderNotify, id());
+            mSender = new RTPSender(mNetSession, notify);
+
+            looper()->registerHandler(mSender);
+
+            int32_t senderRTPPort;
+            CHECK_EQ((status_t)OK,
+                     mSender->initAsync(
+                         host.c_str(),
+                         receiverRTPPort,
+                         kRTPMode,
+                         kRTCPMode == RTPBase::TRANSPORT_NONE
+                            ? -1 : receiverRTPPort + 1,
+                         kRTCPMode,
+                         &senderRTPPort));
+
+            printf("picked senderRTPPort %d\n", senderRTPPort);
+            break;
+        }
+
+        case kWhatSenderNotify:
+        {
+            ALOGI("kWhatSenderNotify");
+
+            int32_t what;
+            CHECK(msg->findInt32("what", &what));
+
+            switch (what) {
+                case RTPSender::kWhatInitDone:
+                {
+                    int32_t err;
+                    CHECK(msg->findInt32("err", &err));
+
+                    ALOGI("RTPSender::initAsync completed w/ err %d", err);
+
+                    if (err == OK) {
+                        err = readMore();
+
+                        if (err != OK) {
+                            (new AMessage(kWhatStop, id()))->post();
+                        }
+                    }
+                    break;
+                }
+
+                case RTPSender::kWhatError:
+                    break;
+            }
+            break;
+        }
+
+        case kWhatReceiverNotify:
+        {
+            ALOGV("kWhatReceiverNotify");
+
+            int32_t what;
+            CHECK(msg->findInt32("what", &what));
+
+            switch (what) {
+                case RTPReceiver::kWhatInitDone:
+                {
+                    int32_t err;
+                    CHECK(msg->findInt32("err", &err));
+
+                    ALOGI("RTPReceiver::initAsync completed w/ err %d", err);
+                    break;
+                }
+
+                case RTPReceiver::kWhatError:
+                    break;
+
+                case RTPReceiver::kWhatAccessUnit:
+                {
+#if 0
+                    if (!mTimeSyncerStarted) {
+                        mTimeSyncer->startClient("172.18.41.216", 8123);
+                        mTimeSyncerStarted = true;
+                    }
+
+                    sp<ABuffer> accessUnit;
+                    CHECK(msg->findBuffer("accessUnit", &accessUnit));
+
+                    int64_t timeUs;
+                    CHECK(accessUnit->meta()->findInt64("timeUs", &timeUs));
+
+                    if (mTimeOffsetValid) {
+                        timeUs -= mTimeOffsetUs;
+                        int64_t nowUs = ALooper::GetNowUs();
+                        int64_t delayMs = (nowUs - timeUs) / 1000ll;
+
+                        dumpDelay(delayMs);
+                    }
+#endif
+                    break;
+                }
+
+                case RTPReceiver::kWhatPacketLost:
+                    ALOGV("kWhatPacketLost");
+                    break;
+
+                default:
+                    TRESPASS();
+            }
+            break;
+        }
+
+        case kWhatSendMore:
+        {
+            sp<ABuffer> accessUnit;
+            CHECK(msg->findBuffer("accessUnit", &accessUnit));
+
+            CHECK_EQ((status_t)OK,
+                     mSender->queueBuffer(
+                         accessUnit,
+                         33,
+                         kPacketizationMode));
+
+            status_t err = readMore();
+
+            if (err != OK) {
+                (new AMessage(kWhatStop, id()))->post();
+            }
+            break;
+        }
+
+        case kWhatStop:
+        {
+            if (mReceiver != NULL) {
+                looper()->unregisterHandler(mReceiver->id());
+                mReceiver.clear();
+            }
+
+            if (mSender != NULL) {
+                looper()->unregisterHandler(mSender->id());
+                mSender.clear();
+            }
+
+            mSource.clear();
+
+            looper()->stop();
+            break;
+        }
+
+        case kWhatTimeSyncerNotify:
+        {
+            CHECK(msg->findInt64("offset", &mTimeOffsetUs));
+            mTimeOffsetValid = true;
+            break;
+        }
+
+        default:
+            TRESPASS();
+    }
+}
+
+status_t TestHandler::readMore() {
+    sp<ABuffer> accessUnit = mSource->getNextAccessUnit();
+
+    if (accessUnit == NULL) {
+        return ERROR_END_OF_STREAM;
+    }
+
+    int64_t timeUs;
+    CHECK(accessUnit->meta()->findInt64("timeUs", &timeUs));
+
+    int64_t nowUs = ALooper::GetNowUs();
+    int64_t whenUs;
+
+    if (mFirstTimeRealUs < 0ll) {
+        mFirstTimeRealUs = whenUs = nowUs;
+        mFirstTimeMediaUs = timeUs;
+    } else {
+        whenUs = mFirstTimeRealUs + timeUs - mFirstTimeMediaUs;
+    }
+
+    accessUnit->meta()->setInt64("timeUs", whenUs);
+
+    sp<AMessage> msg = new AMessage(kWhatSendMore, id());
+    msg->setBuffer("accessUnit", accessUnit);
+    msg->post(whenUs - nowUs);
+
+    return OK;
+}
+
+}  // namespace android
+
+static void usage(const char *me) {
+    fprintf(stderr,
+            "usage: %s -c host:port\tconnect to remote host\n"
+            "               -l       \tlisten\n",
+            me);
+}
+
+int main(int argc, char **argv) {
+    using namespace android;
+
+    // srand(time(NULL));
+
+    ProcessState::self()->startThreadPool();
+
+    DataSource::RegisterDefaultSniffers();
+
+    bool listen = false;
+    int32_t connectToPort = -1;
+    AString connectToHost;
+
+    int res;
+    while ((res = getopt(argc, argv, "hc:l")) >= 0) {
+        switch (res) {
+            case 'c':
+            {
+                const char *colonPos = strrchr(optarg, ':');
+
+                if (colonPos == NULL) {
+                    usage(argv[0]);
+                    exit(1);
+                }
+
+                connectToHost.setTo(optarg, colonPos - optarg);
+
+                char *end;
+                connectToPort = strtol(colonPos + 1, &end, 10);
+
+                if (*end != '\0' || end == colonPos + 1
+                        || connectToPort < 1 || connectToPort > 65535) {
+                    fprintf(stderr, "Illegal port specified.\n");
+                    exit(1);
+                }
+                break;
+            }
+
+            case 'l':
+            {
+                listen = true;
+                break;
+            }
+
+            case '?':
+            case 'h':
+                usage(argv[0]);
+                exit(1);
+        }
+    }
+
+    if (!listen && connectToPort < 0) {
+        fprintf(stderr,
+                "You need to select either client or server mode.\n");
+        exit(1);
+    }
+
+    sp<ANetworkSession> netSession = new ANetworkSession;
+    netSession->start();
+
+    sp<ALooper> looper = new ALooper;
+
+    sp<TestHandler> handler = new TestHandler(netSession);
+    looper->registerHandler(handler);
+
+    if (listen) {
+        handler->listen();
+    }
+
+    if (connectToPort >= 0) {
+        handler->connect(connectToHost.c_str(), connectToPort);
+    }
+
+    looper->start(true /* runOnCallingThread */);
+
+    return 0;
+}
diff -Naur a/frameworks/av/media/libstagefright/wifi-display/sink/DirectRenderer.cpp b/frameworks/av/media/libstagefright/wifi-display/sink/DirectRenderer.cpp
--- a/frameworks/av/media/libstagefright/wifi-display/sink/DirectRenderer.cpp	1969-12-31 19:00:00.000000000 -0500
+++ b/frameworks/av/media/libstagefright/wifi-display/sink/DirectRenderer.cpp	2014-03-24 13:27:01.104651000 -0400
@@ -0,0 +1,652 @@
+/*
+ * Copyright 2012, The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+//#define LOG_NDEBUG 0
+#define LOG_TAG "DirectRenderer"
+#include <utils/Log.h>
+
+#include "DirectRenderer.h"
+
+#include <gui/SurfaceComposerClient.h>
+#include <gui/Surface.h>
+#include <media/AudioTrack.h>
+#include <media/ICrypto.h>
+#include <media/stagefright/foundation/ABuffer.h>
+#include <media/stagefright/foundation/ADebug.h>
+#include <media/stagefright/foundation/AMessage.h>
+#include <media/stagefright/foundation/hexdump.h>
+#include <media/stagefright/MediaCodec.h>
+#include <media/stagefright/MediaDefs.h>
+#include <media/stagefright/MediaErrors.h>
+
+namespace android {
+
+/*
+   Drives the decoding process using a MediaCodec instance. Input buffers
+   queued by calls to "queueInputBuffer" are fed to the decoder as soon
+   as the decoder is ready for them, the client is notified about output
+   buffers as the decoder spits them out.
+*/
+struct DirectRenderer::DecoderContext : public AHandler {
+    enum {
+        kWhatOutputBufferReady,
+    };
+    DecoderContext(const sp<AMessage> &notify);
+
+    status_t init(
+            const sp<AMessage> &format,
+            const sp<IGraphicBufferProducer> &surfaceTex);
+
+    void queueInputBuffer(const sp<ABuffer> &accessUnit);
+
+    status_t renderOutputBufferAndRelease(size_t index);
+    status_t releaseOutputBuffer(size_t index);
+
+protected:
+    virtual ~DecoderContext();
+
+    virtual void onMessageReceived(const sp<AMessage> &msg);
+
+private:
+    enum {
+        kWhatDecoderNotify,
+    };
+
+    sp<AMessage> mNotify;
+    sp<ALooper> mDecoderLooper;
+    sp<MediaCodec> mDecoder;
+    Vector<sp<ABuffer> > mDecoderInputBuffers;
+    Vector<sp<ABuffer> > mDecoderOutputBuffers;
+    List<size_t> mDecoderInputBuffersAvailable;
+    bool mDecoderNotificationPending;
+
+    List<sp<ABuffer> > mAccessUnits;
+
+    void onDecoderNotify();
+    void scheduleDecoderNotification();
+    void queueDecoderInputBuffers();
+
+    void queueOutputBuffer(
+            size_t index, int64_t timeUs, const sp<ABuffer> &buffer);
+
+    DISALLOW_EVIL_CONSTRUCTORS(DecoderContext);
+};
+
+////////////////////////////////////////////////////////////////////////////////
+
+/*
+   A "push" audio renderer. The primary function of this renderer is to use
+   an AudioTrack in push mode and making sure not to block the event loop
+   be ensuring that calls to AudioTrack::write never block. This is done by
+   estimating an upper bound of data that can be written to the AudioTrack
+   buffer without delay.
+*/
+struct DirectRenderer::AudioRenderer : public AHandler {
+    AudioRenderer(const sp<DecoderContext> &decoderContext);
+
+    void queueInputBuffer(
+            size_t index, int64_t timeUs, const sp<ABuffer> &buffer);
+
+protected:
+    virtual ~AudioRenderer();
+    virtual void onMessageReceived(const sp<AMessage> &msg);
+
+private:
+    enum {
+        kWhatPushAudio,
+    };
+
+    struct BufferInfo {
+        size_t mIndex;
+        int64_t mTimeUs;
+        sp<ABuffer> mBuffer;
+    };
+
+    sp<DecoderContext> mDecoderContext;
+    sp<AudioTrack> mAudioTrack;
+
+    List<BufferInfo> mInputBuffers;
+    bool mPushPending;
+
+    size_t mNumFramesWritten;
+
+    void schedulePushIfNecessary();
+    void onPushAudio();
+
+    ssize_t writeNonBlocking(const uint8_t *data, size_t size);
+
+    DISALLOW_EVIL_CONSTRUCTORS(AudioRenderer);
+};
+
+////////////////////////////////////////////////////////////////////////////////
+
+DirectRenderer::DecoderContext::DecoderContext(const sp<AMessage> &notify)
+    : mNotify(notify),
+      mDecoderNotificationPending(false) {
+}
+
+DirectRenderer::DecoderContext::~DecoderContext() {
+    if (mDecoder != NULL) {
+        mDecoder->release();
+        mDecoder.clear();
+
+        mDecoderLooper->stop();
+        mDecoderLooper.clear();
+    }
+}
+
+status_t DirectRenderer::DecoderContext::init(
+        const sp<AMessage> &format,
+        const sp<IGraphicBufferProducer> &surfaceTex) {
+    CHECK(mDecoder == NULL);
+
+    AString mime;
+    CHECK(format->findString("mime", &mime));
+
+    mDecoderLooper = new ALooper;
+    mDecoderLooper->setName("video codec looper");
+
+    mDecoderLooper->start(
+            false /* runOnCallingThread */,
+            false /* canCallJava */,
+            PRIORITY_DEFAULT);
+
+    mDecoder = MediaCodec::CreateByType(
+            mDecoderLooper, mime.c_str(), false /* encoder */);
+
+    CHECK(mDecoder != NULL);
+
+    status_t err = mDecoder->configure(
+            format,
+            surfaceTex == NULL
+                ? NULL : new Surface(surfaceTex),
+            NULL /* crypto */,
+            0 /* flags */);
+    CHECK_EQ(err, (status_t)OK);
+
+    err = mDecoder->start();
+    CHECK_EQ(err, (status_t)OK);
+
+    err = mDecoder->getInputBuffers(
+            &mDecoderInputBuffers);
+    CHECK_EQ(err, (status_t)OK);
+
+    err = mDecoder->getOutputBuffers(
+            &mDecoderOutputBuffers);
+    CHECK_EQ(err, (status_t)OK);
+
+    scheduleDecoderNotification();
+
+    return OK;
+}
+
+void DirectRenderer::DecoderContext::queueInputBuffer(
+        const sp<ABuffer> &accessUnit) {
+    CHECK(mDecoder != NULL);
+
+    mAccessUnits.push_back(accessUnit);
+    queueDecoderInputBuffers();
+}
+
+status_t DirectRenderer::DecoderContext::renderOutputBufferAndRelease(
+        size_t index) {
+    return mDecoder->renderOutputBufferAndRelease(index);
+}
+
+status_t DirectRenderer::DecoderContext::releaseOutputBuffer(size_t index) {
+    return mDecoder->releaseOutputBuffer(index);
+}
+
+void DirectRenderer::DecoderContext::queueDecoderInputBuffers() {
+    if (mDecoder == NULL) {
+        return;
+    }
+
+    bool submittedMore = false;
+
+    while (!mAccessUnits.empty()
+            && !mDecoderInputBuffersAvailable.empty()) {
+        size_t index = *mDecoderInputBuffersAvailable.begin();
+
+        mDecoderInputBuffersAvailable.erase(
+                mDecoderInputBuffersAvailable.begin());
+
+        sp<ABuffer> srcBuffer = *mAccessUnits.begin();
+        mAccessUnits.erase(mAccessUnits.begin());
+
+        const sp<ABuffer> &dstBuffer =
+            mDecoderInputBuffers.itemAt(index);
+
+        memcpy(dstBuffer->data(), srcBuffer->data(), srcBuffer->size());
+
+        int64_t timeUs;
+        CHECK(srcBuffer->meta()->findInt64("timeUs", &timeUs));
+
+        status_t err = mDecoder->queueInputBuffer(
+                index,
+                0 /* offset */,
+                srcBuffer->size(),
+                timeUs,
+                0 /* flags */);
+        CHECK_EQ(err, (status_t)OK);
+
+        submittedMore = true;
+    }
+
+    if (submittedMore) {
+        scheduleDecoderNotification();
+    }
+}
+
+void DirectRenderer::DecoderContext::onMessageReceived(
+        const sp<AMessage> &msg) {
+    switch (msg->what()) {
+        case kWhatDecoderNotify:
+        {
+            onDecoderNotify();
+            break;
+        }
+
+        default:
+            TRESPASS();
+    }
+}
+
+void DirectRenderer::DecoderContext::onDecoderNotify() {
+    mDecoderNotificationPending = false;
+
+    for (;;) {
+        size_t index;
+        status_t err = mDecoder->dequeueInputBuffer(&index);
+
+        if (err == OK) {
+            mDecoderInputBuffersAvailable.push_back(index);
+        } else if (err == -EAGAIN) {
+            break;
+        } else {
+            TRESPASS();
+        }
+    }
+
+    queueDecoderInputBuffers();
+
+    for (;;) {
+        size_t index;
+        size_t offset;
+        size_t size;
+        int64_t timeUs;
+        uint32_t flags;
+        status_t err = mDecoder->dequeueOutputBuffer(
+                &index,
+                &offset,
+                &size,
+                &timeUs,
+                &flags);
+
+        if (err == OK) {
+            queueOutputBuffer(
+                    index, timeUs, mDecoderOutputBuffers.itemAt(index));
+        } else if (err == INFO_OUTPUT_BUFFERS_CHANGED) {
+            err = mDecoder->getOutputBuffers(
+                    &mDecoderOutputBuffers);
+            CHECK_EQ(err, (status_t)OK);
+        } else if (err == INFO_FORMAT_CHANGED) {
+            // We don't care.
+        } else if (err == -EAGAIN) {
+            break;
+        } else {
+            TRESPASS();
+        }
+    }
+
+    scheduleDecoderNotification();
+}
+
+void DirectRenderer::DecoderContext::scheduleDecoderNotification() {
+    if (mDecoderNotificationPending) {
+        return;
+    }
+
+    sp<AMessage> notify =
+        new AMessage(kWhatDecoderNotify, id());
+
+    mDecoder->requestActivityNotification(notify);
+    mDecoderNotificationPending = true;
+}
+
+void DirectRenderer::DecoderContext::queueOutputBuffer(
+        size_t index, int64_t timeUs, const sp<ABuffer> &buffer) {
+    sp<AMessage> msg = mNotify->dup();
+    msg->setInt32("what", kWhatOutputBufferReady);
+    msg->setSize("index", index);
+    msg->setInt64("timeUs", timeUs);
+    msg->setBuffer("buffer", buffer);
+    msg->post();
+}
+
+////////////////////////////////////////////////////////////////////////////////
+
+DirectRenderer::AudioRenderer::AudioRenderer(
+        const sp<DecoderContext> &decoderContext)
+    : mDecoderContext(decoderContext),
+      mPushPending(false),
+      mNumFramesWritten(0) {
+    mAudioTrack = new AudioTrack(
+            AUDIO_STREAM_DEFAULT,
+            48000.0f,
+            AUDIO_FORMAT_PCM,
+            AUDIO_CHANNEL_OUT_STEREO,
+            (int)0 /* frameCount */);
+
+    CHECK_EQ((status_t)OK, mAudioTrack->initCheck());
+
+    mAudioTrack->start();
+}
+
+DirectRenderer::AudioRenderer::~AudioRenderer() {
+}
+
+void DirectRenderer::AudioRenderer::queueInputBuffer(
+        size_t index, int64_t timeUs, const sp<ABuffer> &buffer) {
+    BufferInfo info;
+    info.mIndex = index;
+    info.mTimeUs = timeUs;
+    info.mBuffer = buffer;
+
+    mInputBuffers.push_back(info);
+    schedulePushIfNecessary();
+}
+
+void DirectRenderer::AudioRenderer::onMessageReceived(
+        const sp<AMessage> &msg) {
+    switch (msg->what()) {
+        case kWhatPushAudio:
+        {
+            onPushAudio();
+            break;
+        }
+
+        default:
+            break;
+    }
+}
+
+void DirectRenderer::AudioRenderer::schedulePushIfNecessary() {
+    if (mPushPending || mInputBuffers.empty()) {
+        return;
+    }
+
+    mPushPending = true;
+
+    uint32_t numFramesPlayed;
+    CHECK_EQ(mAudioTrack->getPosition(&numFramesPlayed),
+             (status_t)OK);
+
+    uint32_t numFramesPendingPlayout = mNumFramesWritten - numFramesPlayed;
+
+    // This is how long the audio sink will have data to
+    // play back.
+    const float msecsPerFrame = 1000.0f / mAudioTrack->getSampleRate();
+
+    int64_t delayUs =
+        msecsPerFrame * numFramesPendingPlayout * 1000ll;
+
+    // Let's give it more data after about half that time
+    // has elapsed.
+    (new AMessage(kWhatPushAudio, id()))->post(delayUs / 2);
+}
+
+void DirectRenderer::AudioRenderer::onPushAudio() {
+    mPushPending = false;
+
+    while (!mInputBuffers.empty()) {
+        const BufferInfo &info = *mInputBuffers.begin();
+
+        ssize_t n = writeNonBlocking(
+                info.mBuffer->data(), info.mBuffer->size());
+
+        if (n < (ssize_t)info.mBuffer->size()) {
+            CHECK_GE(n, 0);
+
+            info.mBuffer->setRange(
+                    info.mBuffer->offset() + n, info.mBuffer->size() - n);
+            break;
+        }
+
+        mDecoderContext->releaseOutputBuffer(info.mIndex);
+
+        mInputBuffers.erase(mInputBuffers.begin());
+    }
+
+    schedulePushIfNecessary();
+}
+
+ssize_t DirectRenderer::AudioRenderer::writeNonBlocking(
+        const uint8_t *data, size_t size) {
+    uint32_t numFramesPlayed;
+    status_t err = mAudioTrack->getPosition(&numFramesPlayed);
+    if (err != OK) {
+        return err;
+    }
+
+    ssize_t numFramesAvailableToWrite =
+        mAudioTrack->frameCount() - (mNumFramesWritten - numFramesPlayed);
+
+    size_t numBytesAvailableToWrite =
+        numFramesAvailableToWrite * mAudioTrack->frameSize();
+
+    if (size > numBytesAvailableToWrite) {
+        size = numBytesAvailableToWrite;
+    }
+
+    CHECK_EQ(mAudioTrack->write(data, size), (ssize_t)size);
+
+    size_t numFramesWritten = size / mAudioTrack->frameSize();
+    mNumFramesWritten += numFramesWritten;
+
+    return size;
+}
+
+////////////////////////////////////////////////////////////////////////////////
+
+DirectRenderer::DirectRenderer(
+        const sp<IGraphicBufferProducer> &bufferProducer)
+    : mSurfaceTex(bufferProducer),
+      mVideoRenderPending(false),
+      mNumFramesLate(0),
+      mNumFrames(0) {
+}
+
+DirectRenderer::~DirectRenderer() {
+}
+
+void DirectRenderer::onMessageReceived(const sp<AMessage> &msg) {
+    switch (msg->what()) {
+        case kWhatDecoderNotify:
+        {
+            onDecoderNotify(msg);
+            break;
+        }
+
+        case kWhatRenderVideo:
+        {
+            onRenderVideo();
+            break;
+        }
+
+        case kWhatQueueAccessUnit:
+            onQueueAccessUnit(msg);
+            break;
+
+        case kWhatSetFormat:
+            onSetFormat(msg);
+            break;
+
+        default:
+            TRESPASS();
+    }
+}
+
+void DirectRenderer::setFormat(size_t trackIndex, const sp<AMessage> &format) {
+    sp<AMessage> msg = new AMessage(kWhatSetFormat, id());
+    msg->setSize("trackIndex", trackIndex);
+    msg->setMessage("format", format);
+    msg->post();
+}
+
+void DirectRenderer::onSetFormat(const sp<AMessage> &msg) {
+    size_t trackIndex;
+    CHECK(msg->findSize("trackIndex", &trackIndex));
+
+    sp<AMessage> format;
+    CHECK(msg->findMessage("format", &format));
+
+    internalSetFormat(trackIndex, format);
+}
+
+void DirectRenderer::internalSetFormat(
+        size_t trackIndex, const sp<AMessage> &format) {
+    CHECK_LT(trackIndex, 2u);
+
+    CHECK(mDecoderContext[trackIndex] == NULL);
+
+    sp<AMessage> notify = new AMessage(kWhatDecoderNotify, id());
+    notify->setSize("trackIndex", trackIndex);
+
+    mDecoderContext[trackIndex] = new DecoderContext(notify);
+    looper()->registerHandler(mDecoderContext[trackIndex]);
+
+    CHECK_EQ((status_t)OK,
+             mDecoderContext[trackIndex]->init(
+                 format, trackIndex == 0 ? mSurfaceTex : NULL));
+
+    if (trackIndex == 1) {
+        // Audio
+        mAudioRenderer = new AudioRenderer(mDecoderContext[1]);
+        looper()->registerHandler(mAudioRenderer);
+    }
+}
+
+void DirectRenderer::queueAccessUnit(
+        size_t trackIndex, const sp<ABuffer> &accessUnit) {
+    sp<AMessage> msg = new AMessage(kWhatQueueAccessUnit, id());
+    msg->setSize("trackIndex", trackIndex);
+    msg->setBuffer("accessUnit", accessUnit);
+    msg->post();
+}
+
+void DirectRenderer::onQueueAccessUnit(const sp<AMessage> &msg) {
+    size_t trackIndex;
+    CHECK(msg->findSize("trackIndex", &trackIndex));
+
+    sp<ABuffer> accessUnit;
+    CHECK(msg->findBuffer("accessUnit", &accessUnit));
+
+    CHECK_LT(trackIndex, 2u);
+    CHECK(mDecoderContext[trackIndex] != NULL);
+
+    mDecoderContext[trackIndex]->queueInputBuffer(accessUnit);
+}
+
+void DirectRenderer::onDecoderNotify(const sp<AMessage> &msg) {
+    size_t trackIndex;
+    CHECK(msg->findSize("trackIndex", &trackIndex));
+
+    int32_t what;
+    CHECK(msg->findInt32("what", &what));
+
+    switch (what) {
+        case DecoderContext::kWhatOutputBufferReady:
+        {
+            size_t index;
+            CHECK(msg->findSize("index", &index));
+
+            int64_t timeUs;
+            CHECK(msg->findInt64("timeUs", &timeUs));
+
+            sp<ABuffer> buffer;
+            CHECK(msg->findBuffer("buffer", &buffer));
+
+            queueOutputBuffer(trackIndex, index, timeUs, buffer);
+            break;
+        }
+
+        default:
+            TRESPASS();
+    }
+}
+
+void DirectRenderer::queueOutputBuffer(
+        size_t trackIndex,
+        size_t index, int64_t timeUs, const sp<ABuffer> &buffer) {
+    if (trackIndex == 1) {
+        // Audio
+        mAudioRenderer->queueInputBuffer(index, timeUs, buffer);
+        return;
+    }
+
+    OutputInfo info;
+    info.mIndex = index;
+    info.mTimeUs = timeUs;
+    info.mBuffer = buffer;
+    mVideoOutputBuffers.push_back(info);
+
+    scheduleVideoRenderIfNecessary();
+}
+
+void DirectRenderer::scheduleVideoRenderIfNecessary() {
+    if (mVideoRenderPending || mVideoOutputBuffers.empty()) {
+        return;
+    }
+
+    mVideoRenderPending = true;
+
+    int64_t timeUs = (*mVideoOutputBuffers.begin()).mTimeUs;
+    int64_t nowUs = ALooper::GetNowUs();
+
+    int64_t delayUs = timeUs - nowUs;
+
+    (new AMessage(kWhatRenderVideo, id()))->post(delayUs);
+}
+
+void DirectRenderer::onRenderVideo() {
+    mVideoRenderPending = false;
+
+    int64_t nowUs = ALooper::GetNowUs();
+
+    while (!mVideoOutputBuffers.empty()) {
+        const OutputInfo &info = *mVideoOutputBuffers.begin();
+
+        if (info.mTimeUs > nowUs) {
+            break;
+        }
+
+        if (info.mTimeUs + 15000ll < nowUs) {
+            ++mNumFramesLate;
+        }
+        ++mNumFrames;
+
+        status_t err =
+            mDecoderContext[0]->renderOutputBufferAndRelease(info.mIndex);
+        CHECK_EQ(err, (status_t)OK);
+
+        mVideoOutputBuffers.erase(mVideoOutputBuffers.begin());
+    }
+
+    scheduleVideoRenderIfNecessary();
+}
+
+}  // namespace android
diff -Naur a/frameworks/av/media/libstagefright/wifi-display/sink/DirectRenderer.h b/frameworks/av/media/libstagefright/wifi-display/sink/DirectRenderer.h
--- a/frameworks/av/media/libstagefright/wifi-display/sink/DirectRenderer.h	1969-12-31 19:00:00.000000000 -0500
+++ b/frameworks/av/media/libstagefright/wifi-display/sink/DirectRenderer.h	2014-03-24 13:27:01.108651000 -0400
@@ -0,0 +1,87 @@
+/*
+ * Copyright 2012, The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#ifndef DIRECT_RENDERER_H_
+
+#define DIRECT_RENDERER_H_
+
+#include <media/stagefright/foundation/AHandler.h>
+
+namespace android {
+
+struct ABuffer;
+struct IGraphicBufferProducer;
+
+// Renders audio and video data queued by calls to "queueAccessUnit".
+struct DirectRenderer : public AHandler {
+    DirectRenderer(const sp<IGraphicBufferProducer> &bufferProducer);
+
+    void setFormat(size_t trackIndex, const sp<AMessage> &format);
+    void queueAccessUnit(size_t trackIndex, const sp<ABuffer> &accessUnit);
+
+protected:
+    virtual void onMessageReceived(const sp<AMessage> &msg);
+    virtual ~DirectRenderer();
+
+private:
+    struct DecoderContext;
+    struct AudioRenderer;
+
+    enum {
+        kWhatDecoderNotify,
+        kWhatRenderVideo,
+        kWhatQueueAccessUnit,
+        kWhatSetFormat,
+    };
+
+    struct OutputInfo {
+        size_t mIndex;
+        int64_t mTimeUs;
+        sp<ABuffer> mBuffer;
+    };
+
+    sp<IGraphicBufferProducer> mSurfaceTex;
+
+    sp<DecoderContext> mDecoderContext[2];
+    List<OutputInfo> mVideoOutputBuffers;
+
+    bool mVideoRenderPending;
+
+    sp<AudioRenderer> mAudioRenderer;
+
+    int32_t mNumFramesLate;
+    int32_t mNumFrames;
+
+    void onDecoderNotify(const sp<AMessage> &msg);
+
+    void queueOutputBuffer(
+            size_t trackIndex,
+            size_t index, int64_t timeUs, const sp<ABuffer> &buffer);
+
+    void scheduleVideoRenderIfNecessary();
+    void onRenderVideo();
+
+    void onSetFormat(const sp<AMessage> &msg);
+    void onQueueAccessUnit(const sp<AMessage> &msg);
+
+    void internalSetFormat(size_t trackIndex, const sp<AMessage> &format);
+
+    DISALLOW_EVIL_CONSTRUCTORS(DirectRenderer);
+};
+
+}  // namespace android
+
+#endif  // DIRECT_RENDERER_H_
diff -Naur a/frameworks/av/media/libstagefright/wifi-display/sink/ LinearRegression.cpp b/frameworks/av/media/libstagefright/wifi-display/sink/ LinearRegression.cpp
--- a/frameworks/av/media/libstagefright/wifi-display/sink/ LinearRegression.cpp	1969-12-31 19:00:00.000000000 -0500
+++ b/frameworks/av/media/libstagefright/wifi-display/sink/ LinearRegression.cpp	2014-03-24 14:36:23.522624000 -0400
@@ -0,0 +1,109 @@
+/*
+ * Copyright 2012, The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+//#define LOG_NDEBUG 0
+#define LOG_TAG "LinearRegression"
+#include <utils/Log.h>
+
+#include "LinearRegression.h"
+
+#include <math.h>
+#include <string.h>
+
+namespace android {
+
+LinearRegression::LinearRegression(size_t historySize)
+    : mHistorySize(historySize),
+      mCount(0),
+      mHistory(new Point[mHistorySize]),
+      mSumX(0.0),
+      mSumY(0.0) {
+}
+
+LinearRegression::~LinearRegression() {
+    delete[] mHistory;
+    mHistory = NULL;
+}
+
+void LinearRegression::addPoint(float x, float y) {
+    if (mCount == mHistorySize) {
+        const Point &oldest = mHistory[0];
+
+        mSumX -= oldest.mX;
+        mSumY -= oldest.mY;
+
+        memmove(&mHistory[0], &mHistory[1], (mHistorySize - 1) * sizeof(Point));
+        --mCount;
+    }
+
+    Point *newest = &mHistory[mCount++];
+    newest->mX = x;
+    newest->mY = y;
+
+    mSumX += x;
+    mSumY += y;
+}
+
+bool LinearRegression::approxLine(float *n1, float *n2, float *b) const {
+    static const float kEpsilon = 1.0E-4;
+
+    if (mCount < 2) {
+        return false;
+    }
+
+    float sumX2 = 0.0f;
+    float sumY2 = 0.0f;
+    float sumXY = 0.0f;
+
+    float meanX = mSumX / (float)mCount;
+    float meanY = mSumY / (float)mCount;
+
+    for (size_t i = 0; i < mCount; ++i) {
+        const Point &p = mHistory[i];
+
+        float x = p.mX - meanX;
+        float y = p.mY - meanY;
+
+        sumX2 += x * x;
+        sumY2 += y * y;
+        sumXY += x * y;
+    }
+
+    float T = sumX2 + sumY2;
+    float D = sumX2 * sumY2 - sumXY * sumXY;
+    float root = sqrt(T * T * 0.25 - D);
+
+    float L1 = T * 0.5 - root;
+
+    if (fabs(sumXY) > kEpsilon) {
+        *n1 = 1.0;
+        *n2 = (2.0 * L1 - sumX2) / sumXY;
+
+        float mag = sqrt((*n1) * (*n1) + (*n2) * (*n2));
+
+        *n1 /= mag;
+        *n2 /= mag;
+    } else {
+        *n1 = 0.0;
+        *n2 = 1.0;
+    }
+
+    *b = (*n1) * meanX + (*n2) * meanY;
+
+    return true;
+}
+
+}  // namespace android
diff -Naur a/frameworks/av/media/libstagefright/wifi-display/sink/LinearRegression.h b/frameworks/av/media/libstagefright/wifi-display/sink/LinearRegression.h
--- a/frameworks/av/media/libstagefright/wifi-display/sink/LinearRegression.h	1969-12-31 19:00:00.000000000 -0500
+++ b/frameworks/av/media/libstagefright/wifi-display/sink/LinearRegression.h	2014-03-24 14:36:56.762624000 -0400
@@ -0,0 +1,52 @@
+/*
+ * Copyright 2012, The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#ifndef LINEAR_REGRESSION_H_
+
+#define LINEAR_REGRESSION_H_
+
+#include <sys/types.h>
+#include <media/stagefright/foundation/ABase.h>
+
+namespace android {
+
+// Helper class to fit a line to a set of points minimizing the sum of
+// squared (orthogonal) distances from line to individual points.
+struct LinearRegression {
+    LinearRegression(size_t historySize);
+    ~LinearRegression();
+
+    void addPoint(float x, float y);
+
+    bool approxLine(float *n1, float *n2, float *b) const;
+
+private:
+    struct Point {
+        float mX, mY;
+    };
+
+    size_t mHistorySize;
+    size_t mCount;
+    Point *mHistory;
+
+    float mSumX, mSumY;
+
+    DISALLOW_EVIL_CONSTRUCTORS(LinearRegression);
+};
+
+}  // namespace android
+
+#endif  // LINEAR_REGRESSION_H_
diff -Naur a/frameworks/av/media/libstagefright/wifi-display/sink/RTPSink.cpp b/frameworks/av/media/libstagefright/wifi-display/sink/RTPSink.cpp
--- a/frameworks/av/media/libstagefright/wifi-display/sink/RTPSink.cpp	1969-12-31 19:00:00.000000000 -0500
+++ b/frameworks/av/media/libstagefright/wifi-display/sink/RTPSink.cpp	2014-03-24 14:35:09.166623000 -0400
@@ -0,0 +1,805 @@
+/*
+ * Copyright 2012, The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+//#define LOG_NDEBUG 0
+#define LOG_TAG "RTPSink"
+#include <utils/Log.h>
+
+#include "RTPSink.h"
+
+#include "ANetworkSession.h"
+#include "TunnelRenderer.h"
+
+#include <media/stagefright/foundation/ABuffer.h>
+#include <media/stagefright/foundation/ADebug.h>
+#include <media/stagefright/foundation/AMessage.h>
+#include <media/stagefright/foundation/hexdump.h>
+#include <media/stagefright/MediaErrors.h>
+#include <media/stagefright/Utils.h>
+
+namespace android {
+
+struct RTPSink::Source : public RefBase {
+    Source(uint16_t seq, const sp<ABuffer> &buffer,
+           const sp<AMessage> queueBufferMsg);
+
+    bool updateSeq(uint16_t seq, const sp<ABuffer> &buffer);
+
+    void addReportBlock(uint32_t ssrc, const sp<ABuffer> &buf);
+
+protected:
+    virtual ~Source();
+
+private:
+    static const uint32_t kMinSequential = 2;
+    static const uint32_t kMaxDropout = 3000;
+    static const uint32_t kMaxMisorder = 100;
+    static const uint32_t kRTPSeqMod = 1u << 16;
+
+    sp<AMessage> mQueueBufferMsg;
+
+    uint16_t mMaxSeq;
+    uint32_t mCycles;
+    uint32_t mBaseSeq;
+    uint32_t mBadSeq;
+    uint32_t mProbation;
+    uint32_t mReceived;
+    uint32_t mExpectedPrior;
+    uint32_t mReceivedPrior;
+
+    void initSeq(uint16_t seq);
+    void queuePacket(const sp<ABuffer> &buffer);
+
+    DISALLOW_EVIL_CONSTRUCTORS(Source);
+};
+
+////////////////////////////////////////////////////////////////////////////////
+
+RTPSink::Source::Source(
+        uint16_t seq, const sp<ABuffer> &buffer,
+        const sp<AMessage> queueBufferMsg)
+    : mQueueBufferMsg(queueBufferMsg),
+      mProbation(kMinSequential) {
+    initSeq(seq);
+    mMaxSeq = seq - 1;
+
+    buffer->setInt32Data(mCycles | seq);
+    queuePacket(buffer);
+}
+
+RTPSink::Source::~Source() {
+}
+
+void RTPSink::Source::initSeq(uint16_t seq) {
+    mMaxSeq = seq;
+    mCycles = 0;
+    mBaseSeq = seq;
+    mBadSeq = kRTPSeqMod + 1;
+    mReceived = 0;
+    mExpectedPrior = 0;
+    mReceivedPrior = 0;
+}
+
+bool RTPSink::Source::updateSeq(uint16_t seq, const sp<ABuffer> &buffer) {
+    uint16_t udelta = seq - mMaxSeq;
+
+    if (mProbation) {
+        // Startup phase
+
+        if (seq == mMaxSeq + 1) {
+            buffer->setInt32Data(mCycles | seq);
+            queuePacket(buffer);
+
+            --mProbation;
+            mMaxSeq = seq;
+            if (mProbation == 0) {
+                initSeq(seq);
+                ++mReceived;
+
+                return true;
+            }
+        } else {
+            // Packet out of sequence, restart startup phase
+
+            mProbation = kMinSequential - 1;
+            mMaxSeq = seq;
+
+#if 0
+            mPackets.clear();
+            mTotalBytesQueued = 0;
+            ALOGI("XXX cleared packets");
+#endif
+
+            buffer->setInt32Data(mCycles | seq);
+            queuePacket(buffer);
+        }
+
+        return false;
+    }
+
+    if (udelta < kMaxDropout) {
+        // In order, with permissible gap.
+
+        if (seq < mMaxSeq) {
+            // Sequence number wrapped - count another 64K cycle
+            mCycles += kRTPSeqMod;
+        }
+
+        mMaxSeq = seq;
+    } else if (udelta <= kRTPSeqMod - kMaxMisorder) {
+        // The sequence number made a very large jump
+
+        if (seq == mBadSeq) {
+            // Two sequential packets -- assume that the other side
+            // restarted without telling us so just re-sync
+            // (i.e. pretend this was the first packet)
+
+            initSeq(seq);
+        } else {
+            mBadSeq = (seq + 1) & (kRTPSeqMod - 1);
+
+            return false;
+        }
+    } else {
+        // Duplicate or reordered packet.
+    }
+
+    ++mReceived;
+
+    buffer->setInt32Data(mCycles | seq);
+    queuePacket(buffer);
+
+    return true;
+}
+
+void RTPSink::Source::queuePacket(const sp<ABuffer> &buffer) {
+    sp<AMessage> msg = mQueueBufferMsg->dup();
+    msg->setBuffer("buffer", buffer);
+    msg->post();
+}
+
+void RTPSink::Source::addReportBlock(
+        uint32_t ssrc, const sp<ABuffer> &buf) {
+    uint32_t extMaxSeq = mMaxSeq | mCycles;
+    uint32_t expected = extMaxSeq - mBaseSeq + 1;
+
+    int64_t lost = (int64_t)expected - (int64_t)mReceived;
+    if (lost > 0x7fffff) {
+        lost = 0x7fffff;
+    } else if (lost < -0x800000) {
+        lost = -0x800000;
+    }
+
+    uint32_t expectedInterval = expected - mExpectedPrior;
+    mExpectedPrior = expected;
+
+    uint32_t receivedInterval = mReceived - mReceivedPrior;
+    mReceivedPrior = mReceived;
+
+    int64_t lostInterval = expectedInterval - receivedInterval;
+
+    uint8_t fractionLost;
+    if (expectedInterval == 0 || lostInterval <=0) {
+        fractionLost = 0;
+    } else {
+        fractionLost = (lostInterval << 8) / expectedInterval;
+    }
+
+    uint8_t *ptr = buf->data() + buf->size();
+
+    ptr[0] = ssrc >> 24;
+    ptr[1] = (ssrc >> 16) & 0xff;
+    ptr[2] = (ssrc >> 8) & 0xff;
+    ptr[3] = ssrc & 0xff;
+
+    ptr[4] = fractionLost;
+
+    ptr[5] = (lost >> 16) & 0xff;
+    ptr[6] = (lost >> 8) & 0xff;
+    ptr[7] = lost & 0xff;
+
+    ptr[8] = extMaxSeq >> 24;
+    ptr[9] = (extMaxSeq >> 16) & 0xff;
+    ptr[10] = (extMaxSeq >> 8) & 0xff;
+    ptr[11] = extMaxSeq & 0xff;
+
+    // XXX TODO:
+
+    ptr[12] = 0x00;  // interarrival jitter
+    ptr[13] = 0x00;
+    ptr[14] = 0x00;
+    ptr[15] = 0x00;
+
+    ptr[16] = 0x00;  // last SR
+    ptr[17] = 0x00;
+    ptr[18] = 0x00;
+    ptr[19] = 0x00;
+
+    ptr[20] = 0x00;  // delay since last SR
+    ptr[21] = 0x00;
+    ptr[22] = 0x00;
+    ptr[23] = 0x00;
+}
+
+////////////////////////////////////////////////////////////////////////////////
+
+RTPSink::RTPSink(
+        const sp<ANetworkSession> &netSession,
+        const sp<ISurfaceTexture> &surfaceTex)
+    : mNetSession(netSession),
+      mSurfaceTex(surfaceTex),
+      mRTPPort(0),
+      mRTPSessionID(0),
+      mRTCPSessionID(0),
+      mFirstArrivalTimeUs(-1ll),
+      mNumPacketsReceived(0ll),
+      mRegression(1000),
+      mMaxDelayMs(-1ll) {
+}
+
+RTPSink::~RTPSink() {
+    if (mRTCPSessionID != 0) {
+        mNetSession->destroySession(mRTCPSessionID);
+    }
+
+    if (mRTPSessionID != 0) {
+        mNetSession->destroySession(mRTPSessionID);
+    }
+}
+
+status_t RTPSink::init(bool useTCPInterleaving) {
+    if (useTCPInterleaving) {
+        return OK;
+    }
+
+    int clientRtp;
+
+    sp<AMessage> rtpNotify = new AMessage(kWhatRTPNotify, id());
+    sp<AMessage> rtcpNotify = new AMessage(kWhatRTCPNotify, id());
+    for (clientRtp = 15550;; clientRtp += 2) {
+        int32_t rtpSession;
+        status_t err = mNetSession->createUDPSession(
+                    clientRtp, rtpNotify, &rtpSession);
+
+        if (err != OK) {
+            ALOGI("failed to create RTP socket on port %d", clientRtp);
+            continue;
+        }
+
+        int32_t rtcpSession;
+        err = mNetSession->createUDPSession(
+                clientRtp + 1, rtcpNotify, &rtcpSession);
+
+        if (err == OK) {
+            mRTPPort = clientRtp;
+            mRTPSessionID = rtpSession;
+            mRTCPSessionID = rtcpSession;
+            break;
+        }
+
+        ALOGI("failed to create RTCP socket on port %d", clientRtp + 1);
+        mNetSession->destroySession(rtpSession);
+    }
+
+    if (mRTPPort == 0) {
+        return UNKNOWN_ERROR;
+    }
+
+    return OK;
+}
+
+int32_t RTPSink::getRTPPort() const {
+    return mRTPPort;
+}
+
+void RTPSink::onMessageReceived(const sp<AMessage> &msg) {
+    switch (msg->what()) {
+        case kWhatRTPNotify:
+        case kWhatRTCPNotify:
+        {
+            int32_t reason;
+            CHECK(msg->findInt32("reason", &reason));
+
+            switch (reason) {
+                case ANetworkSession::kWhatError:
+                {
+                    int32_t sessionID;
+                    CHECK(msg->findInt32("sessionID", &sessionID));
+
+                    int32_t err;
+                    CHECK(msg->findInt32("err", &err));
+
+                    AString detail;
+                    CHECK(msg->findString("detail", &detail));
+
+                    ALOGE("An error occurred in session %d (%d, '%s/%s').",
+                          sessionID,
+                          err,
+                          detail.c_str(),
+                          strerror(-err));
+
+                    mNetSession->destroySession(sessionID);
+
+                    if (sessionID == mRTPSessionID) {
+                        mRTPSessionID = 0;
+                    } else if (sessionID == mRTCPSessionID) {
+                        mRTCPSessionID = 0;
+                    }
+                    break;
+                }
+
+                case ANetworkSession::kWhatDatagram:
+                {
+                    int32_t sessionID;
+                    CHECK(msg->findInt32("sessionID", &sessionID));
+
+                    sp<ABuffer> data;
+                    CHECK(msg->findBuffer("data", &data));
+
+                    status_t err;
+                    if (msg->what() == kWhatRTPNotify) {
+                        err = parseRTP(data);
+                    } else {
+                        err = parseRTCP(data);
+                    }
+                    break;
+                }
+
+                default:
+                    TRESPASS();
+            }
+            break;
+        }
+
+        case kWhatSendRR:
+        {
+            onSendRR();
+            break;
+        }
+
+        case kWhatPacketLost:
+        {
+            onPacketLost(msg);
+            break;
+        }
+
+        case kWhatInject:
+        {
+            int32_t isRTP;
+            CHECK(msg->findInt32("isRTP", &isRTP));
+
+            sp<ABuffer> buffer;
+            CHECK(msg->findBuffer("buffer", &buffer));
+
+            status_t err;
+            if (isRTP) {
+                err = parseRTP(buffer);
+            } else {
+                err = parseRTCP(buffer);
+            }
+            break;
+        }
+
+        default:
+            TRESPASS();
+    }
+}
+
+status_t RTPSink::injectPacket(bool isRTP, const sp<ABuffer> &buffer) {
+    sp<AMessage> msg = new AMessage(kWhatInject, id());
+    msg->setInt32("isRTP", isRTP);
+    msg->setBuffer("buffer", buffer);
+    msg->post();
+
+    return OK;
+}
+
+status_t RTPSink::parseRTP(const sp<ABuffer> &buffer) {
+    size_t size = buffer->size();
+    if (size < 12) {
+        // Too short to be a valid RTP header.
+        return ERROR_MALFORMED;
+    }
+
+    const uint8_t *data = buffer->data();
+
+    if ((data[0] >> 6) != 2) {
+        // Unsupported version.
+        return ERROR_UNSUPPORTED;
+    }
+
+    if (data[0] & 0x20) {
+        // Padding present.
+
+        size_t paddingLength = data[size - 1];
+
+        if (paddingLength + 12 > size) {
+            // If we removed this much padding we'd end up with something
+            // that's too short to be a valid RTP header.
+            return ERROR_MALFORMED;
+        }
+
+        size -= paddingLength;
+    }
+
+    int numCSRCs = data[0] & 0x0f;
+
+    size_t payloadOffset = 12 + 4 * numCSRCs;
+
+    if (size < payloadOffset) {
+        // Not enough data to fit the basic header and all the CSRC entries.
+        return ERROR_MALFORMED;
+    }
+
+    if (data[0] & 0x10) {
+        // Header eXtension present.
+
+        if (size < payloadOffset + 4) {
+            // Not enough data to fit the basic header, all CSRC entries
+            // and the first 4 bytes of the extension header.
+
+            return ERROR_MALFORMED;
+        }
+
+        const uint8_t *extensionData = &data[payloadOffset];
+
+        size_t extensionLength =
+            4 * (extensionData[2] << 8 | extensionData[3]);
+
+        if (size < payloadOffset + 4 + extensionLength) {
+            return ERROR_MALFORMED;
+        }
+
+        payloadOffset += 4 + extensionLength;
+    }
+
+    uint32_t srcId = U32_AT(&data[8]);
+    uint32_t rtpTime = U32_AT(&data[4]);
+    uint16_t seqNo = U16_AT(&data[2]);
+
+    int64_t arrivalTimeUs;
+    CHECK(buffer->meta()->findInt64("arrivalTimeUs", &arrivalTimeUs));
+
+    if (mFirstArrivalTimeUs < 0ll) {
+        mFirstArrivalTimeUs = arrivalTimeUs;
+    }
+    arrivalTimeUs -= mFirstArrivalTimeUs;
+
+    int64_t arrivalTimeMedia = (arrivalTimeUs * 9ll) / 100ll;
+
+    ALOGV("seqNo: %d, SSRC 0x%08x, diff %lld",
+            seqNo, srcId, rtpTime - arrivalTimeMedia);
+
+    mRegression.addPoint((float)rtpTime, (float)arrivalTimeMedia);
+
+    ++mNumPacketsReceived;
+
+    float n1, n2, b;
+    if (mRegression.approxLine(&n1, &n2, &b)) {
+        ALOGV("Line %lld: %.2f %.2f %.2f, slope %.2f",
+              mNumPacketsReceived, n1, n2, b, -n1 / n2);
+
+        float expectedArrivalTimeMedia = (b - n1 * (float)rtpTime) / n2;
+        float latenessMs = (arrivalTimeMedia - expectedArrivalTimeMedia) / 90.0;
+
+        if (mMaxDelayMs < 0ll || latenessMs > mMaxDelayMs) {
+            mMaxDelayMs = latenessMs;
+            ALOGI("packet was %.2f ms late", latenessMs);
+        }
+    }
+
+    sp<AMessage> meta = buffer->meta();
+    meta->setInt32("ssrc", srcId);
+    meta->setInt32("rtp-time", rtpTime);
+    meta->setInt32("PT", data[1] & 0x7f);
+    meta->setInt32("M", data[1] >> 7);
+
+    buffer->setRange(payloadOffset, size - payloadOffset);
+
+    ssize_t index = mSources.indexOfKey(srcId);
+    if (index < 0) {
+        if (mRenderer == NULL) {
+            sp<AMessage> notifyLost = new AMessage(kWhatPacketLost, id());
+            notifyLost->setInt32("ssrc", srcId);
+
+            mRenderer = new TunnelRenderer(notifyLost, mSurfaceTex);
+            looper()->registerHandler(mRenderer);
+        }
+
+        sp<AMessage> queueBufferMsg =
+            new AMessage(TunnelRenderer::kWhatQueueBuffer, mRenderer->id());
+
+        sp<Source> source = new Source(seqNo, buffer, queueBufferMsg);
+        mSources.add(srcId, source);
+    } else {
+        mSources.valueAt(index)->updateSeq(seqNo, buffer);
+    }
+
+    return OK;
+}
+
+status_t RTPSink::parseRTCP(const sp<ABuffer> &buffer) {
+    const uint8_t *data = buffer->data();
+    size_t size = buffer->size();
+
+    while (size > 0) {
+        if (size < 8) {
+            // Too short to be a valid RTCP header
+            return ERROR_MALFORMED;
+        }
+
+        if ((data[0] >> 6) != 2) {
+            // Unsupported version.
+            return ERROR_UNSUPPORTED;
+        }
+
+        if (data[0] & 0x20) {
+            // Padding present.
+
+            size_t paddingLength = data[size - 1];
+
+            if (paddingLength + 12 > size) {
+                // If we removed this much padding we'd end up with something
+                // that's too short to be a valid RTP header.
+                return ERROR_MALFORMED;
+            }
+
+            size -= paddingLength;
+        }
+
+        size_t headerLength = 4 * (data[2] << 8 | data[3]) + 4;
+
+        if (size < headerLength) {
+            // Only received a partial packet?
+            return ERROR_MALFORMED;
+        }
+
+        switch (data[1]) {
+            case 200:
+            {
+                parseSR(data, headerLength);
+                break;
+            }
+
+            case 201:  // RR
+            case 202:  // SDES
+            case 204:  // APP
+                break;
+
+            case 205:  // TSFB (transport layer specific feedback)
+            case 206:  // PSFB (payload specific feedback)
+                // hexdump(data, headerLength);
+                break;
+
+            case 203:
+            {
+                parseBYE(data, headerLength);
+                break;
+            }
+
+            default:
+            {
+                ALOGW("Unknown RTCP packet type %u of size %d",
+                     (unsigned)data[1], headerLength);
+                break;
+            }
+        }
+
+        data += headerLength;
+        size -= headerLength;
+    }
+
+    return OK;
+}
+
+status_t RTPSink::parseBYE(const uint8_t *data, size_t size) {
+    size_t SC = data[0] & 0x3f;
+
+    if (SC == 0 || size < (4 + SC * 4)) {
+        // Packet too short for the minimal BYE header.
+        return ERROR_MALFORMED;
+    }
+
+    uint32_t id = U32_AT(&data[4]);
+
+    return OK;
+}
+
+status_t RTPSink::parseSR(const uint8_t *data, size_t size) {
+    size_t RC = data[0] & 0x1f;
+
+    if (size < (7 + RC * 6) * 4) {
+        // Packet too short for the minimal SR header.
+        return ERROR_MALFORMED;
+    }
+
+    uint32_t id = U32_AT(&data[4]);
+    uint64_t ntpTime = U64_AT(&data[8]);
+    uint32_t rtpTime = U32_AT(&data[16]);
+
+    ALOGV("SR: ssrc 0x%08x, ntpTime 0x%016llx, rtpTime 0x%08x",
+          id, ntpTime, rtpTime);
+
+    return OK;
+}
+
+status_t RTPSink::connect(
+        const char *host, int32_t remoteRtpPort, int32_t remoteRtcpPort) {
+    ALOGI("connecting RTP/RTCP sockets to %s:{%d,%d}",
+          host, remoteRtpPort, remoteRtcpPort);
+
+    status_t err =
+        mNetSession->connectUDPSession(mRTPSessionID, host, remoteRtpPort);
+
+    if (err != OK) {
+        return err;
+    }
+
+    err = mNetSession->connectUDPSession(mRTCPSessionID, host, remoteRtcpPort);
+
+    if (err != OK) {
+        return err;
+    }
+
+#if 0
+    sp<ABuffer> buf = new ABuffer(1500);
+    memset(buf->data(), 0, buf->size());
+
+    mNetSession->sendRequest(
+            mRTPSessionID, buf->data(), buf->size());
+
+    mNetSession->sendRequest(
+            mRTCPSessionID, buf->data(), buf->size());
+#endif
+
+    scheduleSendRR();
+
+    return OK;
+}
+
+void RTPSink::scheduleSendRR() {
+    (new AMessage(kWhatSendRR, id()))->post(2000000ll);
+}
+
+void RTPSink::addSDES(const sp<ABuffer> &buffer) {
+    uint8_t *data = buffer->data() + buffer->size();
+    data[0] = 0x80 | 1;
+    data[1] = 202;  // SDES
+    data[4] = 0xde;  // SSRC
+    data[5] = 0xad;
+    data[6] = 0xbe;
+    data[7] = 0xef;
+
+    size_t offset = 8;
+
+    data[offset++] = 1;  // CNAME
+
+    AString cname = "stagefright@somewhere";
+    data[offset++] = cname.size();
+
+    memcpy(&data[offset], cname.c_str(), cname.size());
+    offset += cname.size();
+
+    data[offset++] = 6;  // TOOL
+
+    AString tool = "stagefright/1.0";
+    data[offset++] = tool.size();
+
+    memcpy(&data[offset], tool.c_str(), tool.size());
+    offset += tool.size();
+
+    data[offset++] = 0;
+
+    if ((offset % 4) > 0) {
+        size_t count = 4 - (offset % 4);
+        switch (count) {
+            case 3:
+                data[offset++] = 0;
+            case 2:
+                data[offset++] = 0;
+            case 1:
+                data[offset++] = 0;
+        }
+    }
+
+    size_t numWords = (offset / 4) - 1;
+    data[2] = numWords >> 8;
+    data[3] = numWords & 0xff;
+
+    buffer->setRange(buffer->offset(), buffer->size() + offset);
+}
+
+void RTPSink::onSendRR() {
+    sp<ABuffer> buf = new ABuffer(1500);
+    buf->setRange(0, 0);
+
+    uint8_t *ptr = buf->data();
+    ptr[0] = 0x80 | 0;
+    ptr[1] = 201;  // RR
+    ptr[2] = 0;
+    ptr[3] = 1;
+    ptr[4] = 0xde;  // SSRC
+    ptr[5] = 0xad;
+    ptr[6] = 0xbe;
+    ptr[7] = 0xef;
+
+    buf->setRange(0, 8);
+
+    size_t numReportBlocks = 0;
+    for (size_t i = 0; i < mSources.size(); ++i) {
+        uint32_t ssrc = mSources.keyAt(i);
+        sp<Source> source = mSources.valueAt(i);
+
+        if (numReportBlocks > 31 || buf->size() + 24 > buf->capacity()) {
+            // Cannot fit another report block.
+            break;
+        }
+
+        source->addReportBlock(ssrc, buf);
+        ++numReportBlocks;
+    }
+
+    ptr[0] |= numReportBlocks;  // 5 bit
+
+    size_t sizeInWordsMinus1 = 1 + 6 * numReportBlocks;
+    ptr[2] = sizeInWordsMinus1 >> 8;
+    ptr[3] = sizeInWordsMinus1 & 0xff;
+
+    buf->setRange(0, (sizeInWordsMinus1 + 1) * 4);
+
+    addSDES(buf);
+
+    mNetSession->sendRequest(mRTCPSessionID, buf->data(), buf->size());
+
+    scheduleSendRR();
+}
+
+void RTPSink::onPacketLost(const sp<AMessage> &msg) {
+    uint32_t srcId;
+    CHECK(msg->findInt32("ssrc", (int32_t *)&srcId));
+
+    int32_t seqNo;
+    CHECK(msg->findInt32("seqNo", &seqNo));
+
+    int32_t blp = 0;
+
+    sp<ABuffer> buf = new ABuffer(1500);
+    buf->setRange(0, 0);
+
+    uint8_t *ptr = buf->data();
+    ptr[0] = 0x80 | 1;  // generic NACK
+    ptr[1] = 205;  // RTPFB
+    ptr[2] = 0;
+    ptr[3] = 3;
+    ptr[4] = 0xde;  // sender SSRC
+    ptr[5] = 0xad;
+    ptr[6] = 0xbe;
+    ptr[7] = 0xef;
+    ptr[8] = (srcId >> 24) & 0xff;
+    ptr[9] = (srcId >> 16) & 0xff;
+    ptr[10] = (srcId >> 8) & 0xff;
+    ptr[11] = (srcId & 0xff);
+    ptr[12] = (seqNo >> 8) & 0xff;
+    ptr[13] = (seqNo & 0xff);
+    ptr[14] = (blp >> 8) & 0xff;
+    ptr[15] = (blp & 0xff);
+
+    buf->setRange(0, 16);
+
+    mNetSession->sendRequest(mRTCPSessionID, buf->data(), buf->size());
+}
+
+}  // namespace android
diff -Naur a/frameworks/av/media/libstagefright/wifi-display/sink/RTPSink.h b/frameworks/av/media/libstagefright/wifi-display/sink/RTPSink.h
--- a/frameworks/av/media/libstagefright/wifi-display/sink/RTPSink.h	1969-12-31 19:00:00.000000000 -0500
+++ b/frameworks/av/media/libstagefright/wifi-display/sink/RTPSink.h	2014-03-24 14:35:45.378624000 -0400
@@ -0,0 +1,98 @@
+/*
+ * Copyright 2012, The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#ifndef RTP_SINK_H_
+
+#define RTP_SINK_H_
+
+#include <media/stagefright/foundation/AHandler.h>
+
+#include "LinearRegression.h"
+
+#include <gui/Surface.h>
+
+namespace android {
+
+struct ABuffer;
+struct ANetworkSession;
+struct TunnelRenderer;
+
+// Creates a pair of sockets for RTP/RTCP traffic, instantiates a renderer
+// for incoming transport stream data and occasionally sends statistics over
+// the RTCP channel.
+struct RTPSink : public AHandler {
+    RTPSink(const sp<ANetworkSession> &netSession,
+            const sp<ISurfaceTexture> &surfaceTex);
+
+    // If TCP interleaving is used, no UDP sockets are created, instead
+    // incoming RTP/RTCP packets (arriving on the RTSP control connection)
+    // are manually injected by WifiDisplaySink.
+    status_t init(bool useTCPInterleaving);
+
+    status_t connect(
+            const char *host, int32_t remoteRtpPort, int32_t remoteRtcpPort);
+
+    int32_t getRTPPort() const;
+
+    status_t injectPacket(bool isRTP, const sp<ABuffer> &buffer);
+
+protected:
+    virtual void onMessageReceived(const sp<AMessage> &msg);
+    virtual ~RTPSink();
+
+private:
+    enum {
+        kWhatRTPNotify,
+        kWhatRTCPNotify,
+        kWhatSendRR,
+        kWhatPacketLost,
+        kWhatInject,
+    };
+
+    struct Source;
+    struct StreamSource;
+
+    sp<ANetworkSession> mNetSession;
+    sp<ISurfaceTexture> mSurfaceTex;
+    KeyedVector<uint32_t, sp<Source> > mSources;
+
+    int32_t mRTPPort;
+    int32_t mRTPSessionID;
+    int32_t mRTCPSessionID;
+
+    int64_t mFirstArrivalTimeUs;
+    int64_t mNumPacketsReceived;
+    LinearRegression mRegression;
+    int64_t mMaxDelayMs;
+
+    sp<TunnelRenderer> mRenderer;
+
+    status_t parseRTP(const sp<ABuffer> &buffer);
+    status_t parseRTCP(const sp<ABuffer> &buffer);
+    status_t parseBYE(const uint8_t *data, size_t size);
+    status_t parseSR(const uint8_t *data, size_t size);
+
+    void addSDES(const sp<ABuffer> &buffer);
+    void onSendRR();
+    void onPacketLost(const sp<AMessage> &msg);
+    void scheduleSendRR();
+
+    DISALLOW_EVIL_CONSTRUCTORS(RTPSink);
+};
+
+}  // namespace android
+
+#endif  // RTP_SINK_H_
diff -Naur a/frameworks/av/media/libstagefright/wifi-display/sink/TunnelRenderer.cpp b/frameworks/av/media/libstagefright/wifi-display/sink/TunnelRenderer.cpp
--- a/frameworks/av/media/libstagefright/wifi-display/sink/TunnelRenderer.cpp	1969-12-31 19:00:00.000000000 -0500
+++ b/frameworks/av/media/libstagefright/wifi-display/sink/TunnelRenderer.cpp	2014-03-24 13:27:01.108651000 -0400
@@ -0,0 +1,407 @@
+/*
+ * Copyright 2012, The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+//#define LOG_NDEBUG 0
+#define LOG_TAG "TunnelRenderer"
+#include <utils/Log.h>
+
+#include "TunnelRenderer.h"
+
+#include "ATSParser.h"
+
+#include <binder/IMemory.h>
+#include <binder/IServiceManager.h>
+#include <gui/SurfaceComposerClient.h>
+#include <media/IMediaPlayerService.h>
+#include <media/IStreamSource.h>
+#include <media/stagefright/foundation/ABuffer.h>
+#include <media/stagefright/foundation/ADebug.h>
+#include <media/stagefright/foundation/AMessage.h>
+#include <ui/DisplayInfo.h>
+
+#include <gui/ISurfaceComposer.h>
+
+
+namespace android {
+
+struct TunnelRenderer::PlayerClient : public BnMediaPlayerClient {
+    PlayerClient() {}
+
+    virtual void notify(int msg, int ext1, int ext2, const Parcel *obj) {
+        ALOGI("notify %d, %d, %d", msg, ext1, ext2);
+    }
+
+protected:
+    virtual ~PlayerClient() {}
+
+private:
+    DISALLOW_EVIL_CONSTRUCTORS(PlayerClient);
+};
+
+struct TunnelRenderer::StreamSource : public BnStreamSource {
+    StreamSource(TunnelRenderer *owner);
+
+    virtual void setListener(const sp<IStreamListener> &listener);
+    virtual void setBuffers(const Vector<sp<IMemory> > &buffers);
+
+    virtual void onBufferAvailable(size_t index);
+
+    virtual uint32_t flags() const;
+
+    void doSomeWork();
+
+protected:
+    virtual ~StreamSource();
+
+private:
+    mutable Mutex mLock;
+
+    TunnelRenderer *mOwner;
+
+    sp<IStreamListener> mListener;
+
+    Vector<sp<IMemory> > mBuffers;
+    List<size_t> mIndicesAvailable;
+
+    size_t mNumDeqeued;
+
+    DISALLOW_EVIL_CONSTRUCTORS(StreamSource);
+};
+
+////////////////////////////////////////////////////////////////////////////////
+
+TunnelRenderer::StreamSource::StreamSource(TunnelRenderer *owner)
+    : mOwner(owner),
+      mNumDeqeued(0) {
+}
+
+TunnelRenderer::StreamSource::~StreamSource() {
+}
+
+void TunnelRenderer::StreamSource::setListener(
+        const sp<IStreamListener> &listener) {
+    mListener = listener;
+}
+
+void TunnelRenderer::StreamSource::setBuffers(
+        const Vector<sp<IMemory> > &buffers) {
+    mBuffers = buffers;
+}
+
+void TunnelRenderer::StreamSource::onBufferAvailable(size_t index) {
+    CHECK_LT(index, mBuffers.size());
+
+    {
+        Mutex::Autolock autoLock(mLock);
+        mIndicesAvailable.push_back(index);
+    }
+
+    doSomeWork();
+}
+
+uint32_t TunnelRenderer::StreamSource::flags() const {
+    return kFlagAlignedVideoData;
+}
+
+void TunnelRenderer::StreamSource::doSomeWork() {
+    Mutex::Autolock autoLock(mLock);
+
+    while (!mIndicesAvailable.empty()) {
+        sp<ABuffer> srcBuffer = mOwner->dequeueBuffer();
+        if (srcBuffer == NULL) {
+            break;
+        }
+
+        ++mNumDeqeued;
+
+        if (mNumDeqeued == 1) {
+            ALOGI("fixing real time now.");
+
+            sp<AMessage> extra = new AMessage;
+
+            extra->setInt32(
+                    IStreamListener::kKeyDiscontinuityMask,
+                    ATSParser::DISCONTINUITY_ABSOLUTE_TIME);
+
+            extra->setInt64("timeUs", ALooper::GetNowUs());
+
+            mListener->issueCommand(
+                    IStreamListener::DISCONTINUITY,
+                    false /* synchronous */,
+                    extra);
+        }
+
+        ALOGV("dequeue TS packet of size %d", srcBuffer->size());
+
+        size_t index = *mIndicesAvailable.begin();
+        mIndicesAvailable.erase(mIndicesAvailable.begin());
+
+        sp<IMemory> mem = mBuffers.itemAt(index);
+        CHECK_LE(srcBuffer->size(), mem->size());
+        CHECK_EQ((srcBuffer->size() % 188), 0u);
+
+        memcpy(mem->pointer(), srcBuffer->data(), srcBuffer->size());
+        mListener->queueBuffer(index, srcBuffer->size());
+    }
+}
+
+////////////////////////////////////////////////////////////////////////////////
+
+TunnelRenderer::TunnelRenderer(
+        const sp<AMessage> &notifyLost,
+        const sp<ISurfaceTexture> &surfaceTex)
+    : mNotifyLost(notifyLost),
+      mSurfaceTex(surfaceTex),
+      mTotalBytesQueued(0ll),
+      mLastDequeuedExtSeqNo(-1),
+      mFirstFailedAttemptUs(-1ll),
+      mRequestedRetransmission(false) {
+}
+
+TunnelRenderer::~TunnelRenderer() {
+    destroyPlayer();
+}
+
+void TunnelRenderer::queueBuffer(const sp<ABuffer> &buffer) {
+    Mutex::Autolock autoLock(mLock);
+
+    mTotalBytesQueued += buffer->size();
+
+    if (mPackets.empty()) {
+        mPackets.push_back(buffer);
+        return;
+    }
+
+    int32_t newExtendedSeqNo = buffer->int32Data();
+
+    List<sp<ABuffer> >::iterator firstIt = mPackets.begin();
+    List<sp<ABuffer> >::iterator it = --mPackets.end();
+    for (;;) {
+        int32_t extendedSeqNo = (*it)->int32Data();
+
+        if (extendedSeqNo == newExtendedSeqNo) {
+            // Duplicate packet.
+            return;
+        }
+
+        if (extendedSeqNo < newExtendedSeqNo) {
+            // Insert new packet after the one at "it".
+            mPackets.insert(++it, buffer);
+            return;
+        }
+
+        if (it == firstIt) {
+            // Insert new packet before the first existing one.
+            mPackets.insert(it, buffer);
+            return;
+        }
+
+        --it;
+    }
+}
+
+sp<ABuffer> TunnelRenderer::dequeueBuffer() {
+    Mutex::Autolock autoLock(mLock);
+
+    sp<ABuffer> buffer;
+    int32_t extSeqNo;
+    while (!mPackets.empty()) {
+        buffer = *mPackets.begin();
+        extSeqNo = buffer->int32Data();
+
+        if (mLastDequeuedExtSeqNo < 0 || extSeqNo > mLastDequeuedExtSeqNo) {
+            break;
+        }
+
+        // This is a retransmission of a packet we've already returned.
+
+        mTotalBytesQueued -= buffer->size();
+        buffer.clear();
+        extSeqNo = -1;
+
+        mPackets.erase(mPackets.begin());
+    }
+
+    if (mPackets.empty()) {
+        if (mFirstFailedAttemptUs < 0ll) {
+            mFirstFailedAttemptUs = ALooper::GetNowUs();
+            mRequestedRetransmission = false;
+        } else {
+            ALOGV("no packets available for %.2f secs",
+                    (ALooper::GetNowUs() - mFirstFailedAttemptUs) / 1E6);
+        }
+
+        return NULL;
+    }
+
+    if (mLastDequeuedExtSeqNo < 0 || extSeqNo == mLastDequeuedExtSeqNo + 1) {
+        if (mRequestedRetransmission) {
+            ALOGI("Recovered after requesting retransmission of %d",
+                  extSeqNo);
+        }
+
+        mLastDequeuedExtSeqNo = extSeqNo;
+        mFirstFailedAttemptUs = -1ll;
+        mRequestedRetransmission = false;
+
+        mPackets.erase(mPackets.begin());
+
+        mTotalBytesQueued -= buffer->size();
+
+        return buffer;
+    }
+
+    if (mFirstFailedAttemptUs < 0ll) {
+        mFirstFailedAttemptUs = ALooper::GetNowUs();
+
+        ALOGI("failed to get the correct packet the first time.");
+        return NULL;
+    }
+
+    if (mFirstFailedAttemptUs + 50000ll > ALooper::GetNowUs()) {
+        // We're willing to wait a little while to get the right packet.
+
+        if (!mRequestedRetransmission) {
+            ALOGI("requesting retransmission of seqNo %d",
+                  (mLastDequeuedExtSeqNo + 1) & 0xffff);
+
+            sp<AMessage> notify = mNotifyLost->dup();
+            notify->setInt32("seqNo", (mLastDequeuedExtSeqNo + 1) & 0xffff);
+            notify->post();
+
+            mRequestedRetransmission = true;
+        } else {
+            ALOGI("still waiting for the correct packet to arrive.");
+        }
+
+        return NULL;
+    }
+
+    ALOGI("dropping packet. extSeqNo %d didn't arrive in time",
+            mLastDequeuedExtSeqNo + 1);
+
+    // Permanent failure, we never received the packet.
+    mLastDequeuedExtSeqNo = extSeqNo;
+    mFirstFailedAttemptUs = -1ll;
+    mRequestedRetransmission = false;
+
+    mTotalBytesQueued -= buffer->size();
+
+    mPackets.erase(mPackets.begin());
+
+    return buffer;
+}
+
+void TunnelRenderer::onMessageReceived(const sp<AMessage> &msg) {
+    switch (msg->what()) {
+        case kWhatQueueBuffer:
+        {
+            sp<ABuffer> buffer;
+            CHECK(msg->findBuffer("buffer", &buffer));
+
+            queueBuffer(buffer);
+
+            if (mStreamSource == NULL) {
+                if (mTotalBytesQueued > 0ll) {
+                    initPlayer();
+                } else {
+                    ALOGI("Have %lld bytes queued...", mTotalBytesQueued);
+                }
+            } else {
+                mStreamSource->doSomeWork();
+            }
+            break;
+        }
+
+        default:
+            TRESPASS();
+    }
+}
+
+void TunnelRenderer::initPlayer() {
+    if (mSurfaceTex == NULL) {
+        mComposerClient = new SurfaceComposerClient;
+        CHECK_EQ(mComposerClient->initCheck(), (status_t)OK);
+
+        DisplayInfo info;
+        SurfaceComposerClient::getDisplayInfo(0, &info);
+        ssize_t displayWidth = info.w;
+        ssize_t displayHeight = info.h;
+        ALOGD("initPlayer() defailt size[%d, %d]", info.w, info.h);
+
+        sp<IBinder> display = SurfaceComposerClient::getBuiltInDisplay(ISurfaceComposer::eDisplayIdMain);
+        SurfaceComposerClient::getDisplayInfo(display, &info);
+        displayWidth = info.w;
+        displayHeight = info.h;
+        ALOGD("initPlayer() fixed size[%d, %d]", info.w, info.h);
+
+        mSurfaceControl =
+            mComposerClient->createSurface(
+//                    String8("A Surface"),
+                    String8("A Sink Surface"),
+                    displayWidth,
+                    displayHeight,
+                    PIXEL_FORMAT_RGB_565,
+                    0);
+
+        CHECK(mSurfaceControl != NULL);
+        CHECK(mSurfaceControl->isValid());
+
+        SurfaceComposerClient::openGlobalTransaction();
+        CHECK_EQ(mSurfaceControl->setLayer(INT_MAX), (status_t)OK);
+        CHECK_EQ(mSurfaceControl->show(), (status_t)OK);
+        SurfaceComposerClient::closeGlobalTransaction();
+
+        mSurface = mSurfaceControl->getSurface();
+        CHECK(mSurface != NULL);
+    }
+
+    sp<IServiceManager> sm = defaultServiceManager();
+    sp<IBinder> binder = sm->getService(String16("media.player"));
+    sp<IMediaPlayerService> service = interface_cast<IMediaPlayerService>(binder);
+    CHECK(service.get() != NULL);
+
+    mStreamSource = new StreamSource(this);
+
+    mPlayerClient = new PlayerClient;
+
+    mPlayer = service->create(getpid(), mPlayerClient, 0);
+    CHECK(mPlayer != NULL);
+    CHECK_EQ(mPlayer->setDataSource(mStreamSource), (status_t)OK);
+
+    mPlayer->setVideoSurfaceTexture(
+            mSurfaceTex != NULL ? mSurfaceTex : mSurface->getSurfaceTexture());
+
+    mPlayer->start();
+}
+
+void TunnelRenderer::destroyPlayer() {
+    mStreamSource.clear();
+
+    mPlayer->stop();
+    mPlayer.clear();
+
+    if (mSurfaceTex == NULL) {
+        mSurface.clear();
+        mSurfaceControl.clear();
+
+        mComposerClient->dispose();
+        mComposerClient.clear();
+    }
+}
+
+}  // namespace android
+
diff -Naur a/frameworks/av/media/libstagefright/wifi-display/sink/WifiDisplaySink.cpp b/frameworks/av/media/libstagefright/wifi-display/sink/WifiDisplaySink.cpp
--- a/frameworks/av/media/libstagefright/wifi-display/sink/WifiDisplaySink.cpp	1969-12-31 19:00:00.000000000 -0500
+++ b/frameworks/av/media/libstagefright/wifi-display/sink/WifiDisplaySink.cpp	2014-03-24 13:27:01.108651000 -0400
@@ -0,0 +1,658 @@
+/*
+ * Copyright 2012, The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+//#define LOG_NDEBUG 0
+#define LOG_TAG "WifiDisplaySink"
+#include <utils/Log.h>
+
+#include "WifiDisplaySink.h"
+#include "ParsedMessage.h"
+#include "RTPSink.h"
+
+#include <media/stagefright/foundation/ABuffer.h>
+#include <media/stagefright/foundation/ADebug.h>
+#include <media/stagefright/foundation/AMessage.h>
+#include <media/stagefright/MediaErrors.h>
+
+namespace android {
+
+WifiDisplaySink::WifiDisplaySink(
+        const sp<ANetworkSession> &netSession,
+        const sp<ISurfaceTexture> &surfaceTex)
+    : mState(UNDEFINED),
+      mNetSession(netSession),
+      mSurfaceTex(surfaceTex),
+      mSessionID(0),
+      mNextCSeq(1) {
+}
+
+WifiDisplaySink::~WifiDisplaySink() {
+}
+
+void WifiDisplaySink::start(const char *sourceHost, int32_t sourcePort) {
+    sp<AMessage> msg = new AMessage(kWhatStart, id());
+    msg->setString("sourceHost", sourceHost);
+    msg->setInt32("sourcePort", sourcePort);
+    msg->post();
+}
+
+void WifiDisplaySink::start(const char *uri) {
+    sp<AMessage> msg = new AMessage(kWhatStart, id());
+    msg->setString("setupURI", uri);
+    msg->post();
+}
+
+// static
+bool WifiDisplaySink::ParseURL(
+        const char *url, AString *host, int32_t *port, AString *path,
+        AString *user, AString *pass) {
+    host->clear();
+    *port = 0;
+    path->clear();
+    user->clear();
+    pass->clear();
+
+    if (strncasecmp("rtsp://", url, 7)) {
+        return false;
+    }
+
+    const char *slashPos = strchr(&url[7], '/');
+
+    if (slashPos == NULL) {
+        host->setTo(&url[7]);
+        path->setTo("/");
+    } else {
+        host->setTo(&url[7], slashPos - &url[7]);
+        path->setTo(slashPos);
+    }
+
+    ssize_t atPos = host->find("@");
+
+    if (atPos >= 0) {
+        // Split of user:pass@ from hostname.
+
+        AString userPass(*host, 0, atPos);
+        host->erase(0, atPos + 1);
+
+        ssize_t colonPos = userPass.find(":");
+
+        if (colonPos < 0) {
+            *user = userPass;
+        } else {
+            user->setTo(userPass, 0, colonPos);
+            pass->setTo(userPass, colonPos + 1, userPass.size() - colonPos - 1);
+        }
+    }
+
+    const char *colonPos = strchr(host->c_str(), ':');
+
+    if (colonPos != NULL) {
+        char *end;
+        unsigned long x = strtoul(colonPos + 1, &end, 10);
+
+        if (end == colonPos + 1 || *end != '\0' || x >= 65536) {
+            return false;
+        }
+
+        *port = x;
+
+        size_t colonOffset = colonPos - host->c_str();
+        size_t trailing = host->size() - colonOffset;
+        host->erase(colonOffset, trailing);
+    } else {
+        *port = 554;
+    }
+
+    return true;
+}
+
+void WifiDisplaySink::onMessageReceived(const sp<AMessage> &msg) {
+    switch (msg->what()) {
+        case kWhatStart:
+        {
+            int32_t sourcePort;
+
+            if (msg->findString("setupURI", &mSetupURI)) {
+                AString path, user, pass;
+                CHECK(ParseURL(
+                            mSetupURI.c_str(),
+                            &mRTSPHost, &sourcePort, &path, &user, &pass)
+                        && user.empty() && pass.empty());
+            } else {
+                CHECK(msg->findString("sourceHost", &mRTSPHost));
+                CHECK(msg->findInt32("sourcePort", &sourcePort));
+            }
+
+            sp<AMessage> notify = new AMessage(kWhatRTSPNotify, id());
+
+            status_t err = mNetSession->createRTSPClient(
+                    mRTSPHost.c_str(), sourcePort, notify, &mSessionID);
+            CHECK_EQ(err, (status_t)OK);
+
+            mState = CONNECTING;
+            break;
+        }
+
+        case kWhatRTSPNotify:
+        {
+            int32_t reason;
+            CHECK(msg->findInt32("reason", &reason));
+
+            switch (reason) {
+                case ANetworkSession::kWhatError:
+                {
+                    int32_t sessionID;
+                    CHECK(msg->findInt32("sessionID", &sessionID));
+
+                    int32_t err;
+                    CHECK(msg->findInt32("err", &err));
+
+                    AString detail;
+                    CHECK(msg->findString("detail", &detail));
+
+                    ALOGE("An error occurred in session %d (%d, '%s/%s').",
+                          sessionID,
+                          err,
+                          detail.c_str(),
+                          strerror(-err));
+
+                    ALOGE("An error occurred in session %d-%d (%d, '%s/%s').",
+                          sessionID,
+                          mSessionID,
+                          err,
+                          detail.c_str(),
+                          strerror(-err));
+
+                    if (sessionID == mSessionID) {
+                        ALOGI("Lost control connection.");
+
+                        // The control connection is dead now.
+                        mNetSession->destroySession(mSessionID);
+                        mSessionID = 0;
+
+                        looper()->stop();
+                    }
+                    break;
+                }
+
+                case ANetworkSession::kWhatConnected:
+                {
+                    ALOGI("We're now connected.");
+                    mState = CONNECTED;
+
+                    if (!mSetupURI.empty()) {
+                        status_t err =
+                            sendDescribe(mSessionID, mSetupURI.c_str());
+
+                        CHECK_EQ(err, (status_t)OK);
+                    }
+                    break;
+                }
+
+                case ANetworkSession::kWhatData:
+                {
+                    onReceiveClientData(msg);
+                    break;
+                }
+
+                case ANetworkSession::kWhatBinaryData:
+                {
+                    CHECK(sUseTCPInterleaving);
+
+                    int32_t channel;
+                    CHECK(msg->findInt32("channel", &channel));
+
+                    sp<ABuffer> data;
+                    CHECK(msg->findBuffer("data", &data));
+
+                    mRTPSink->injectPacket(channel == 0 /* isRTP */, data);
+                    break;
+                }
+
+                default:
+                    TRESPASS();
+            }
+            break;
+        }
+
+        case kWhatStop:
+        {
+            looper()->stop();
+            break;
+        }
+
+        default:
+            TRESPASS();
+    }
+}
+
+void WifiDisplaySink::registerResponseHandler(
+        int32_t sessionID, int32_t cseq, HandleRTSPResponseFunc func) {
+    ResponseID id;
+    id.mSessionID = sessionID;
+    id.mCSeq = cseq;
+    mResponseHandlers.add(id, func);
+}
+
+status_t WifiDisplaySink::sendM2(int32_t sessionID) {
+    AString request = "OPTIONS * RTSP/1.0\r\n";
+    AppendCommonResponse(&request, mNextCSeq);
+
+    request.append(
+            "Require: org.wfa.wfd1.0\r\n"
+            "\r\n");
+
+    status_t err =
+        mNetSession->sendRequest(sessionID, request.c_str(), request.size());
+
+    if (err != OK) {
+        return err;
+    }
+
+    registerResponseHandler(
+            sessionID, mNextCSeq, &WifiDisplaySink::onReceiveM2Response);
+
+    ++mNextCSeq;
+
+    return OK;
+}
+
+status_t WifiDisplaySink::onReceiveM2Response(
+        int32_t sessionID, const sp<ParsedMessage> &msg) {
+    int32_t statusCode;
+    if (!msg->getStatusCode(&statusCode)) {
+        return ERROR_MALFORMED;
+    }
+
+    if (statusCode != 200) {
+        return ERROR_UNSUPPORTED;
+    }
+
+    return OK;
+}
+
+status_t WifiDisplaySink::onReceiveDescribeResponse(
+        int32_t sessionID, const sp<ParsedMessage> &msg) {
+    int32_t statusCode;
+    if (!msg->getStatusCode(&statusCode)) {
+        return ERROR_MALFORMED;
+    }
+
+    if (statusCode != 200) {
+        return ERROR_UNSUPPORTED;
+    }
+
+    return sendSetup(sessionID, mSetupURI.c_str());
+}
+
+status_t WifiDisplaySink::onReceiveSetupResponse(
+        int32_t sessionID, const sp<ParsedMessage> &msg) {
+    int32_t statusCode;
+    if (!msg->getStatusCode(&statusCode)) {
+        return ERROR_MALFORMED;
+    }
+
+    if (statusCode != 200) {
+        return ERROR_UNSUPPORTED;
+    }
+
+    if (!msg->findString("session", &mPlaybackSessionID)) {
+        return ERROR_MALFORMED;
+    }
+
+    if (!ParsedMessage::GetInt32Attribute(
+                mPlaybackSessionID.c_str(),
+                "timeout",
+                &mPlaybackSessionTimeoutSecs)) {
+        mPlaybackSessionTimeoutSecs = -1;
+    }
+
+    ssize_t colonPos = mPlaybackSessionID.find(";");
+    if (colonPos >= 0) {
+        // Strip any options from the returned session id.
+        mPlaybackSessionID.erase(
+                colonPos, mPlaybackSessionID.size() - colonPos);
+    }
+
+    status_t err = configureTransport(msg);
+
+    if (err != OK) {
+        return err;
+    }
+
+    mState = PAUSED;
+
+    return sendPlay(
+            sessionID,
+            !mSetupURI.empty()
+                ? mSetupURI.c_str() : "rtsp://x.x.x.x:x/wfd1.0/streamid=0");
+}
+
+status_t WifiDisplaySink::configureTransport(const sp<ParsedMessage> &msg) {
+    if (sUseTCPInterleaving) {
+        return OK;
+    }
+
+    AString transport;
+    if (!msg->findString("transport", &transport)) {
+        ALOGE("Missing 'transport' field in SETUP response.");
+        return ERROR_MALFORMED;
+    }
+
+    AString sourceHost;
+    if (!ParsedMessage::GetAttribute(
+                transport.c_str(), "source", &sourceHost)) {
+        sourceHost = mRTSPHost;
+    }
+
+    AString serverPortStr;
+    if (!ParsedMessage::GetAttribute(
+                transport.c_str(), "server_port", &serverPortStr)) {
+        ALOGE("Missing 'server_port' in Transport field.");
+        return ERROR_MALFORMED;
+    }
+
+    int rtpPort, rtcpPort;
+    if (sscanf(serverPortStr.c_str(), "%d-%d", &rtpPort, &rtcpPort) != 2
+            || rtpPort <= 0 || rtpPort > 65535
+            || rtcpPort <=0 || rtcpPort > 65535
+            || rtcpPort != rtpPort + 1) {
+        ALOGE("Invalid server_port description '%s'.",
+                serverPortStr.c_str());
+
+        return ERROR_MALFORMED;
+    }
+
+    if (rtpPort & 1) {
+        ALOGW("Server picked an odd numbered RTP port.");
+    }
+
+    return mRTPSink->connect(sourceHost.c_str(), rtpPort, rtcpPort);
+}
+
+status_t WifiDisplaySink::onReceivePlayResponse(
+        int32_t sessionID, const sp<ParsedMessage> &msg) {
+    int32_t statusCode;
+    if (!msg->getStatusCode(&statusCode)) {
+        return ERROR_MALFORMED;
+    }
+
+    if (statusCode != 200) {
+        return ERROR_UNSUPPORTED;
+    }
+
+    mState = PLAYING;
+
+    return OK;
+}
+
+void WifiDisplaySink::onReceiveClientData(const sp<AMessage> &msg) {
+    int32_t sessionID;
+    CHECK(msg->findInt32("sessionID", &sessionID));
+
+    sp<RefBase> obj;
+    CHECK(msg->findObject("data", &obj));
+
+    sp<ParsedMessage> data =
+        static_cast<ParsedMessage *>(obj.get());
+
+    ALOGV("session %d received '%s'",
+          sessionID, data->debugString().c_str());
+
+    AString method;
+    AString uri;
+    data->getRequestField(0, &method);
+
+    int32_t cseq;
+    if (!data->findInt32("cseq", &cseq)) {
+        sendErrorResponse(sessionID, "400 Bad Request", -1 /* cseq */);
+        return;
+    }
+
+    if (method.startsWith("RTSP/")) {
+        // This is a response.
+
+        ResponseID id;
+        id.mSessionID = sessionID;
+        id.mCSeq = cseq;
+
+        ssize_t index = mResponseHandlers.indexOfKey(id);
+
+        if (index < 0) {
+            ALOGW("Received unsolicited server response, cseq %d", cseq);
+            return;
+        }
+
+        HandleRTSPResponseFunc func = mResponseHandlers.valueAt(index);
+        mResponseHandlers.removeItemsAt(index);
+
+        status_t err = (this->*func)(sessionID, data);
+        CHECK_EQ(err, (status_t)OK);
+    } else {
+        AString version;
+        data->getRequestField(2, &version);
+        if (!(version == AString("RTSP/1.0"))) {
+            sendErrorResponse(sessionID, "505 RTSP Version not supported", cseq);
+            return;
+        }
+
+        if (method == "OPTIONS") {
+            onOptionsRequest(sessionID, cseq, data);
+        } else if (method == "GET_PARAMETER") {
+            onGetParameterRequest(sessionID, cseq, data);
+        } else if (method == "SET_PARAMETER") {
+            onSetParameterRequest(sessionID, cseq, data);
+        } else {
+            sendErrorResponse(sessionID, "405 Method Not Allowed", cseq);
+        }
+    }
+}
+
+void WifiDisplaySink::onOptionsRequest(
+        int32_t sessionID,
+        int32_t cseq,
+        const sp<ParsedMessage> &data) {
+    AString response = "RTSP/1.0 200 OK\r\n";
+    AppendCommonResponse(&response, cseq);
+    response.append("Public: org.wfa.wfd1.0, GET_PARAMETER, SET_PARAMETER\r\n");
+    response.append("\r\n");
+
+    status_t err = mNetSession->sendRequest(sessionID, response.c_str());
+    CHECK_EQ(err, (status_t)OK);
+
+    err = sendM2(sessionID);
+    CHECK_EQ(err, (status_t)OK);
+}
+
+void WifiDisplaySink::onGetParameterRequest(
+        int32_t sessionID,
+        int32_t cseq,
+        const sp<ParsedMessage> &data) {
+    //AString body =
+    //    "wfd_video_formats: xxx\r\n"
+    //    "wfd_audio_codecs: xxx\r\n"
+    //    "wfd_client_rtp_ports: RTP/AVP/UDP;unicast xxx 0 mode=play\r\n";
+    AString body =
+        "wfd_video_formats: 40 00 02 02 0001DEFF 157C7FFF 00000FFF 00 0000 0000 11 none none, 01 02 0001DEFF 157C7FFF 00000FFF 00 0000 0000 11 none none\r\n" // TODO FIXMI ^^;;
+        "wfd_audio_codecs: LPCM 00000003 00, AAC 0000000F 00\r\n"
+        "wfd_client_rtp_ports: RTP/AVP/UDP;unicast 19000 0 mode=play\r\n";
+// "wfd_video_formats: 38 01 01 08 0001deff 07ffffff 00000fff 02 0000 0000 11 0780 0438" // Q-WH-D1
+// "wfd_video_formats: 40 00 02 02 0001DEFF 157C7FFF 00000FFF 00 0000 0000 11 none none, 01 02 0001DEFF 157C7FFF 00000FFF 00 0000 0000 11 none none" // PTV3000
+// "wfd_video_formats: 79 00 02 02 0001DEFF 157C7FFF 00000FFF 00 0000 0000 11 none none, 01 02 0001DEFF 157C7FFF 00000FFF 00 0000 0000 11 none none" // NEC wsbox
+
+    AString response = "RTSP/1.0 200 OK\r\n";
+    AppendCommonResponse(&response, cseq);
+    response.append("Content-Type: text/parameters\r\n");
+    response.append(StringPrintf("Content-Length: %d\r\n", body.size()));
+    response.append("\r\n");
+    response.append(body);
+
+    status_t err = mNetSession->sendRequest(sessionID, response.c_str());
+    CHECK_EQ(err, (status_t)OK);
+}
+
+status_t WifiDisplaySink::sendDescribe(int32_t sessionID, const char *uri) {
+    uri = "rtsp://xwgntvx.is.livestream-api.com/livestreamiphone/wgntv";
+    uri = "rtsp://v2.cache6.c.youtube.com/video.3gp?cid=e101d4bf280055f9&fmt=18";
+
+    AString request = StringPrintf("DESCRIBE %s RTSP/1.0\r\n", uri);
+    AppendCommonResponse(&request, mNextCSeq);
+
+    request.append("Accept: application/sdp\r\n");
+    request.append("\r\n");
+
+    status_t err = mNetSession->sendRequest(
+            sessionID, request.c_str(), request.size());
+
+    if (err != OK) {
+        return err;
+    }
+
+    registerResponseHandler(
+            sessionID, mNextCSeq, &WifiDisplaySink::onReceiveDescribeResponse);
+
+    ++mNextCSeq;
+
+    return OK;
+}
+
+status_t WifiDisplaySink::sendSetup(int32_t sessionID, const char *uri) {
+    mRTPSink = new RTPSink(mNetSession, mSurfaceTex);
+    looper()->registerHandler(mRTPSink);
+
+    status_t err = mRTPSink->init(sUseTCPInterleaving);
+
+    if (err != OK) {
+        looper()->unregisterHandler(mRTPSink->id());
+        mRTPSink.clear();
+        return err;
+    }
+
+    AString request = StringPrintf("SETUP %s RTSP/1.0\r\n", uri);
+
+    AppendCommonResponse(&request, mNextCSeq);
+
+    if (sUseTCPInterleaving) {
+        request.append("Transport: RTP/AVP/TCP;interleaved=0-1\r\n");
+    } else {
+        int32_t rtpPort = mRTPSink->getRTPPort();
+
+        request.append(
+                StringPrintf(
+                    "Transport: RTP/AVP/UDP;unicast;client_port=%d-%d\r\n",
+                    rtpPort, rtpPort + 1));
+    }
+
+    request.append("\r\n");
+
+    ALOGV("request = '%s'", request.c_str());
+
+    err = mNetSession->sendRequest(sessionID, request.c_str(), request.size());
+
+    if (err != OK) {
+        return err;
+    }
+
+    registerResponseHandler(
+            sessionID, mNextCSeq, &WifiDisplaySink::onReceiveSetupResponse);
+
+    ++mNextCSeq;
+
+    return OK;
+}
+
+status_t WifiDisplaySink::sendPlay(int32_t sessionID, const char *uri) {
+    AString request = StringPrintf("PLAY %s RTSP/1.0\r\n", uri);
+
+    AppendCommonResponse(&request, mNextCSeq);
+
+    request.append(StringPrintf("Session: %s\r\n", mPlaybackSessionID.c_str()));
+    request.append("\r\n");
+
+    status_t err =
+        mNetSession->sendRequest(sessionID, request.c_str(), request.size());
+
+    if (err != OK) {
+        return err;
+    }
+
+    registerResponseHandler(
+            sessionID, mNextCSeq, &WifiDisplaySink::onReceivePlayResponse);
+
+    ++mNextCSeq;
+
+    return OK;
+}
+
+void WifiDisplaySink::onSetParameterRequest(
+        int32_t sessionID,
+        int32_t cseq,
+        const sp<ParsedMessage> &data) {
+    const char *content = data->getContent();
+
+    if (strstr(content, "wfd_trigger_method: SETUP\r\n") != NULL) {
+        status_t err =
+            sendSetup(
+                    sessionID,
+                    "rtsp://x.x.x.x:x/wfd1.0/streamid=0");
+
+        CHECK_EQ(err, (status_t)OK);
+    }
+
+    AString response = "RTSP/1.0 200 OK\r\n";
+    AppendCommonResponse(&response, cseq);
+    response.append("\r\n");
+
+    status_t err = mNetSession->sendRequest(sessionID, response.c_str());
+    CHECK_EQ(err, (status_t)OK);
+}
+
+void WifiDisplaySink::sendErrorResponse(
+        int32_t sessionID,
+        const char *errorDetail,
+        int32_t cseq) {
+    AString response;
+    response.append("RTSP/1.0 ");
+    response.append(errorDetail);
+    response.append("\r\n");
+
+    AppendCommonResponse(&response, cseq);
+
+    response.append("\r\n");
+
+    status_t err = mNetSession->sendRequest(sessionID, response.c_str());
+    CHECK_EQ(err, (status_t)OK);
+}
+
+// static
+void WifiDisplaySink::AppendCommonResponse(AString *response, int32_t cseq) {
+    time_t now = time(NULL);
+    struct tm *now2 = gmtime(&now);
+    char buf[128];
+    strftime(buf, sizeof(buf), "%a, %d %b %Y %H:%M:%S %z", now2);
+
+    response->append("Date: ");
+    response->append(buf);
+    response->append("\r\n");
+
+    response->append("User-Agent: stagefright/1.1 (Linux;Android 4.1)\r\n");
+
+    if (cseq >= 0) {
+        response->append(StringPrintf("CSeq: %d\r\n", cseq));
+    }
+}
+
+}  // namespace android
diff -Naur a/frameworks/av/media/libstagefright/wifi-display/sink/WifiDisplaySink.h b/frameworks/av/media/libstagefright/wifi-display/sink/WifiDisplaySink.h
--- a/frameworks/av/media/libstagefright/wifi-display/sink/WifiDisplaySink.h	1969-12-31 19:00:00.000000000 -0500
+++ b/frameworks/av/media/libstagefright/wifi-display/sink/WifiDisplaySink.h	2014-03-24 13:27:01.108651000 -0400
@@ -0,0 +1,195 @@
+/*
+ * Copyright 2012, The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#ifndef WIFI_DISPLAY_SINK_H_
+
+#define WIFI_DISPLAY_SINK_H_
+
+#include "VideoFormats.h"
+
+#include <gui/Surface.h>
+#include <media/stagefright/foundation/AHandler.h>
+#include <media/stagefright/foundation/ANetworkSession.h>
+
+namespace android {
+
+struct AMessage;
+struct DirectRenderer;
+struct MediaReceiver;
+struct ParsedMessage;
+struct TimeSyncer;
+
+// Represents the RTSP client acting as a wifi display sink.
+// Connects to a wifi display source and renders the incoming
+// transport stream using a MediaPlayer instance.
+struct WifiDisplaySink : public AHandler {
+    enum {
+        kWhatDisconnected,
+    };
+
+    enum Flags {
+        FLAG_SPECIAL_MODE = 1,
+    };
+
+    // If no notification message is specified (notify == NULL)
+    // the sink will stop its looper() once the session ends,
+    // otherwise it will post an appropriate notification but leave
+    // the looper() running.
+    WifiDisplaySink(
+            uint32_t flags,
+            const sp<ANetworkSession> &netSession,
+            const sp<IGraphicBufferProducer> &bufferProducer = NULL,
+            const sp<AMessage> &notify = NULL);
+
+    void start(const char *sourceHost, int32_t sourcePort);
+    void start(const char *uri);
+
+protected:
+    virtual ~WifiDisplaySink();
+    virtual void onMessageReceived(const sp<AMessage> &msg);
+
+private:
+    enum State {
+        UNDEFINED,
+        CONNECTING,
+        CONNECTED,
+        PAUSED,
+        PLAYING,
+    };
+
+    enum {
+        kWhatStart,
+        kWhatRTSPNotify,
+        kWhatStop,
+        kWhatMediaReceiverNotify,
+        kWhatTimeSyncerNotify,
+        kWhatReportLateness,
+    };
+
+    struct ResponseID {
+        int32_t mSessionID;
+        int32_t mCSeq;
+
+        bool operator<(const ResponseID &other) const {
+            return mSessionID < other.mSessionID
+                || (mSessionID == other.mSessionID
+                        && mCSeq < other.mCSeq);
+        }
+    };
+
+    typedef status_t (WifiDisplaySink::*HandleRTSPResponseFunc)(
+            int32_t sessionID, const sp<ParsedMessage> &msg);
+
+    static const int64_t kReportLatenessEveryUs = 1000000ll;
+
+    static const AString sUserAgent;
+
+    State mState;
+    uint32_t mFlags;
+    VideoFormats mSinkSupportedVideoFormats;
+    sp<ANetworkSession> mNetSession;
+    sp<IGraphicBufferProducer> mSurfaceTex;
+    sp<AMessage> mNotify;
+    sp<TimeSyncer> mTimeSyncer;
+    bool mUsingTCPTransport;
+    bool mUsingTCPInterleaving;
+    AString mRTSPHost;
+    int32_t mSessionID;
+
+    int32_t mNextCSeq;
+
+    KeyedVector<ResponseID, HandleRTSPResponseFunc> mResponseHandlers;
+
+    sp<ALooper> mMediaReceiverLooper;
+    sp<MediaReceiver> mMediaReceiver;
+    sp<DirectRenderer> mRenderer;
+
+    AString mPlaybackSessionID;
+    int32_t mPlaybackSessionTimeoutSecs;
+
+    bool mIDRFrameRequestPending;
+
+    int64_t mTimeOffsetUs;
+    bool mTimeOffsetValid;
+
+    bool mSetupDeferred;
+
+    size_t mLatencyCount;
+    int64_t mLatencySumUs;
+    int64_t mLatencyMaxUs;
+
+    int64_t mMaxDelayMs;
+
+    status_t sendM2(int32_t sessionID);
+    status_t sendSetup(int32_t sessionID, const char *uri);
+    status_t sendPlay(int32_t sessionID, const char *uri);
+    status_t sendIDRFrameRequest(int32_t sessionID);
+
+    status_t onReceiveM2Response(
+            int32_t sessionID, const sp<ParsedMessage> &msg);
+
+    status_t onReceiveSetupResponse(
+            int32_t sessionID, const sp<ParsedMessage> &msg);
+
+    status_t configureTransport(const sp<ParsedMessage> &msg);
+
+    status_t onReceivePlayResponse(
+            int32_t sessionID, const sp<ParsedMessage> &msg);
+
+    status_t onReceiveIDRFrameRequestResponse(
+            int32_t sessionID, const sp<ParsedMessage> &msg);
+
+    void registerResponseHandler(
+            int32_t sessionID, int32_t cseq, HandleRTSPResponseFunc func);
+
+    void onReceiveClientData(const sp<AMessage> &msg);
+
+    void onOptionsRequest(
+            int32_t sessionID,
+            int32_t cseq,
+            const sp<ParsedMessage> &data);
+
+    void onGetParameterRequest(
+            int32_t sessionID,
+            int32_t cseq,
+            const sp<ParsedMessage> &data);
+
+    void onSetParameterRequest(
+            int32_t sessionID,
+            int32_t cseq,
+            const sp<ParsedMessage> &data);
+
+    void onMediaReceiverNotify(const sp<AMessage> &msg);
+
+    void sendErrorResponse(
+            int32_t sessionID,
+            const char *errorDetail,
+            int32_t cseq);
+
+    static void AppendCommonResponse(AString *response, int32_t cseq);
+
+    bool ParseURL(
+            const char *url, AString *host, int32_t *port, AString *path,
+            AString *user, AString *pass);
+
+    void dumpDelay(size_t trackIndex, int64_t timeUs);
+
+    DISALLOW_EVIL_CONSTRUCTORS(WifiDisplaySink);
+};
+
+}  // namespace android
+
+#endif  // WIFI_DISPLAY_SINK_H_
diff -Naur a/frameworks/av/media/libstagefright/wifi-display/SNTPClient.cpp b/frameworks/av/media/libstagefright/wifi-display/SNTPClient.cpp
--- a/frameworks/av/media/libstagefright/wifi-display/SNTPClient.cpp	1969-12-31 19:00:00.000000000 -0500
+++ b/frameworks/av/media/libstagefright/wifi-display/SNTPClient.cpp	2014-03-24 09:52:53.392384591 -0400
@@ -0,0 +1,174 @@
+/*
+ * Copyright 2013, The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#include "SNTPClient.h"
+
+#include <media/stagefright/foundation/ALooper.h>
+#include <media/stagefright/Utils.h>
+
+#include <arpa/inet.h>
+#include <netdb.h>
+#include <netinet/in.h>
+#include <sys/socket.h>
+#include <unistd.h>
+
+namespace android {
+
+SNTPClient::SNTPClient() {
+}
+
+status_t SNTPClient::requestTime(const char *host) {
+    struct hostent *ent;
+    int64_t requestTimeNTP, requestTimeUs;
+    ssize_t n;
+    int64_t responseTimeUs, responseTimeNTP;
+    int64_t originateTimeNTP, receiveTimeNTP, transmitTimeNTP;
+    int64_t roundTripTimeNTP, clockOffsetNTP;
+
+    status_t err = UNKNOWN_ERROR;
+
+    int s = socket(AF_INET, SOCK_DGRAM, 0);
+
+    if (s < 0) {
+        err = -errno;
+
+        goto bail;
+    }
+
+    ent = gethostbyname(host);
+
+    if (ent == NULL) {
+        err = -ENOENT;
+        goto bail2;
+    }
+
+    struct sockaddr_in hostAddr;
+    memset(hostAddr.sin_zero, 0, sizeof(hostAddr.sin_zero));
+    hostAddr.sin_family = AF_INET;
+    hostAddr.sin_port = htons(kNTPPort);
+    hostAddr.sin_addr.s_addr = *(in_addr_t *)ent->h_addr;
+
+    uint8_t packet[kNTPPacketSize];
+    memset(packet, 0, sizeof(packet));
+
+    packet[0] = kNTPModeClient | (kNTPVersion << 3);
+
+    requestTimeNTP = getNowNTP();
+    requestTimeUs = ALooper::GetNowUs();
+    writeTimeStamp(&packet[kNTPTransmitTimeOffset], requestTimeNTP);
+
+    n = sendto(
+            s, packet, sizeof(packet), 0,
+            (const struct sockaddr *)&hostAddr, sizeof(hostAddr));
+
+    if (n < 0) {
+        err = -errno;
+        goto bail2;
+    }
+
+    memset(packet, 0, sizeof(packet));
+
+    do {
+        n = recv(s, packet, sizeof(packet), 0);
+    } while (n < 0 && errno == EINTR);
+
+    if (n < 0) {
+        err = -errno;
+        goto bail2;
+    }
+
+    responseTimeUs = ALooper::GetNowUs();
+
+    responseTimeNTP = requestTimeNTP + makeNTP(responseTimeUs - requestTimeUs);
+
+    originateTimeNTP = readTimeStamp(&packet[kNTPOriginateTimeOffset]);
+    receiveTimeNTP = readTimeStamp(&packet[kNTPReceiveTimeOffset]);
+    transmitTimeNTP = readTimeStamp(&packet[kNTPTransmitTimeOffset]);
+
+    roundTripTimeNTP =
+        makeNTP(responseTimeUs - requestTimeUs)
+            - (transmitTimeNTP - receiveTimeNTP);
+
+    clockOffsetNTP =
+        ((receiveTimeNTP - originateTimeNTP)
+            + (transmitTimeNTP - responseTimeNTP)) / 2;
+
+    mTimeReferenceNTP = responseTimeNTP + clockOffsetNTP;
+    mTimeReferenceUs = responseTimeUs;
+    mRoundTripTimeNTP = roundTripTimeNTP;
+
+    err = OK;
+
+bail2:
+    close(s);
+    s = -1;
+
+bail:
+    return err;
+}
+
+int64_t SNTPClient::adjustTimeUs(int64_t timeUs) const {
+    uint64_t nowNTP =
+        mTimeReferenceNTP + makeNTP(timeUs - mTimeReferenceUs);
+
+    int64_t nowUs =
+        (nowNTP >> 32) * 1000000ll
+        + ((nowNTP & 0xffffffff) * 1000000ll) / (1ll << 32);
+
+    nowUs -= ((70ll * 365 + 17) * 24) * 60 * 60 * 1000000ll;
+
+    return nowUs;
+}
+
+// static
+void SNTPClient::writeTimeStamp(uint8_t *dst, uint64_t ntpTime) {
+    *dst++ = (ntpTime >> 56) & 0xff;
+    *dst++ = (ntpTime >> 48) & 0xff;
+    *dst++ = (ntpTime >> 40) & 0xff;
+    *dst++ = (ntpTime >> 32) & 0xff;
+    *dst++ = (ntpTime >> 24) & 0xff;
+    *dst++ = (ntpTime >> 16) & 0xff;
+    *dst++ = (ntpTime >> 8) & 0xff;
+    *dst++ = ntpTime & 0xff;
+}
+
+// static
+uint64_t SNTPClient::readTimeStamp(const uint8_t *dst) {
+    return U64_AT(dst);
+}
+
+// static
+uint64_t SNTPClient::getNowNTP() {
+    struct timeval tv;
+    gettimeofday(&tv, NULL /* time zone */);
+
+    uint64_t nowUs = tv.tv_sec * 1000000ll + tv.tv_usec;
+
+    nowUs += ((70ll * 365 + 17) * 24) * 60 * 60 * 1000000ll;
+
+    return makeNTP(nowUs);
+}
+
+// static
+uint64_t SNTPClient::makeNTP(uint64_t deltaUs) {
+    uint64_t hi = deltaUs / 1000000ll;
+    uint64_t lo = ((1ll << 32) * (deltaUs % 1000000ll)) / 1000000ll;
+
+    return (hi << 32) | lo;
+}
+
+}  // namespace android
+
diff -Naur a/frameworks/av/media/libstagefright/wifi-display/SNTPClient.h b/frameworks/av/media/libstagefright/wifi-display/SNTPClient.h
--- a/frameworks/av/media/libstagefright/wifi-display/SNTPClient.h	1969-12-31 19:00:00.000000000 -0500
+++ b/frameworks/av/media/libstagefright/wifi-display/SNTPClient.h	2014-03-24 09:53:33.372385421 -0400
@@ -0,0 +1,62 @@
+/*
+ * Copyright 2013, The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#ifndef SNTP_CLIENT_H_
+
+#define SNTP_CLIENT_H_
+
+#include <media/stagefright/foundation/ABase.h>
+#include <utils/Errors.h>
+
+namespace android {
+
+// Implementation of the SNTP (Simple Network Time Protocol)
+struct SNTPClient {
+    SNTPClient();
+
+    status_t requestTime(const char *host);
+
+    // given a time obtained from ALooper::GetNowUs()
+    // return the number of us elapsed since Jan 1 1970 00:00:00 (UTC).
+    int64_t adjustTimeUs(int64_t timeUs) const;
+
+private:
+    enum {
+        kNTPPort = 123,
+        kNTPPacketSize = 48,
+        kNTPModeClient = 3,
+        kNTPVersion = 3,
+        kNTPTransmitTimeOffset = 40,
+        kNTPOriginateTimeOffset = 24,
+        kNTPReceiveTimeOffset = 32,
+    };
+
+    uint64_t mTimeReferenceNTP;
+    int64_t mTimeReferenceUs;
+    int64_t mRoundTripTimeNTP;
+
+    static void writeTimeStamp(uint8_t *dst, uint64_t ntpTime);
+    static uint64_t readTimeStamp(const uint8_t *dst);
+
+    static uint64_t getNowNTP();
+    static uint64_t makeNTP(uint64_t deltaUs);
+
+    DISALLOW_EVIL_CONSTRUCTORS(SNTPClient);
+};
+
+}  // namespace android
+
+#endif  // SNTP_CLIENT_H_
diff -Naur a/frameworks/av/media/libstagefright/wifi-display/source/udptest.cpp b/frameworks/av/media/libstagefright/wifi-display/source/udptest.cpp
--- a/frameworks/av/media/libstagefright/wifi-display/source/udptest.cpp	1969-12-31 19:00:00.000000000 -0500
+++ b/frameworks/av/media/libstagefright/wifi-display/source/udptest.cpp	2014-03-24 10:13:12.884409917 -0400
@@ -0,0 +1,115 @@
+/*
+ * Copyright 2012, The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+//#define LOG_NEBUG 0
+#define LOG_TAG "udptest"
+#include <utils/Log.h>
+
+#include "TimeSyncer.h"
+
+#include <binder/ProcessState.h>
+#include <media/stagefright/foundation/AMessage.h>
+#include <media/stagefright/foundation/ANetworkSession.h>
+
+namespace android {
+
+}  // namespace android
+
+static void usage(const char *me) {
+    fprintf(stderr,
+            "usage: %s -c host[:port]\tconnect to test server\n"
+            "           -l            \tcreate a test server\n",
+            me);
+}
+
+int main(int argc, char **argv) {
+    using namespace android;
+
+    ProcessState::self()->startThreadPool();
+
+    int32_t localPort = -1;
+    int32_t connectToPort = -1;
+    AString connectToHost;
+
+    int res;
+    while ((res = getopt(argc, argv, "hc:l:")) >= 0) {
+        switch (res) {
+            case 'c':
+            {
+                const char *colonPos = strrchr(optarg, ':');
+
+                if (colonPos == NULL) {
+                    connectToHost = optarg;
+                    connectToPort = 49152;
+                } else {
+                    connectToHost.setTo(optarg, colonPos - optarg);
+
+                    char *end;
+                    connectToPort = strtol(colonPos + 1, &end, 10);
+
+                    if (*end != '\0' || end == colonPos + 1
+                            || connectToPort < 1 || connectToPort > 65535) {
+                        fprintf(stderr, "Illegal port specified.\n");
+                        exit(1);
+                    }
+                }
+                break;
+            }
+
+            case 'l':
+            {
+                char *end;
+                localPort = strtol(optarg, &end, 10);
+
+                if (*end != '\0' || end == optarg
+                        || localPort < 1 || localPort > 65535) {
+                    fprintf(stderr, "Illegal port specified.\n");
+                    exit(1);
+                }
+                break;
+            }
+
+            case '?':
+            case 'h':
+                usage(argv[0]);
+                exit(1);
+        }
+    }
+
+    if (localPort < 0 && connectToPort < 0) {
+        fprintf(stderr,
+                "You need to select either client or server mode.\n");
+        exit(1);
+    }
+
+    sp<ANetworkSession> netSession = new ANetworkSession;
+    netSession->start();
+
+    sp<ALooper> looper = new ALooper;
+
+    sp<TimeSyncer> handler = new TimeSyncer(netSession, NULL /* notify */);
+    looper->registerHandler(handler);
+
+    if (localPort >= 0) {
+        handler->startServer(localPort);
+    } else {
+        handler->startClient(connectToHost.c_str(), connectToPort);
+    }
+
+    looper->start(true /* runOnCallingThread */);
+
+    return 0;
+}
diff -Naur a/frameworks/av/media/libstagefright/wifi-display/source/WifiDisplaySource.cpp b/frameworks/av/media/libstagefright/wifi-display/source/WifiDisplaySource.cpp
--- a/frameworks/av/media/libstagefright/wifi-display/source/WifiDisplaySource.cpp	2014-03-23 23:08:08.443581000 -0400
+++ b/frameworks/av/media/libstagefright/wifi-display/source/WifiDisplaySource.cpp	2013-08-14 04:13:30.000000000 -0400
@@ -21,19 +21,18 @@
 #include "WifiDisplaySource.h"
 #include "PlaybackSession.h"
 #include "Parameters.h"
-#include "rtp/RTPSender.h"
+#include "ParsedMessage.h"
+#include "Sender.h"
 
 #include <binder/IServiceManager.h>
-#include <gui/IGraphicBufferProducer.h>
+#include <gui/ISurfaceTexture.h>
 #include <media/IHDCP.h>
 #include <media/IMediaPlayerService.h>
 #include <media/IRemoteDisplayClient.h>
 #include <media/stagefright/foundation/ABuffer.h>
 #include <media/stagefright/foundation/ADebug.h>
 #include <media/stagefright/foundation/AMessage.h>
-#include <media/stagefright/foundation/ParsedMessage.h>
 #include <media/stagefright/MediaErrors.h>
-#include <media/stagefright/Utils.h>
 
 #include <arpa/inet.h>
 #include <cutils/properties.h>
@@ -42,13 +41,9 @@
 
 namespace android {
 
-// static
-const AString WifiDisplaySource::sUserAgent = MakeUserAgent();
-
 WifiDisplaySource::WifiDisplaySource(
         const sp<ANetworkSession> &netSession,
-        const sp<IRemoteDisplayClient> &client,
-        const char *path)
+        const sp<IRemoteDisplayClient> &client)
     : mState(INITIALIZED),
       mNetSession(netSession),
       mClient(client),
@@ -63,22 +58,8 @@
       mIsHDCP2_0(false),
       mHDCPPort(0),
       mHDCPInitializationComplete(false),
-      mSetupTriggerDeferred(false),
-      mPlaybackSessionEstablished(false) {
-    if (path != NULL) {
-        mMediaPath.setTo(path);
-    }
-
-    mSupportedSourceVideoFormats.disableAll();
-
-    mSupportedSourceVideoFormats.setNativeResolution(
-            VideoFormats::RESOLUTION_CEA, 5);  // 1280x720 p30
-
-    // Enable all resolutions up to 1280x720p30
-    mSupportedSourceVideoFormats.enableResolutionUpto(
-            VideoFormats::RESOLUTION_CEA, 5,
-            VideoFormats::PROFILE_CHP,  // Constrained High Profile
-            VideoFormats::LEVEL_32);    // Level 3.2
+      mSetupTriggerDeferred(false)
+{
 }
 
 WifiDisplaySource::~WifiDisplaySource() {
@@ -172,7 +153,9 @@
                 }
             }
 
-            mState = AWAITING_CLIENT_CONNECTION;
+            if (err == OK) {
+                mState = AWAITING_CLIENT_CONNECTION;
+            }
 
             sp<AMessage> response = new AMessage;
             response->setInt32("err", err);
@@ -270,8 +253,7 @@
                         if (!strcasecmp(val, "pause") && mState == PLAYING) {
                             mState = PLAYING_TO_PAUSED;
                             sendTrigger(mClientSessionID, TRIGGER_PAUSE);
-                        } else if (!strcasecmp(val, "play")
-                                    && mState == PAUSED) {
+                        } else if (!strcasecmp(val, "play") && mState == PAUSED) {
                             mState = PAUSED_TO_PLAYING;
                             sendTrigger(mClientSessionID, TRIGGER_PLAY);
                         }
@@ -280,11 +262,6 @@
                     break;
                 }
 
-                case ANetworkSession::kWhatNetworkStall:
-                {
-                    break;
-                }
-
                 default:
                     TRESPASS();
             }
@@ -397,43 +374,16 @@
                 mClient->onDisplayError(
                         IRemoteDisplayClient::kDisplayErrorUnknown);
             } else if (what == PlaybackSession::kWhatSessionEstablished) {
-                mPlaybackSessionEstablished = true;
-
                 if (mClient != NULL) {
-                    if (!mSinkSupportsVideo) {
-                        mClient->onDisplayConnected(
-                                NULL,  // SurfaceTexture
-                                0, // width,
-                                0, // height,
-                                mUsingHDCP
-                                    ? IRemoteDisplayClient::kDisplayFlagSecure
-                                    : 0,
-                                0);
-                    } else {
-                        size_t width, height;
-
-                        CHECK(VideoFormats::GetConfiguration(
-                                    mChosenVideoResolutionType,
-                                    mChosenVideoResolutionIndex,
-                                    &width,
-                                    &height,
-                                    NULL /* framesPerSecond */,
-                                    NULL /* interlaced */));
-
-                        mClient->onDisplayConnected(
-                                mClientInfo.mPlaybackSession
-                                    ->getSurfaceTexture(),
-                                width,
-                                height,
-                                mUsingHDCP
-                                    ? IRemoteDisplayClient::kDisplayFlagSecure
-                                    : 0,
-                                playbackSessionID);
-                    }
+                    mClient->onDisplayConnected(
+                            mClientInfo.mPlaybackSession->getSurfaceTexture(),
+                            mClientInfo.mPlaybackSession->width(),
+                            mClientInfo.mPlaybackSession->height(),
+                            mUsingHDCP
+                                ? IRemoteDisplayClient::kDisplayFlagSecure
+                                : 0);
                 }
 
-                finishPlay();
-
                 if (mState == ABOUT_TO_PLAY) {
                     mState = PLAYING;
                 }
@@ -584,11 +534,25 @@
 }
 
 status_t WifiDisplaySource::sendM3(int32_t sessionID) {
-    AString body =
-        "wfd_content_protection\r\n"
-        "wfd_video_formats\r\n"
-        "wfd_audio_codecs\r\n"
-        "wfd_client_rtp_ports\r\n";
+    // HDCP Authentication Skip!
+    char val[PROPERTY_VALUE_MAX];
+    bool skip_hdcp = property_get("persist.sys.wfd.nohdcp", val, NULL) && strcmp("1", val) == 0;
+    AString body;
+    if (skip_hdcp) {
+        ALOGI("sendM3() SKIP!! HDCP Authentication");
+        body = 
+            //"wfd_content_protection\r\n"
+            "wfd_video_formats\r\n"
+            "wfd_audio_codecs\r\n"
+            "wfd_client_rtp_ports\r\n";
+    } else {
+        ALOGI("sendM3() send standard request.");
+        body = 
+            "wfd_content_protection\r\n"
+            "wfd_video_formats\r\n"
+            "wfd_audio_codecs\r\n"
+            "wfd_client_rtp_ports\r\n";
+    }
 
     AString request = "GET_PARAMETER rtsp://localhost/wfd1.0 RTSP/1.0\r\n";
     AppendCommonResponse(&request, mNextCSeq);
@@ -614,41 +578,55 @@
 }
 
 status_t WifiDisplaySource::sendM4(int32_t sessionID) {
-    CHECK_EQ(sessionID, mClientSessionID);
+    // wfd_video_formats:
+    // 1 byte "native"
+    // 1 byte "preferred-display-mode-supported" 0 or 1
+    // one or more avc codec structures
+    //   1 byte profile
+    //   1 byte level
+    //   4 byte CEA mask
+    //   4 byte VESA mask
+    //   4 byte HH mask
+    //   1 byte latency
+    //   2 byte min-slice-slice
+    //   2 byte slice-enc-params
+    //   1 byte framerate-control-support
+    //   max-hres (none or 2 byte)
+    //   max-vres (none or 2 byte)
 
-    AString body;
+    CHECK_EQ(sessionID, mClientSessionID);
 
-    if (mSinkSupportsVideo) {
-        body.append("wfd_video_formats: ");
+    AString transportString = "UDP";
 
-        VideoFormats chosenVideoFormat;
-        chosenVideoFormat.disableAll();
-        chosenVideoFormat.setNativeResolution(
-                mChosenVideoResolutionType, mChosenVideoResolutionIndex);
-        chosenVideoFormat.setProfileLevel(
-                mChosenVideoResolutionType, mChosenVideoResolutionIndex,
-                mChosenVideoProfile, mChosenVideoLevel);
-
-        body.append(chosenVideoFormat.getFormatSpec(true /* forM4Message */));
-        body.append("\r\n");
-    }
-
-    if (mSinkSupportsAudio) {
-        body.append(
-                StringPrintf("wfd_audio_codecs: %s\r\n",
-                             (mUsingPCMAudio
-                                ? "LPCM 00000002 00" // 2 ch PCM 48kHz
-                                : "AAC 00000001 00")));  // 2 ch AAC 48kHz
-    }
-
-    body.append(
-            StringPrintf(
-                "wfd_presentation_URL: rtsp://%s/wfd1.0/streamid=0 none\r\n",
-                mClientInfo.mLocalIP.c_str()));
-
-    body.append(
-            StringPrintf(
-                "wfd_client_rtp_ports: %s\r\n", mWfdClientRtpPorts.c_str()));
+    char val[PROPERTY_VALUE_MAX];
+    if (property_get("media.wfd.enable-tcp", val, NULL)
+            && (!strcasecmp("true", val) || !strcmp("1", val))) {
+        ALOGI("Using TCP transport.");
+        transportString = "TCP";
+    }
+
+    // For 720p60:
+    //   use "30 00 02 02 00000040 00000000 00000000 00 0000 0000 00 none none\r\n"
+    // For 720p30:
+    //   use "28 00 02 02 00000020 00000000 00000000 00 0000 0000 00 none none\r\n"
+    // For 720p24:
+    //   use "78 00 02 02 00008000 00000000 00000000 00 0000 0000 00 none none\r\n"
+    // For 1080p30:
+    //   use "38 00 02 02 00000080 00000000 00000000 00 0000 0000 00 none none\r\n"
+    AString body = StringPrintf(
+        "wfd_video_formats: "
+#if USE_1080P
+        "38 00 02 02 00000080 00000000 00000000 00 0000 0000 00 none none\r\n"
+#else
+        "28 00 02 02 00000020 00000000 00000000 00 0000 0000 00 none none\r\n"
+#endif
+        "wfd_audio_codecs: %s\r\n"
+        "wfd_presentation_URL: rtsp://%s/wfd1.0/streamid=0 none\r\n"
+        "wfd_client_rtp_ports: RTP/AVP/%s;unicast %d 0 mode=play\r\n",
+        (mUsingPCMAudio
+            ? "LPCM 00000002 00" // 2 ch PCM 48kHz
+            : "AAC 00000001 00"),  // 2 ch AAC 48kHz
+        mClientInfo.mLocalIP.c_str(), transportString.c_str(), mChosenRTPPort);
 
     AString request = "SET_PARAMETER rtsp://localhost/wfd1.0 RTSP/1.0\r\n";
     AppendCommonResponse(&request, mNextCSeq);
@@ -740,8 +718,6 @@
 
     ++mNextCSeq;
 
-    scheduleKeepAlive(sessionID);
-
     return OK;
 }
 
@@ -813,129 +789,67 @@
         return ERROR_MALFORMED;
     }
 
-    unsigned port0 = 0, port1 = 0;
+    unsigned port0, port1;
     if (sscanf(value.c_str(),
                "RTP/AVP/UDP;unicast %u %u mode=play",
                &port0,
-               &port1) == 2
-        || sscanf(value.c_str(),
-               "RTP/AVP/TCP;unicast %u %u mode=play",
-               &port0,
-               &port1) == 2) {
-            if (port0 == 0 || port0 > 65535 || port1 != 0) {
-                ALOGE("Sink chose its wfd_client_rtp_ports poorly (%s)",
-                      value.c_str());
-
-                return ERROR_MALFORMED;
-            }
-    } else if (strcmp(value.c_str(), "RTP/AVP/TCP;interleaved mode=play")) {
-        ALOGE("Unsupported value for wfd_client_rtp_ports (%s)",
+               &port1) != 2
+        || port0 == 0 || port0 > 65535 || port1 != 0) {
+        ALOGE("Sink chose its wfd_client_rtp_ports poorly (%s)",
               value.c_str());
 
-        return ERROR_UNSUPPORTED;
+        ALOGE("onReceiveM3Response() SKIP!! port check.");
+        port0 = 19000;
+        port1 = 0;
+        //return ERROR_MALFORMED;
     }
 
-    mWfdClientRtpPorts = value;
     mChosenRTPPort = port0;
 
-    if (!params->findParameter("wfd_video_formats", &value)) {
-        ALOGE("Sink doesn't report its choice of wfd_video_formats.");
+    if (!params->findParameter("wfd_audio_codecs", &value)) {
+        ALOGE("Sink doesn't report its choice of wfd_audio_codecs.");
         return ERROR_MALFORMED;
     }
 
-    mSinkSupportsVideo = false;
-
-    if  (!(value == "none")) {
-        mSinkSupportsVideo = true;
-        if (!mSupportedSinkVideoFormats.parseFormatSpec(value.c_str())) {
-            ALOGE("Failed to parse sink provided wfd_video_formats (%s)",
-                  value.c_str());
-
-            return ERROR_MALFORMED;
-        }
-
-        if (!VideoFormats::PickBestFormat(
-                    mSupportedSinkVideoFormats,
-                    mSupportedSourceVideoFormats,
-                    &mChosenVideoResolutionType,
-                    &mChosenVideoResolutionIndex,
-                    &mChosenVideoProfile,
-                    &mChosenVideoLevel)) {
-            ALOGE("Sink and source share no commonly supported video "
-                  "formats.");
-
-            return ERROR_UNSUPPORTED;
-        }
-
-        size_t width, height, framesPerSecond;
-        bool interlaced;
-        CHECK(VideoFormats::GetConfiguration(
-                    mChosenVideoResolutionType,
-                    mChosenVideoResolutionIndex,
-                    &width,
-                    &height,
-                    &framesPerSecond,
-                    &interlaced));
-
-        ALOGI("Picked video resolution %u x %u %c%u",
-              width, height, interlaced ? 'i' : 'p', framesPerSecond);
-
-        ALOGI("Picked AVC profile %d, level %d",
-              mChosenVideoProfile, mChosenVideoLevel);
-    } else {
-        ALOGI("Sink doesn't support video at all.");
+    if  (value == "none") {
+        ALOGE("Sink doesn't support audio at all.");
+        return ERROR_UNSUPPORTED;
     }
 
-    if (!params->findParameter("wfd_audio_codecs", &value)) {
-        ALOGE("Sink doesn't report its choice of wfd_audio_codecs.");
-        return ERROR_MALFORMED;
+    if (value == "xxx") {
+        ALOGE("onReceiveM3Response() Force Apply wfd_audio_codecs to AAC");
+        value.clear();
+        value.append("LPCM 00000003 00, AAC 0000000F 00");
     }
 
-    mSinkSupportsAudio = false;
+    uint32_t modes;
+    GetAudioModes(value.c_str(), "AAC", &modes);
 
-    if  (!(value == "none")) {
-        mSinkSupportsAudio = true;
+    bool supportsAAC = (modes & 1) != 0;  // AAC 2ch 48kHz
 
-        uint32_t modes;
-        GetAudioModes(value.c_str(), "AAC", &modes);
+    GetAudioModes(value.c_str(), "LPCM", &modes);
 
-        bool supportsAAC = (modes & 1) != 0;  // AAC 2ch 48kHz
-
-        GetAudioModes(value.c_str(), "LPCM", &modes);
-
-        bool supportsPCM = (modes & 2) != 0;  // LPCM 2ch 48kHz
-
-        char val[PROPERTY_VALUE_MAX];
-        if (supportsPCM
-                && property_get("media.wfd.use-pcm-audio", val, NULL)
-                && (!strcasecmp("true", val) || !strcmp("1", val))) {
-            ALOGI("Using PCM audio.");
-            mUsingPCMAudio = true;
-        } else if (supportsAAC) {
-            ALOGI("Using AAC audio.");
-            mUsingPCMAudio = false;
-        } else if (supportsPCM) {
-            ALOGI("Using PCM audio.");
-            mUsingPCMAudio = true;
-        } else {
-            ALOGI("Sink doesn't support an audio format we do.");
-            return ERROR_UNSUPPORTED;
-        }
-    } else {
-        ALOGI("Sink doesn't support audio at all.");
-    }
+    bool supportsPCM = (modes & 2) != 0;  // LPCM 2ch 48kHz
 
-    if (!mSinkSupportsVideo && !mSinkSupportsAudio) {
-        ALOGE("Sink supports neither video nor audio...");
+    char val[PROPERTY_VALUE_MAX];
+    if (supportsPCM
+            && property_get("media.wfd.use-pcm-audio", val, NULL)
+            && (!strcasecmp("true", val) || !strcmp("1", val))) {
+        ALOGI("Using PCM audio.");
+        mUsingPCMAudio = true;
+    } else if (supportsAAC) {
+        ALOGI("Using AAC audio.");
+        mUsingPCMAudio = false;
+    } else if (supportsPCM) {
+        ALOGI("Using PCM audio.");
+        mUsingPCMAudio = true;
+    } else {
+        ALOGI("Sink doesn't support an audio format we do.");
         return ERROR_UNSUPPORTED;
     }
 
     mUsingHDCP = false;
-    char val[PROPERTY_VALUE_MAX];
-    if (property_get("persist.sys.wfd.nohdcp", val, NULL)
-            && !strcmp("1", val)) {
-        ALOGI("Content protection has been disabled for WFD sinks");
-    } else if (!params->findParameter("wfd_content_protection", &value)) {
+    if (!params->findParameter("wfd_content_protection", &value)) {
         ALOGI("Sink doesn't appear to support content protection.");
     } else if (value == "none") {
         ALOGI("Sink does not support content protection.");
@@ -1016,6 +930,8 @@
 
     if (mClientInfo.mPlaybackSession != NULL) {
         mClientInfo.mPlaybackSession->updateLiveness();
+
+        scheduleKeepAlive(sessionID);
     }
 
     return OK;
@@ -1057,6 +973,9 @@
     AString uri;
     data->getRequestField(0, &method);
 
+    ALOGI("<== <== <== onReceiveClientData() session[%d] method[%s]", sessionID, method.c_str());
+    ALOGI("[%s]", data->debugString().c_str());
+
     int32_t cseq;
     if (!data->findInt32("cseq", &cseq)) {
         sendErrorResponse(sessionID, "400 Bad Request", -1 /* cseq */);
@@ -1172,7 +1091,7 @@
         return ERROR_MALFORMED;
     }
 
-    RTPSender::TransportMode rtpMode = RTPSender::TRANSPORT_UDP;
+    Sender::TransportMode transportMode = Sender::TRANSPORT_UDP;
 
     int clientRtp, clientRtcp;
     if (transport.startsWith("RTP/AVP/TCP;")) {
@@ -1181,7 +1100,7 @@
                     transport.c_str(), "interleaved", &interleaved)
                 && sscanf(interleaved.c_str(), "%d-%d",
                           &clientRtp, &clientRtcp) == 2) {
-            rtpMode = RTPSender::TRANSPORT_TCP_INTERLEAVED;
+            transportMode = Sender::TRANSPORT_TCP_INTERLEAVED;
         } else {
             bool badRequest = false;
 
@@ -1203,7 +1122,7 @@
                 return ERROR_MALFORMED;
             }
 
-            rtpMode = RTPSender::TRANSPORT_TCP;
+            transportMode = Sender::TRANSPORT_TCP;
         }
     } else if (transport.startsWith("RTP/AVP;unicast;")
             || transport.startsWith("RTP/AVP/UDP;unicast;")) {
@@ -1245,7 +1164,7 @@
 
     sp<PlaybackSession> playbackSession =
         new PlaybackSession(
-                mNetSession, notify, mInterfaceAddr, mHDCP, mMediaPath.c_str());
+                mNetSession, notify, mInterfaceAddr, mHDCP);
 
     looper()->registerHandler(playbackSession);
 
@@ -1262,24 +1181,12 @@
         return ERROR_MALFORMED;
     }
 
-    RTPSender::TransportMode rtcpMode = RTPSender::TRANSPORT_UDP;
-    if (clientRtcp < 0) {
-        rtcpMode = RTPSender::TRANSPORT_NONE;
-    }
-
     status_t err = playbackSession->init(
             mClientInfo.mRemoteIP.c_str(),
             clientRtp,
-            rtpMode,
             clientRtcp,
-            rtcpMode,
-            mSinkSupportsAudio,
-            mUsingPCMAudio,
-            mSinkSupportsVideo,
-            mChosenVideoResolutionType,
-            mChosenVideoResolutionIndex,
-            mChosenVideoProfile,
-            mChosenVideoLevel);
+            transportMode,
+            mUsingPCMAudio);
 
     if (err != OK) {
         looper()->unregisterHandler(playbackSession->id());
@@ -1303,7 +1210,7 @@
     AString response = "RTSP/1.0 200 OK\r\n";
     AppendCommonResponse(&response, cseq, playbackSessionID);
 
-    if (rtpMode == RTPSender::TRANSPORT_TCP_INTERLEAVED) {
+    if (transportMode == Sender::TRANSPORT_TCP_INTERLEAVED) {
         response.append(
                 StringPrintf(
                     "Transport: RTP/AVP/TCP;interleaved=%d-%d;",
@@ -1312,7 +1219,7 @@
         int32_t serverRtp = playbackSession->getRTPPort();
 
         AString transportString = "UDP";
-        if (rtpMode == RTPSender::TRANSPORT_TCP) {
+        if (transportMode == Sender::TRANSPORT_TCP) {
             transportString = "TCP";
         }
 
@@ -1362,54 +1269,35 @@
         return ERROR_MALFORMED;
     }
 
-    if (mState != AWAITING_CLIENT_PLAY
-     && mState != PAUSED_TO_PLAYING
-     && mState != PAUSED) {
-        ALOGW("Received PLAY request but we're in state %d", mState);
-
-        sendErrorResponse(
-                sessionID, "455 Method Not Valid in This State", cseq);
-
-        return INVALID_OPERATION;
-    }
-
     ALOGI("Received PLAY request.");
-    if (mPlaybackSessionEstablished) {
-        finishPlay();
-    } else {
-        ALOGI("deferring PLAY request until session established.");
-    }
+
+    status_t err = playbackSession->play();
+    CHECK_EQ(err, (status_t)OK);
 
     AString response = "RTSP/1.0 200 OK\r\n";
     AppendCommonResponse(&response, cseq, playbackSessionID);
     response.append("Range: npt=now-\r\n");
     response.append("\r\n");
 
-    status_t err = mNetSession->sendRequest(sessionID, response.c_str());
+    err = mNetSession->sendRequest(sessionID, response.c_str());
 
     if (err != OK) {
         return err;
     }
 
-    if (mState == PAUSED_TO_PLAYING || mPlaybackSessionEstablished) {
+    if (mState == PAUSED_TO_PLAYING) {
         mState = PLAYING;
         return OK;
     }
 
+    playbackSession->finishPlay();
+
     CHECK_EQ(mState, AWAITING_CLIENT_PLAY);
     mState = ABOUT_TO_PLAY;
 
     return OK;
 }
 
-void WifiDisplaySource::finishPlay() {
-    const sp<PlaybackSession> &playbackSession =
-        mClientInfo.mPlaybackSession;
-
-    status_t err = playbackSession->play();
-    CHECK_EQ(err, (status_t)OK);
-}
-
 status_t WifiDisplaySource::onPauseRequest(
         int32_t sessionID,
         int32_t cseq,
@@ -1425,7 +1313,7 @@
 
     ALOGI("Received PAUSE request.");
 
-    if (mState != PLAYING_TO_PAUSED && mState != PLAYING) {
+    if (mState != PLAYING_TO_PAUSED) {
         return INVALID_OPERATION;
     }
 
@@ -1585,7 +1473,7 @@
     response->append(buf);
     response->append("\r\n");
 
-    response->append(StringPrintf("Server: %s\r\n", sUserAgent.c_str()));
+    response->append("Server: Mine/1.0\r\n");
 
     if (cseq >= 0) {
         response->append(StringPrintf("CSeq: %d\r\n", cseq));
@@ -1695,13 +1583,10 @@
 status_t WifiDisplaySource::makeHDCP() {
     sp<IServiceManager> sm = defaultServiceManager();
     sp<IBinder> binder = sm->getService(String16("media.player"));
-
-    sp<IMediaPlayerService> service =
-        interface_cast<IMediaPlayerService>(binder);
-
+    sp<IMediaPlayerService> service = interface_cast<IMediaPlayerService>(binder);
     CHECK(service != NULL);
 
-    mHDCP = service->makeHDCP(true /* createEncryptionModule */);
+    mHDCP = service->makeHDCP();
 
     if (mHDCP == NULL) {
         return ERROR_UNSUPPORTED;
diff -Naur a/frameworks/av/media/libstagefright/wifi-display/source/WifiDisplaySource.h b/frameworks/av/media/libstagefright/wifi-display/source/WifiDisplaySource.h
--- a/frameworks/av/media/libstagefright/wifi-display/source/WifiDisplaySource.h	2014-03-23 23:08:08.443581000 -0400
+++ b/frameworks/av/media/libstagefright/wifi-display/source/WifiDisplaySource.h	2014-03-24 10:11:27.244407723 -0400
@@ -30,6 +30,7 @@
 struct IHDCP;
 struct IRemoteDisplayClient;
 struct ParsedMessage;
+struct TimeSyncer;
 
 // Represents the RTSP server acting as a wifi display source.
 // Manages incoming connections, sets up Playback sessions as necessary.
@@ -82,6 +83,7 @@
         kWhatHDCPNotify,
         kWhatFinishStop2,
         kWhatTeardownTriggerTimedOut,
+        kWhatTimeSyncerNotify,
     };
 
     struct ResponseID {
@@ -118,6 +120,7 @@
     sp<ANetworkSession> mNetSession;
     sp<IRemoteDisplayClient> mClient;
     AString mMediaPath;
+    sp<TimeSyncer> mTimeSyncer;
     struct in_addr mInterfaceAddr;
     int32_t mSessionID;
 
diff -Naur a/frameworks/av/media/libstagefright/wifi-display/TimeSyncer.cpp b/frameworks/av/media/libstagefright/wifi-display/TimeSyncer.cpp
--- a/frameworks/av/media/libstagefright/wifi-display/TimeSyncer.cpp	1969-12-31 19:00:00.000000000 -0500
+++ b/frameworks/av/media/libstagefright/wifi-display/TimeSyncer.cpp	2014-03-24 09:54:23.140386455 -0400
@@ -0,0 +1,337 @@
+/*
+ * Copyright 2013, The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+//#define LOG_NEBUG 0
+#define LOG_TAG "TimeSyncer"
+#include <utils/Log.h>
+
+#include "TimeSyncer.h"
+
+#include <media/stagefright/foundation/ABuffer.h>
+#include <media/stagefright/foundation/ADebug.h>
+#include <media/stagefright/foundation/AHandler.h>
+#include <media/stagefright/foundation/ALooper.h>
+#include <media/stagefright/foundation/AMessage.h>
+#include <media/stagefright/foundation/ANetworkSession.h>
+#include <media/stagefright/Utils.h>
+
+namespace android {
+
+TimeSyncer::TimeSyncer(
+        const sp<ANetworkSession> &netSession, const sp<AMessage> &notify)
+    : mNetSession(netSession),
+      mNotify(notify),
+      mIsServer(false),
+      mConnected(false),
+      mUDPSession(0),
+      mSeqNo(0),
+      mTotalTimeUs(0.0),
+      mPendingT1(0ll),
+      mTimeoutGeneration(0) {
+}
+
+TimeSyncer::~TimeSyncer() {
+}
+
+void TimeSyncer::startServer(unsigned localPort) {
+    sp<AMessage> msg = new AMessage(kWhatStartServer, id());
+    msg->setInt32("localPort", localPort);
+    msg->post();
+}
+
+void TimeSyncer::startClient(const char *remoteHost, unsigned remotePort) {
+    sp<AMessage> msg = new AMessage(kWhatStartClient, id());
+    msg->setString("remoteHost", remoteHost);
+    msg->setInt32("remotePort", remotePort);
+    msg->post();
+}
+
+void TimeSyncer::onMessageReceived(const sp<AMessage> &msg) {
+    switch (msg->what()) {
+        case kWhatStartClient:
+        {
+            AString remoteHost;
+            CHECK(msg->findString("remoteHost", &remoteHost));
+
+            int32_t remotePort;
+            CHECK(msg->findInt32("remotePort", &remotePort));
+
+            sp<AMessage> notify = new AMessage(kWhatUDPNotify, id());
+
+            CHECK_EQ((status_t)OK,
+                     mNetSession->createUDPSession(
+                         0 /* localPort */,
+                         remoteHost.c_str(),
+                         remotePort,
+                         notify,
+                         &mUDPSession));
+
+            postSendPacket();
+            break;
+        }
+
+        case kWhatStartServer:
+        {
+            mIsServer = true;
+
+            int32_t localPort;
+            CHECK(msg->findInt32("localPort", &localPort));
+
+            sp<AMessage> notify = new AMessage(kWhatUDPNotify, id());
+
+            CHECK_EQ((status_t)OK,
+                     mNetSession->createUDPSession(
+                         localPort, notify, &mUDPSession));
+
+            break;
+        }
+
+        case kWhatSendPacket:
+        {
+            if (mHistory.size() == 0) {
+                ALOGI("starting batch");
+            }
+
+            TimeInfo ti;
+            memset(&ti, 0, sizeof(ti));
+
+            ti.mT1 = ALooper::GetNowUs();
+
+            CHECK_EQ((status_t)OK,
+                     mNetSession->sendRequest(
+                         mUDPSession, &ti, sizeof(ti)));
+
+            mPendingT1 = ti.mT1;
+            postTimeout();
+            break;
+        }
+
+        case kWhatTimedOut:
+        {
+            int32_t generation;
+            CHECK(msg->findInt32("generation", &generation));
+
+            if (generation != mTimeoutGeneration) {
+                break;
+            }
+
+            ALOGI("timed out, sending another request");
+            postSendPacket();
+            break;
+        }
+
+        case kWhatUDPNotify:
+        {
+            int32_t reason;
+            CHECK(msg->findInt32("reason", &reason));
+
+            switch (reason) {
+                case ANetworkSession::kWhatError:
+                {
+                    int32_t sessionID;
+                    CHECK(msg->findInt32("sessionID", &sessionID));
+
+                    int32_t err;
+                    CHECK(msg->findInt32("err", &err));
+
+                    AString detail;
+                    CHECK(msg->findString("detail", &detail));
+
+                    ALOGE("An error occurred in session %d (%d, '%s/%s').",
+                          sessionID,
+                          err,
+                          detail.c_str(),
+                          strerror(-err));
+
+                    mNetSession->destroySession(sessionID);
+
+                    cancelTimeout();
+
+                    notifyError(err);
+                    break;
+                }
+
+                case ANetworkSession::kWhatDatagram:
+                {
+                    int32_t sessionID;
+                    CHECK(msg->findInt32("sessionID", &sessionID));
+
+                    sp<ABuffer> packet;
+                    CHECK(msg->findBuffer("data", &packet));
+
+                    int64_t arrivalTimeUs;
+                    CHECK(packet->meta()->findInt64(
+                                "arrivalTimeUs", &arrivalTimeUs));
+
+                    CHECK_EQ(packet->size(), sizeof(TimeInfo));
+
+                    TimeInfo *ti = (TimeInfo *)packet->data();
+
+                    if (mIsServer) {
+                        if (!mConnected) {
+                            AString fromAddr;
+                            CHECK(msg->findString("fromAddr", &fromAddr));
+
+                            int32_t fromPort;
+                            CHECK(msg->findInt32("fromPort", &fromPort));
+
+                            CHECK_EQ((status_t)OK,
+                                     mNetSession->connectUDPSession(
+                                         mUDPSession, fromAddr.c_str(), fromPort));
+
+                            mConnected = true;
+                        }
+
+                        ti->mT2 = arrivalTimeUs;
+                        ti->mT3 = ALooper::GetNowUs();
+
+                        CHECK_EQ((status_t)OK,
+                                 mNetSession->sendRequest(
+                                     mUDPSession, ti, sizeof(*ti)));
+                    } else {
+                        if (ti->mT1 != mPendingT1) {
+                            break;
+                        }
+
+                        cancelTimeout();
+                        mPendingT1 = 0;
+
+                        ti->mT4 = arrivalTimeUs;
+
+                        // One way delay for a packet to travel from client
+                        // to server or back (assumed to be the same either way).
+                        int64_t delay =
+                            (ti->mT2 - ti->mT1 + ti->mT4 - ti->mT3) / 2;
+
+                        // Offset between the client clock (T1, T4) and the
+                        // server clock (T2, T3) timestamps.
+                        int64_t offset =
+                            (ti->mT2 - ti->mT1 - ti->mT4 + ti->mT3) / 2;
+
+                        mHistory.push_back(*ti);
+
+                        ALOGV("delay = %lld us,\toffset %lld us",
+                               delay,
+                               offset);
+
+                        if (mHistory.size() < kNumPacketsPerBatch) {
+                            postSendPacket(1000000ll / 30);
+                        } else {
+                            notifyOffset();
+
+                            ALOGI("batch done");
+
+                            mHistory.clear();
+                            postSendPacket(kBatchDelayUs);
+                        }
+                    }
+                    break;
+                }
+
+                default:
+                    TRESPASS();
+            }
+
+            break;
+        }
+
+        default:
+            TRESPASS();
+    }
+}
+
+void TimeSyncer::postSendPacket(int64_t delayUs) {
+    (new AMessage(kWhatSendPacket, id()))->post(delayUs);
+}
+
+void TimeSyncer::postTimeout() {
+    sp<AMessage> msg = new AMessage(kWhatTimedOut, id());
+    msg->setInt32("generation", mTimeoutGeneration);
+    msg->post(kTimeoutDelayUs);
+}
+
+void TimeSyncer::cancelTimeout() {
+    ++mTimeoutGeneration;
+}
+
+void TimeSyncer::notifyError(status_t err) {
+    if (mNotify == NULL) {
+        looper()->stop();
+        return;
+    }
+
+    sp<AMessage> notify = mNotify->dup();
+    notify->setInt32("what", kWhatError);
+    notify->setInt32("err", err);
+    notify->post();
+}
+
+// static
+int TimeSyncer::CompareRountripTime(const TimeInfo *ti1, const TimeInfo *ti2) {
+    int64_t rt1 = ti1->mT4 - ti1->mT1;
+    int64_t rt2 = ti2->mT4 - ti2->mT1;
+
+    if (rt1 < rt2) {
+        return -1;
+    } else if (rt1 > rt2) {
+        return 1;
+    }
+
+    return 0;
+}
+
+void TimeSyncer::notifyOffset() {
+    mHistory.sort(CompareRountripTime);
+
+    int64_t sum = 0ll;
+    size_t count = 0;
+
+    // Only consider the third of the information associated with the best
+    // (smallest) roundtrip times.
+    for (size_t i = 0; i < mHistory.size() / 3; ++i) {
+        const TimeInfo *ti = &mHistory[i];
+
+#if 0
+        // One way delay for a packet to travel from client
+        // to server or back (assumed to be the same either way).
+        int64_t delay =
+            (ti->mT2 - ti->mT1 + ti->mT4 - ti->mT3) / 2;
+#endif
+
+        // Offset between the client clock (T1, T4) and the
+        // server clock (T2, T3) timestamps.
+        int64_t offset =
+            (ti->mT2 - ti->mT1 - ti->mT4 + ti->mT3) / 2;
+
+        ALOGV("(%d) RT: %lld us, offset: %lld us",
+              i, ti->mT4 - ti->mT1, offset);
+
+        sum += offset;
+        ++count;
+    }
+
+    if (mNotify == NULL) {
+        ALOGI("avg. offset is %lld", sum / count);
+        return;
+    }
+
+    sp<AMessage> notify = mNotify->dup();
+    notify->setInt32("what", kWhatTimeOffset);
+    notify->setInt64("offset", sum / count);
+    notify->post();
+}
+
+}  // namespace android
diff -Naur a/frameworks/av/media/libstagefright/wifi-display/TimeSyncer.h b/frameworks/av/media/libstagefright/wifi-display/TimeSyncer.h
--- a/frameworks/av/media/libstagefright/wifi-display/TimeSyncer.h	1969-12-31 19:00:00.000000000 -0500
+++ b/frameworks/av/media/libstagefright/wifi-display/TimeSyncer.h	2014-03-24 09:55:09.232387412 -0400
@@ -0,0 +1,109 @@
+/*
+ * Copyright 2013, The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#ifndef TIME_SYNCER_H_
+
+#define TIME_SYNCER_H_
+
+#include <media/stagefright/foundation/AHandler.h>
+
+namespace android {
+
+struct ANetworkSession;
+
+/*
+   TimeSyncer allows us to synchronize time between a client and a server.
+   The client sends a UDP packet containing its send-time to the server,
+   the server sends that packet back to the client amended with information
+   about when it was received as well as the time the reply was sent back.
+   Finally the client receives the reply and has now enough information to
+   compute the clock offset between client and server assuming that packet
+   exchange is symmetric, i.e. time for a packet client->server and
+   server->client is roughly equal.
+   This exchange is repeated a number of times and the average offset computed
+   over the 30% of packets that had the lowest roundtrip times.
+   The offset is determined every 10 secs to account for slight differences in
+   clock frequency.
+*/
+struct TimeSyncer : public AHandler {
+    enum {
+        kWhatError,
+        kWhatTimeOffset,
+    };
+    TimeSyncer(
+            const sp<ANetworkSession> &netSession,
+            const sp<AMessage> &notify);
+
+    void startServer(unsigned localPort);
+    void startClient(const char *remoteHost, unsigned remotePort);
+
+protected:
+    virtual ~TimeSyncer();
+
+    virtual void onMessageReceived(const sp<AMessage> &msg);
+
+private:
+    enum {
+        kWhatStartServer,
+        kWhatStartClient,
+        kWhatUDPNotify,
+        kWhatSendPacket,
+        kWhatTimedOut,
+    };
+
+    struct TimeInfo {
+        int64_t mT1;  // client timestamp at send
+        int64_t mT2;  // server timestamp at receive
+        int64_t mT3;  // server timestamp at send
+        int64_t mT4;  // client timestamp at receive
+    };
+
+    enum {
+        kNumPacketsPerBatch = 30,
+    };
+    static const int64_t kTimeoutDelayUs = 500000ll;
+    static const int64_t kBatchDelayUs = 60000000ll;  // every minute
+
+    sp<ANetworkSession> mNetSession;
+    sp<AMessage> mNotify;
+
+    bool mIsServer;
+    bool mConnected;
+    int32_t mUDPSession;
+    uint32_t mSeqNo;
+    double mTotalTimeUs;
+
+    Vector<TimeInfo> mHistory;
+
+    int64_t mPendingT1;
+    int32_t mTimeoutGeneration;
+
+    void postSendPacket(int64_t delayUs = 0ll);
+
+    void postTimeout();
+    void cancelTimeout();
+
+    void notifyError(status_t err);
+    void notifyOffset();
+
+    static int CompareRountripTime(const TimeInfo *ti1, const TimeInfo *ti2);
+
+    DISALLOW_EVIL_CONSTRUCTORS(TimeSyncer);
+};
+
+}  // namespace android
+
+#endif  // TIME_SYNCER_H_
diff -Naur a/frameworks/av/media/libstagefright/wifi-display/wfd.cpp b/frameworks/av/media/libstagefright/wifi-display/wfd.cpp
--- a/frameworks/av/media/libstagefright/wifi-display/wfd.cpp	1969-12-31 19:00:00.000000000 -0500
+++ b/frameworks/av/media/libstagefright/wifi-display/wfd.cpp	2014-03-24 10:24:32.124424023 -0400
@@ -0,0 +1,269 @@
+/*
+ * Copyright 2012, The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+//#define LOG_NDEBUG 0
+#define LOG_TAG "wfd"
+#include <utils/Log.h>
+
+#include "source/WifiDisplaySource.h"
+
+#include <binder/ProcessState.h>
+#include <binder/IServiceManager.h>
+#include <gui/ISurfaceComposer.h>
+#include <gui/SurfaceComposerClient.h>
+#include <media/AudioSystem.h>
+#include <media/IMediaPlayerService.h>
+#include <media/IRemoteDisplay.h>
+#include <media/IRemoteDisplayClient.h>
+#include <media/stagefright/DataSource.h>
+#include <media/stagefright/foundation/ADebug.h>
+#include <media/stagefright/foundation/AMessage.h>
+#include <ui/DisplayInfo.h>
+
+namespace android {
+
+static void usage(const char *me) {
+    fprintf(stderr,
+            "usage:\n"
+            "           %s -l iface[:port]\tcreate a wifi display source\n"
+            "               -f(ilename)  \tstream media\n",
+            me);
+}
+
+struct RemoteDisplayClient : public BnRemoteDisplayClient {
+    RemoteDisplayClient();
+
+    virtual void onDisplayConnected(
+            const sp<IGraphicBufferProducer> &bufferProducer,
+            uint32_t width,
+            uint32_t height,
+            uint32_t flags);
+
+    virtual void onDisplayDisconnected();
+    virtual void onDisplayError(int32_t error);
+
+    void waitUntilDone();
+
+protected:
+    virtual ~RemoteDisplayClient();
+
+private:
+    Mutex mLock;
+    Condition mCondition;
+
+    bool mDone;
+
+    sp<SurfaceComposerClient> mComposerClient;
+    sp<IGraphicBufferProducer> mSurfaceTexture;
+    sp<IBinder> mDisplayBinder;
+
+    DISALLOW_EVIL_CONSTRUCTORS(RemoteDisplayClient);
+};
+
+RemoteDisplayClient::RemoteDisplayClient()
+    : mDone(false) {
+    mComposerClient = new SurfaceComposerClient;
+    CHECK_EQ(mComposerClient->initCheck(), (status_t)OK);
+}
+
+RemoteDisplayClient::~RemoteDisplayClient() {
+}
+
+void RemoteDisplayClient::onDisplayConnected(
+        const sp<IGraphicBufferProducer> &bufferProducer,
+        uint32_t width,
+        uint32_t height,
+        uint32_t flags) {
+    ALOGI("onDisplayConnected width=%u, height=%u, flags = 0x%08x",
+          width, height, flags);
+
+    if (bufferProducer != NULL) {
+        mSurfaceTexture = bufferProducer;
+        mDisplayBinder = mComposerClient->createDisplay(
+                String8("foo"), false /* secure */);
+
+        SurfaceComposerClient::openGlobalTransaction();
+        mComposerClient->setDisplaySurface(mDisplayBinder, mSurfaceTexture);
+
+        Rect layerStackRect(1280, 720);  // XXX fix this.
+        Rect displayRect(1280, 720);
+
+        mComposerClient->setDisplayProjection(
+                mDisplayBinder, 0 /* 0 degree rotation */,
+                layerStackRect,
+                displayRect);
+
+        SurfaceComposerClient::closeGlobalTransaction();
+    }
+}
+
+void RemoteDisplayClient::onDisplayDisconnected() {
+    ALOGI("onDisplayDisconnected");
+
+    Mutex::Autolock autoLock(mLock);
+    mDone = true;
+    mCondition.broadcast();
+}
+
+void RemoteDisplayClient::onDisplayError(int32_t error) {
+    ALOGI("onDisplayError error=%d", error);
+
+    Mutex::Autolock autoLock(mLock);
+    mDone = true;
+    mCondition.broadcast();
+}
+
+void RemoteDisplayClient::waitUntilDone() {
+    Mutex::Autolock autoLock(mLock);
+    while (!mDone) {
+        mCondition.wait(mLock);
+    }
+}
+
+static status_t enableAudioSubmix(bool enable) {
+    status_t err = AudioSystem::setDeviceConnectionState(
+            AUDIO_DEVICE_IN_REMOTE_SUBMIX,
+            enable
+                ? AUDIO_POLICY_DEVICE_STATE_AVAILABLE
+                : AUDIO_POLICY_DEVICE_STATE_UNAVAILABLE,
+            NULL /* device_address */);
+
+    if (err != OK) {
+        return err;
+    }
+
+    err = AudioSystem::setDeviceConnectionState(
+            AUDIO_DEVICE_OUT_REMOTE_SUBMIX,
+            enable
+                ? AUDIO_POLICY_DEVICE_STATE_AVAILABLE
+                : AUDIO_POLICY_DEVICE_STATE_UNAVAILABLE,
+            NULL /* device_address */);
+
+    return err;
+}
+
+static void createSource(const AString &addr, int32_t port) {
+    sp<IServiceManager> sm = defaultServiceManager();
+    sp<IBinder> binder = sm->getService(String16("media.player"));
+    sp<IMediaPlayerService> service =
+        interface_cast<IMediaPlayerService>(binder);
+
+    CHECK(service.get() != NULL);
+
+    enableAudioSubmix(true /* enable */);
+
+    String8 iface;
+    iface.append(addr.c_str());
+    iface.append(StringPrintf(":%d", port).c_str());
+
+    sp<RemoteDisplayClient> client = new RemoteDisplayClient;
+    sp<IRemoteDisplay> display = service->listenForRemoteDisplay(client, iface);
+
+    client->waitUntilDone();
+
+    display->dispose();
+    display.clear();
+
+    enableAudioSubmix(false /* enable */);
+}
+
+static void createFileSource(
+        const AString &addr, int32_t port, const char *path) {
+    sp<ANetworkSession> session = new ANetworkSession;
+    session->start();
+
+    sp<ALooper> looper = new ALooper;
+    looper->start();
+
+    sp<RemoteDisplayClient> client = new RemoteDisplayClient;
+    sp<WifiDisplaySource> source = new WifiDisplaySource(session, client, path);
+    looper->registerHandler(source);
+
+    AString iface = StringPrintf("%s:%d", addr.c_str(), port);
+    CHECK_EQ((status_t)OK, source->start(iface.c_str()));
+
+    client->waitUntilDone();
+
+    source->stop();
+}
+
+}  // namespace android
+
+int main(int argc, char **argv) {
+    using namespace android;
+
+    ProcessState::self()->startThreadPool();
+
+    DataSource::RegisterDefaultSniffers();
+
+    AString listenOnAddr;
+    int32_t listenOnPort = -1;
+
+    AString path;
+
+    int res;
+    while ((res = getopt(argc, argv, "hl:f:")) >= 0) {
+        switch (res) {
+            case 'f':
+            {
+                path = optarg;
+                break;
+            }
+
+            case 'l':
+            {
+                const char *colonPos = strrchr(optarg, ':');
+
+                if (colonPos == NULL) {
+                    listenOnAddr = optarg;
+                    listenOnPort = WifiDisplaySource::kWifiDisplayDefaultPort;
+                } else {
+                    listenOnAddr.setTo(optarg, colonPos - optarg);
+
+                    char *end;
+                    listenOnPort = strtol(colonPos + 1, &end, 10);
+
+                    if (*end != '\0' || end == colonPos + 1
+                            || listenOnPort < 1 || listenOnPort > 65535) {
+                        fprintf(stderr, "Illegal port specified.\n");
+                        exit(1);
+                    }
+                }
+                break;
+            }
+
+            case '?':
+            case 'h':
+            default:
+                usage(argv[0]);
+                exit(1);
+        }
+    }
+
+    if (listenOnPort >= 0) {
+        if (path.empty()) {
+            createSource(listenOnAddr, listenOnPort);
+        } else {
+            createFileSource(listenOnAddr, listenOnPort, path.c_str());
+        }
+
+        exit(0);
+    }
+
+    usage(argv[0]);
+
+    return 0;
+}
diff -Naur a/frameworks/base/services/java/com/android/server/display/WifiDisplayController.java b/frameworks/base/services/java/com/android/server/display/WifiDisplayController.java
--- a/frameworks/base/services/java/com/android/server/display/WifiDisplayController.java	2014-03-23 23:09:13.723582000 -0400
+++ b/frameworks/base/services/java/com/android/server/display/WifiDisplayController.java	2013-08-14 04:13:30.000000000 -0400
@@ -25,8 +25,8 @@
 import android.content.IntentFilter;
 import android.database.ContentObserver;
 import android.hardware.display.WifiDisplay;
-import android.hardware.display.WifiDisplaySessionInfo;
 import android.hardware.display.WifiDisplayStatus;
+import android.media.AudioManager;
 import android.media.RemoteDisplay;
 import android.net.NetworkInfo;
 import android.net.Uri;
@@ -42,6 +42,7 @@
 import android.net.wifi.p2p.WifiP2pManager.GroupInfoListener;
 import android.net.wifi.p2p.WifiP2pManager.PeerListListener;
 import android.os.Handler;
+import android.os.SystemProperties;
 import android.provider.Settings;
 import android.util.Slog;
 import android.view.Surface;
@@ -74,23 +75,20 @@
 
     private static final int DEFAULT_CONTROL_PORT = 7236;
     private static final int MAX_THROUGHPUT = 50;
-    private static final int CONNECTION_TIMEOUT_SECONDS = 30;
-    private static final int RTSP_TIMEOUT_SECONDS = 30;
-    private static final int RTSP_TIMEOUT_SECONDS_CERT_MODE = 120;
-
-    // We repeatedly issue calls to discover peers every so often for a few reasons.
-    // 1. The initial request may fail and need to retried.
-    // 2. Discovery will self-abort after any group is initiated, which may not necessarily
-    //    be what we want to have happen.
-    // 3. Discovery will self-timeout after 2 minutes, whereas we want discovery to
-    //    be occur for as long as a client is requesting it be.
-    // 4. We don't seem to get updated results for displays we've already found until
-    //    we ask to discover again, particularly for the isSessionAvailable() property.
-    private static final int DISCOVER_PEERS_INTERVAL_MILLIS = 10000;
+    private static final int CONNECTION_TIMEOUT_SECONDS = 60;
+    private static final int RTSP_TIMEOUT_SECONDS = 15;
+
+    private static final int DISCOVER_PEERS_MAX_RETRIES = 10;
+    private static final int DISCOVER_PEERS_RETRY_DELAY_MILLIS = 500;
 
     private static final int CONNECT_MAX_RETRIES = 3;
     private static final int CONNECT_RETRY_DELAY_MILLIS = 500;
 
+    // A unique token to identify the remote submix that is managed by Wifi display.
+    // It must match what the media server uses when it starts recording the submix
+    // for transmission.  We use 0 although the actual value is currently ignored.
+    private static final int REMOTE_SUBMIX_ADDRESS = 0;
+
     private final Context mContext;
     private final Handler mHandler;
     private final Listener mListener;
@@ -98,6 +96,8 @@
     private final WifiP2pManager mWifiP2pManager;
     private final Channel mWifiP2pChannel;
 
+    private final AudioManager mAudioManager;
+
     private boolean mWifiP2pEnabled;
     private boolean mWfdEnabled;
     private boolean mWfdEnabling;
@@ -109,12 +109,12 @@
     // True if Wifi display is enabled by the user.
     private boolean mWifiDisplayOnSetting;
 
-    // True if a scan was requested independent of whether one is actually in progress.
-    private boolean mScanRequested;
-
     // True if there is a call to discoverPeers in progress.
     private boolean mDiscoverPeersInProgress;
 
+    // Number of discover peers retries remaining.
+    private int mDiscoverPeersRetriesLeft;
+
     // The device to which we want to connect, or null if we want to be disconnected.
     private WifiP2pDevice mDesiredDevice;
 
@@ -137,10 +137,6 @@
     // Number of connection retries remaining.
     private int mConnectionRetriesLeft;
 
-    // The Extended remote display that is listening on the connection.
-    // Created after the Wifi P2P network is connected.
-    private Object mExtRemoteDisplay;
-
     // The remote display that is listening on the connection.
     // Created after the Wifi P2P network is connected.
     private RemoteDisplay mRemoteDisplay;
@@ -151,6 +147,9 @@
     // True if RTSP has connected.
     private boolean mRemoteDisplayConnected;
 
+    // True if the remote submix is enabled.
+    private boolean mRemoteSubmixOn;
+
     // The information we have most recently told WifiDisplayAdapter about.
     private WifiDisplay mAdvertisedDisplay;
     private Surface mAdvertisedDisplaySurface;
@@ -158,12 +157,6 @@
     private int mAdvertisedDisplayHeight;
     private int mAdvertisedDisplayFlags;
 
-    // Certification
-    private boolean mWifiDisplayCertMode;
-    private int mWifiDisplayWpsConfig = WpsInfo.INVALID;
-
-    private WifiP2pDevice mThisDevice;
-
     public WifiDisplayController(Context context, Handler handler, Listener listener) {
         mContext = context;
         mHandler = handler;
@@ -172,11 +165,12 @@
         mWifiP2pManager = (WifiP2pManager)context.getSystemService(Context.WIFI_P2P_SERVICE);
         mWifiP2pChannel = mWifiP2pManager.initialize(context, handler.getLooper(), null);
 
+        mAudioManager = (AudioManager)context.getSystemService(Context.AUDIO_SERVICE);
+
         IntentFilter intentFilter = new IntentFilter();
         intentFilter.addAction(WifiP2pManager.WIFI_P2P_STATE_CHANGED_ACTION);
         intentFilter.addAction(WifiP2pManager.WIFI_P2P_PEERS_CHANGED_ACTION);
         intentFilter.addAction(WifiP2pManager.WIFI_P2P_CONNECTION_CHANGED_ACTION);
-        intentFilter.addAction(WifiP2pManager.WIFI_P2P_THIS_DEVICE_CHANGED_ACTION);
         context.registerReceiver(mWifiP2pReceiver, intentFilter, null, mHandler);
 
         ContentObserver settingsObserver = new ContentObserver(mHandler) {
@@ -189,10 +183,6 @@
         final ContentResolver resolver = mContext.getContentResolver();
         resolver.registerContentObserver(Settings.Global.getUriFor(
                 Settings.Global.WIFI_DISPLAY_ON), false, settingsObserver);
-        resolver.registerContentObserver(Settings.Global.getUriFor(
-                Settings.Global.WIFI_DISPLAY_CERTIFICATION_ON), false, settingsObserver);
-        resolver.registerContentObserver(Settings.Global.getUriFor(
-                Settings.Global.WIFI_DISPLAY_WPS_CONFIG), false, settingsObserver);
         updateSettings();
     }
 
@@ -200,14 +190,6 @@
         final ContentResolver resolver = mContext.getContentResolver();
         mWifiDisplayOnSetting = Settings.Global.getInt(resolver,
                 Settings.Global.WIFI_DISPLAY_ON, 0) != 0;
-        mWifiDisplayCertMode = Settings.Global.getInt(resolver,
-                Settings.Global.WIFI_DISPLAY_CERTIFICATION_ON, 0) != 0;
-
-        mWifiDisplayWpsConfig = WpsInfo.INVALID;
-        if (mWifiDisplayCertMode) {
-            mWifiDisplayWpsConfig = Settings.Global.getInt(resolver,
-                  Settings.Global.WIFI_DISPLAY_WPS_CONFIG, WpsInfo.INVALID);
-        }
 
         updateWfdEnableState();
     }
@@ -219,8 +201,8 @@
         pw.println("mWfdEnabled=" + mWfdEnabled);
         pw.println("mWfdEnabling=" + mWfdEnabling);
         pw.println("mNetworkInfo=" + mNetworkInfo);
-        pw.println("mScanRequested=" + mScanRequested);
         pw.println("mDiscoverPeersInProgress=" + mDiscoverPeersInProgress);
+        pw.println("mDiscoverPeersRetriesLeft=" + mDiscoverPeersRetriesLeft);
         pw.println("mDesiredDevice=" + describeWifiP2pDevice(mDesiredDevice));
         pw.println("mConnectingDisplay=" + describeWifiP2pDevice(mConnectingDevice));
         pw.println("mDisconnectingDisplay=" + describeWifiP2pDevice(mDisconnectingDevice));
@@ -230,6 +212,7 @@
         pw.println("mRemoteDisplay=" + mRemoteDisplay);
         pw.println("mRemoteDisplayInterface=" + mRemoteDisplayInterface);
         pw.println("mRemoteDisplayConnected=" + mRemoteDisplayConnected);
+        pw.println("mRemoteSubmixOn=" + mRemoteSubmixOn);
         pw.println("mAdvertisedDisplay=" + mAdvertisedDisplay);
         pw.println("mAdvertisedDisplaySurface=" + mAdvertisedDisplaySurface);
         pw.println("mAdvertisedDisplayWidth=" + mAdvertisedDisplayWidth);
@@ -242,38 +225,59 @@
         }
     }
 
-    public void requestStartScan() {
-        if (!mScanRequested) {
-            mScanRequested = true;
-            updateScanState();
-        }
-    }
-
-    public void requestStopScan() {
-        if (mScanRequested) {
-            mScanRequested = false;
-            updateScanState();
-        }
+    public void requestScan() {
+        discoverPeers();
     }
 
     public void requestConnect(String address) {
         for (WifiP2pDevice device : mAvailableWifiDisplayPeers) {
             if (device.deviceAddress.equals(address)) {
                 connect(device);
+                Slog.d(TAG, "requestConnect()[p2p] " + device);
+                return;
             }
         }
-    }
 
-    public void requestPause() {
-        if (mRemoteDisplay != null) {
-            mRemoteDisplay.pause();
-        }
+        listenWiFiDisplay(address);
     }
 
-    public void requestResume() {
-        if (mRemoteDisplay != null) {
-            mRemoteDisplay.resume();
-        }
+    private void listenWiFiDisplay(final String ipaddr_port) {
+        Slog.d(TAG, "listenWiFiDisplay()[wifi] " + ipaddr_port);
+        setRemoteSubmixOn(false);
+        unadvertiseDisplay();
+
+        final String iface = ipaddr_port;
+        mRemoteDisplayInterface = iface;
+        setRemoteSubmixOn(true);
+
+        Slog.i(TAG, "Listening for RTSP connection on " + iface + " from Wifi display Sink");
+        mRemoteDisplay = RemoteDisplay.listen(iface, new RemoteDisplay.Listener() {
+            @Override
+            public void onDisplayConnected(Surface surface, int width, int height, int flags) {
+                Slog.i(TAG, "listenWiFiDisplay() onDisplayConnected()");
+                mRemoteDisplayConnected = true;
+                mHandler.removeCallbacks(mRtspTimeout);
+                advertiseDisplay(new WifiDisplay(ipaddr_port, "Sink", null), surface, width, height, flags);
+            }
+
+            @Override
+            public void onDisplayDisconnected() {
+                Slog.i(TAG, "listenWiFiDisplay() onDisplayDisconnected()");
+                mHandler.removeCallbacks(mRtspTimeout);
+                disconnect();
+                unadvertiseDisplay();
+            }
+
+            @Override
+            public void onDisplayError(int error) {
+                Slog.i(TAG, "listenWiFiDisplay() onDisplayError()");
+                mHandler.removeCallbacks(mRtspTimeout);
+                handleConnectionFailure(false);
+                unadvertiseDisplay();
+            }
+        }, mHandler);
+
+        mHandler.postDelayed(mRtspTimeout, RTSP_TIMEOUT_SECONDS * 1000);
     }
 
     public void requestDisconnect() {
@@ -288,7 +292,10 @@
 
                 WifiP2pWfdInfo wfdInfo = new WifiP2pWfdInfo();
                 wfdInfo.setWfdEnabled(true);
-                wfdInfo.setDeviceType(WifiP2pWfdInfo.WFD_SOURCE);
+
+//                wfdInfo.setDeviceType(WifiP2pWfdInfo.WFD_SOURCE);
+                wfdInfo.setDeviceType(WifiP2pWfdInfo.SOURCE_OR_PRIMARY_SINK);
+
                 wfdInfo.setSessionAvailable(true);
                 wfdInfo.setControlPort(DEFAULT_CONTROL_PORT);
                 wfdInfo.setMaxThroughput(MAX_THROUGHPUT);
@@ -302,7 +309,6 @@
                             mWfdEnabling = false;
                             mWfdEnabled = true;
                             reportFeatureState();
-                            updateScanState();
                         }
                     }
 
@@ -317,29 +323,9 @@
             }
         } else {
             // WFD should be disabled.
-            if (mWfdEnabled || mWfdEnabling) {
-                WifiP2pWfdInfo wfdInfo = new WifiP2pWfdInfo();
-                wfdInfo.setWfdEnabled(false);
-                mWifiP2pManager.setWFDInfo(mWifiP2pChannel, wfdInfo, new ActionListener() {
-                    @Override
-                    public void onSuccess() {
-                        if (DEBUG) {
-                            Slog.d(TAG, "Successfully set WFD info.");
-                        }
-                    }
-
-                    @Override
-                    public void onFailure(int reason) {
-                        if (DEBUG) {
-                            Slog.d(TAG, "Failed to set WFD info with reason " + reason + ".");
-                        }
-                    }
-                });
-            }
             mWfdEnabling = false;
             mWfdEnabled = false;
             reportFeatureState();
-            updateScanState();
             disconnect();
         }
     }
@@ -362,29 +348,12 @@
                 WifiDisplayStatus.FEATURE_STATE_OFF;
     }
 
-    private void updateScanState() {
-        if (mScanRequested && mWfdEnabled && mDesiredDevice == null) {
-            if (!mDiscoverPeersInProgress) {
-                Slog.i(TAG, "Starting Wifi display scan.");
-                mDiscoverPeersInProgress = true;
-                handleScanStarted();
-                tryDiscoverPeers();
-            }
-        } else {
-            if (mDiscoverPeersInProgress) {
-                // Cancel automatic retry right away.
-                mHandler.removeCallbacks(mDiscoverPeers);
-
-                // Defer actually stopping discovery if we have a connection attempt in progress.
-                // The wifi display connection attempt often fails if we are not in discovery
-                // mode.  So we allow discovery to continue until we give up trying to connect.
-                if (mDesiredDevice == null || mDesiredDevice == mConnectedDevice) {
-                    Slog.i(TAG, "Stopping Wifi display scan.");
-                    mDiscoverPeersInProgress = false;
-                    stopPeerDiscovery();
-                    handleScanFinished();
-                }
-            }
+    private void discoverPeers() {
+        if (!mDiscoverPeersInProgress) {
+            mDiscoverPeersInProgress = true;
+            mDiscoverPeersRetriesLeft = DISCOVER_PEERS_MAX_RETRIES;
+            handleScanStarted();
+            tryDiscoverPeers();
         }
     }
 
@@ -396,9 +365,8 @@
                     Slog.d(TAG, "Discover peers succeeded.  Requesting peers now.");
                 }
 
-                if (mDiscoverPeersInProgress) {
-                    requestPeers();
-                }
+                mDiscoverPeersInProgress = false;
+                requestPeers();
             }
 
             @Override
@@ -407,28 +375,30 @@
                     Slog.d(TAG, "Discover peers failed with reason " + reason + ".");
                 }
 
-                // Ignore the error.
-                // We will retry automatically in a little bit.
-            }
-        });
-
-        // Retry discover peers periodically until stopped.
-        mHandler.postDelayed(mDiscoverPeers, DISCOVER_PEERS_INTERVAL_MILLIS);
-    }
-
-    private void stopPeerDiscovery() {
-        mWifiP2pManager.stopPeerDiscovery(mWifiP2pChannel, new ActionListener() {
-            @Override
-            public void onSuccess() {
-                if (DEBUG) {
-                    Slog.d(TAG, "Stop peer discovery succeeded.");
-                }
-            }
-
-            @Override
-            public void onFailure(int reason) {
-                if (DEBUG) {
-                    Slog.d(TAG, "Stop peer discovery failed with reason " + reason + ".");
+                if (mDiscoverPeersInProgress) {
+                    if (reason == 0 && mDiscoverPeersRetriesLeft > 0 && mWfdEnabled) {
+                        mHandler.postDelayed(new Runnable() {
+                            @Override
+                            public void run() {
+                                if (mDiscoverPeersInProgress) {
+                                    if (mDiscoverPeersRetriesLeft > 0 && mWfdEnabled) {
+                                        mDiscoverPeersRetriesLeft -= 1;
+                                        if (DEBUG) {
+                                            Slog.d(TAG, "Retrying discovery.  Retries left: "
+                                                    + mDiscoverPeersRetriesLeft);
+                                        }
+                                        tryDiscoverPeers();
+                                    } else {
+                                        handleScanFinished();
+                                        mDiscoverPeersInProgress = false;
+                                    }
+                                }
+                            }
+                        }, DISCOVER_PEERS_RETRY_DELAY_MILLIS);
+                    } else {
+                        handleScanFinished();
+                        mDiscoverPeersInProgress = false;
+                    }
                 }
             }
         });
@@ -453,9 +423,7 @@
                     }
                 }
 
-                if (mDiscoverPeersInProgress) {
-                    handleScanResults();
-                }
+                handleScanFinished();
             }
         });
     }
@@ -469,7 +437,7 @@
         });
     }
 
-    private void handleScanResults() {
+    private void handleScanFinished() {
         final int count = mAvailableWifiDisplayPeers.size();
         final WifiDisplay[] displays = WifiDisplay.CREATOR.newArray(count);
         for (int i = 0; i < count; i++) {
@@ -481,16 +449,7 @@
         mHandler.post(new Runnable() {
             @Override
             public void run() {
-                mListener.onScanResults(displays);
-            }
-        });
-    }
-
-    private void handleScanFinished() {
-        mHandler.post(new Runnable() {
-            @Override
-            public void run() {
-                mListener.onScanFinished();
+                mListener.onScanFinished(displays);
             }
         });
     }
@@ -533,12 +492,6 @@
             return;
         }
 
-        if (!mWfdEnabled) {
-            Slog.i(TAG, "Ignoring request to connect to Wifi display because the "
-                    +" feature is currently disabled: " + device.deviceName);
-            return;
-        }
-
         mDesiredDevice = device;
         mConnectionRetriesLeft = CONNECT_MAX_RETRIES;
         updateConnection();
@@ -563,31 +516,19 @@
      * connection is established (or not).
      */
     private void updateConnection() {
-        // Step 0. Stop scans if necessary to prevent interference while connected.
-        // Resume scans later when no longer attempting to connect.
-        updateScanState();
-
         // Step 1. Before we try to connect to a new device, tell the system we
         // have disconnected from the old one.
-        if ((mRemoteDisplay != null || mExtRemoteDisplay != null) &&
-                mConnectedDevice != mDesiredDevice) {
-            Slog.i(TAG, "Stopped listening for RTSP connection on "
-                    + mRemoteDisplayInterface
-                    + " from Wifi display: " + mConnectedDevice.deviceName);
-
-            if(mRemoteDisplay != null) {
-                mRemoteDisplay.dispose();
-            } else if(mExtRemoteDisplay != null) {
-                ExtendedRemoteDisplayHelper.dispose(mExtRemoteDisplay);
-            }
+        if (mRemoteDisplay != null && mConnectedDevice != mDesiredDevice) {
+            Slog.i(TAG, "Stopped listening for RTSP connection on " + mRemoteDisplayInterface
+                    + " from Wifi display: " + (mConnectedDevice == null ? "(null)" : mConnectedDevice.deviceName));
 
-            mExtRemoteDisplay = null;
+            mRemoteDisplay.dispose();
             mRemoteDisplay = null;
             mRemoteDisplayInterface = null;
             mRemoteDisplayConnected = false;
             mHandler.removeCallbacks(mRtspTimeout);
 
-            mWifiP2pManager.setMiracastMode(WifiP2pManager.MIRACAST_DISABLED);
+            setRemoteSubmixOn(false);
             unadvertiseDisplay();
 
             // continue to next step
@@ -598,10 +539,9 @@
             return; // wait for asynchronous callback
         }
         if (mConnectedDevice != null && mConnectedDevice != mDesiredDevice) {
-            Slog.i(TAG, "Disconnecting from Wifi display: " + mConnectedDevice.deviceName);
+            Slog.i(TAG, "Disconnecting from Wifi display: " + (mConnectedDevice == null ? "(null)" : mConnectedDevice.deviceName));
             mDisconnectingDevice = mConnectedDevice;
             mConnectedDevice = null;
-            mConnectedDeviceGroupInfo = null;
 
             unadvertiseDisplay();
 
@@ -668,12 +608,8 @@
             return; // wait for asynchronous callback
         }
 
-        // Step 4. If we wanted to disconnect, or we're updating after starting an
-        // autonomous GO, then mission accomplished.
+        // Step 4. If we wanted to disconnect, then mission accomplished.
         if (mDesiredDevice == null) {
-            if (mWifiDisplayCertMode) {
-                mListener.onDisplaySessionInfo(getSessionInfo(mConnectedDeviceGroupInfo, 0));
-            }
             unadvertiseDisplay();
             return; // done
         }
@@ -685,9 +621,7 @@
             mConnectingDevice = mDesiredDevice;
             WifiP2pConfig config = new WifiP2pConfig();
             WpsInfo wps = new WpsInfo();
-            if (mWifiDisplayWpsConfig != WpsInfo.INVALID) {
-                wps.setup = mWifiDisplayWpsConfig;
-            } else if (mConnectingDevice.wpsPbcSupported()) {
+            if (mConnectingDevice.wpsPbcSupported()) {
                 wps.setup = WpsInfo.PBC;
             } else if (mConnectingDevice.wpsDisplaySupported()) {
                 // We do keypad if peer does display
@@ -728,9 +662,8 @@
             return; // wait for asynchronous callback
         }
 
-        // Step 6. Listen for incoming RTSP connection.
-        if (mConnectedDevice != null && (mRemoteDisplay == null &&
-                    mExtRemoteDisplay == null)) {
+        // Step 6. Listen for incoming connections.
+        if (mConnectedDevice != null && mRemoteDisplay == null) {
             Inet4Address addr = getInterfaceAddress(mConnectedDeviceGroupInfo);
             if (addr == null) {
                 Slog.i(TAG, "Failed to get local interface address for communicating "
@@ -739,7 +672,7 @@
                 return; // done
             }
 
-            mWifiP2pManager.setMiracastMode(WifiP2pManager.MIRACAST_SOURCE);
+            setRemoteSubmixOn(true);
 
             final WifiP2pDevice oldDevice = mConnectedDevice;
             final int port = getPortNumber(mConnectedDevice);
@@ -749,21 +682,16 @@
             Slog.i(TAG, "Listening for RTSP connection on " + iface
                     + " from Wifi display: " + mConnectedDevice.deviceName);
 
-            RemoteDisplay.Listener listener = new RemoteDisplay.Listener() {
+            mRemoteDisplay = RemoteDisplay.listen(iface, new RemoteDisplay.Listener() {
                 @Override
                 public void onDisplayConnected(Surface surface,
-                        int width, int height, int flags, int session) {
+                        int width, int height, int flags) {
                     if (mConnectedDevice == oldDevice && !mRemoteDisplayConnected) {
                         Slog.i(TAG, "Opened RTSP connection with Wifi display: "
                                 + mConnectedDevice.deviceName);
                         mRemoteDisplayConnected = true;
                         mHandler.removeCallbacks(mRtspTimeout);
 
-                        if (mWifiDisplayCertMode) {
-                            mListener.onDisplaySessionInfo(
-                                    getSessionInfo(mConnectedDeviceGroupInfo, session));
-                        }
-
                         final WifiDisplay display = createWifiDisplay(mConnectedDevice);
                         advertiseDisplay(display, surface, width, height, flags);
                     }
@@ -788,38 +716,22 @@
                         handleConnectionFailure(false);
                     }
                 }
-            };
-            if(ExtendedRemoteDisplayHelper.isAvailable()){
-                mExtRemoteDisplay = ExtendedRemoteDisplayHelper.listen(iface,
-                        listener, mHandler, mContext);
-            } else {
-                mRemoteDisplay = RemoteDisplay.listen(iface, listener,
-                        mHandler);
-            }
+            }, mHandler);
 
-            // Use extended timeout value for certification, as some tests require user inputs
-            int rtspTimeout = mWifiDisplayCertMode ?
-                    RTSP_TIMEOUT_SECONDS_CERT_MODE : RTSP_TIMEOUT_SECONDS;
-
-            mHandler.postDelayed(mRtspTimeout, rtspTimeout * 1000);
+            // Timeout extended
+            boolean to = Integer.parseInt( SystemProperties.get("persist.sys.wfd.longtimeout", "0") ) == 1;
+            int ext = to ? 2 : 1;
+            Slog.i(TAG, "updateConnection() RTSP Timeout["+RTSP_TIMEOUT_SECONDS * ext+"] seconds");
+            mHandler.postDelayed(mRtspTimeout, RTSP_TIMEOUT_SECONDS * 1000 * ext);
+            //mHandler.postDelayed(mRtspTimeout, RTSP_TIMEOUT_SECONDS * 1000);
         }
     }
 
-    private WifiDisplaySessionInfo getSessionInfo(WifiP2pGroup info, int session) {
-        if (info == null) {
-            return null;
-        }
-        Inet4Address addr = getInterfaceAddress(info);
-        WifiDisplaySessionInfo sessionInfo = new WifiDisplaySessionInfo(
-                !info.getOwner().deviceAddress.equals(mThisDevice.deviceAddress),
-                session,
-                info.getOwner().deviceAddress + " " + info.getNetworkName(),
-                info.getPassphrase(),
-                (addr != null) ? addr.getHostAddress() : "");
-        if (DEBUG) {
-            Slog.d(TAG, sessionInfo.toString());
+    private void setRemoteSubmixOn(boolean on) {
+        if (mRemoteSubmixOn != on) {
+            mRemoteSubmixOn = on;
+            mAudioManager.setRemoteSubmixOn(on, REMOTE_SUBMIX_ADDRESS);
         }
-        return sessionInfo;
     }
 
     private void handleStateChanged(boolean enabled) {
@@ -836,7 +748,7 @@
     private void handleConnectionChanged(NetworkInfo networkInfo) {
         mNetworkInfo = networkInfo;
         if (mWfdEnabled && networkInfo.isConnected()) {
-            if (mDesiredDevice != null || mWifiDisplayCertMode) {
+            if (mDesiredDevice != null) {
                 mWifiP2pManager.requestGroupInfo(mWifiP2pChannel, new GroupInfoListener() {
                     @Override
                     public void onGroupInfoAvailable(WifiP2pGroup info) {
@@ -858,25 +770,6 @@
                             return;
                         }
 
-                        if (mWifiDisplayCertMode) {
-                            boolean owner = info.getOwner().deviceAddress
-                                    .equals(mThisDevice.deviceAddress);
-                            if (owner && info.getClientList().isEmpty()) {
-                                // this is the case when we started Autonomous GO,
-                                // and no client has connected, save group info
-                                // and updateConnection()
-                                mConnectingDevice = mDesiredDevice = null;
-                                mConnectedDeviceGroupInfo = info;
-                                updateConnection();
-                            } else if (mConnectingDevice == null && mDesiredDevice == null) {
-                                // this is the case when we received an incoming connection
-                                // from the sink, update both mConnectingDevice and mDesiredDevice
-                                // then proceed to updateConnection() below
-                                mConnectingDevice = mDesiredDevice = owner ?
-                                        info.getClientList().iterator().next() : info.getOwner();
-                            }
-                        }
-
                         if (mConnectingDevice != null && mConnectingDevice == mDesiredDevice) {
                             Slog.i(TAG, "Connected to Wifi display: "
                                     + mConnectingDevice.deviceName);
@@ -891,12 +784,7 @@
                 });
             }
         } else {
-            mConnectedDeviceGroupInfo = null;
-
-            // Disconnect if we lost the network while connecting or connected to a display.
-            if (mConnectingDevice != null || mConnectedDevice != null) {
-                disconnect();
-            }
+            disconnect();
 
             // After disconnection for a group, for some reason we have a tendency
             // to get a peer change notification with an empty list of peers.
@@ -907,13 +795,6 @@
         }
     }
 
-    private final Runnable mDiscoverPeers = new Runnable() {
-        @Override
-        public void run() {
-            tryDiscoverPeers();
-        }
-    };
-
     private final Runnable mConnectionTimeout = new Runnable() {
         @Override
         public void run() {
@@ -1066,8 +947,7 @@
     }
 
     private static WifiDisplay createWifiDisplay(WifiP2pDevice device) {
-        return new WifiDisplay(device.deviceAddress, device.deviceName, null,
-                true, device.wfdInfo.isSessionAvailable(), false);
+        return new WifiDisplay(device.deviceAddress, device.deviceName, null);
     }
 
     private final BroadcastReceiver mWifiP2pReceiver = new BroadcastReceiver() {
@@ -1101,13 +981,6 @@
                 }
 
                 handleConnectionChanged(networkInfo);
-            } else if (action.equals(WifiP2pManager.WIFI_P2P_THIS_DEVICE_CHANGED_ACTION)) {
-                mThisDevice = (WifiP2pDevice) intent.getParcelableExtra(
-                        WifiP2pManager.EXTRA_WIFI_P2P_DEVICE);
-                if (DEBUG) {
-                    Slog.d(TAG, "Received WIFI_P2P_THIS_DEVICE_CHANGED_ACTION: mThisDevice= "
-                            + mThisDevice);
-                }
             }
         }
     };
@@ -1119,15 +992,13 @@
         void onFeatureStateChanged(int featureState);
 
         void onScanStarted();
-        void onScanResults(WifiDisplay[] availableDisplays);
-        void onScanFinished();
+        void onScanFinished(WifiDisplay[] availableDisplays);
 
         void onDisplayConnecting(WifiDisplay display);
         void onDisplayConnectionFailed();
         void onDisplayChanged(WifiDisplay display);
         void onDisplayConnected(WifiDisplay display,
                 Surface surface, int width, int height, int flags);
-        void onDisplaySessionInfo(WifiDisplaySessionInfo sessionInfo);
         void onDisplayDisconnected();
     }
 }
diff -Naur a/frameworks/native/include/gui/SurfaceTexture.h b/frameworks/native/include/gui/SurfaceTexture.h
--- a/frameworks/native/include/gui/SurfaceTexture.h	1969-12-31 19:00:00.000000000 -0500
+++ b/frameworks/native/include/gui/SurfaceTexture.h	2014-03-24 10:21:44.196420535 -0400
@@ -0,0 +1,402 @@
+/*
+ * Copyright (C) 2010 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#ifndef ANDROID_GUI_SURFACETEXTURE_H
+#define ANDROID_GUI_SURFACETEXTURE_H
+
+#include <EGL/egl.h>
+#include <EGL/eglext.h>
+#include <GLES2/gl2.h>
+#include <GLES2/gl2ext.h>
+
+#include <gui/ISurfaceTexture.h>
+#include <gui/BufferQueue.h>
+#include <gui/ConsumerBase.h>
+
+#include <ui/GraphicBuffer.h>
+
+#include <utils/String8.h>
+#include <utils/Vector.h>
+#include <utils/threads.h>
+
+#define ANDROID_GRAPHICS_SURFACETEXTURE_JNI_ID "mSurfaceTexture"
+
+namespace android {
+// ----------------------------------------------------------------------------
+
+
+class String8;
+
+class SurfaceTexture : public ConsumerBase {
+public:
+    typedef ConsumerBase::FrameAvailableListener FrameAvailableListener;
+
+    // SurfaceTexture constructs a new SurfaceTexture object. tex indicates the
+    // name of the OpenGL ES texture to which images are to be streamed.
+    // allowSynchronousMode specifies whether or not synchronous mode can be
+    // enabled. texTarget specifies the OpenGL ES texture target to which the
+    // texture will be bound in updateTexImage. useFenceSync specifies whether
+    // fences should be used to synchronize access to buffers if that behavior
+    // is enabled at compile-time. A custom bufferQueue can be specified
+    // if behavior for queue/dequeue/connect etc needs to be customized.
+    // Otherwise a default BufferQueue will be created and used.
+    //
+    // For legacy reasons, the SurfaceTexture is created in a state where it is
+    // considered attached to an OpenGL ES context for the purposes of the
+    // attachToContext and detachFromContext methods. However, despite being
+    // considered "attached" to a context, the specific OpenGL ES context
+    // doesn't get latched until the first call to updateTexImage. After that
+    // point, all calls to updateTexImage must be made with the same OpenGL ES
+    // context current.
+    //
+    // A SurfaceTexture may be detached from one OpenGL ES context and then
+    // attached to a different context using the detachFromContext and
+    // attachToContext methods, respectively. The intention of these methods is
+    // purely to allow a SurfaceTexture to be transferred from one consumer
+    // context to another. If such a transfer is not needed there is no
+    // requirement that either of these methods be called.
+    SurfaceTexture(GLuint tex, bool allowSynchronousMode = true,
+            GLenum texTarget = GL_TEXTURE_EXTERNAL_OES, bool useFenceSync = true,
+            const sp<BufferQueue> &bufferQueue = 0);
+
+    // updateTexImage sets the image contents of the target texture to that of
+    // the most recently queued buffer.
+    //
+    // This call may only be made while the OpenGL ES context to which the
+    // target texture belongs is bound to the calling thread.
+    //
+    // After calling this method the doGLFenceWait method must be called
+    // before issuing OpenGL ES commands that access the texture contents.
+    status_t updateTexImage();
+
+    // setReleaseFence stores a fence file descriptor that will signal when the
+    // current buffer is no longer being read. This fence will be returned to
+    // the producer when the current buffer is released by updateTexImage().
+    // Multiple fences can be set for a given buffer; they will be merged into
+    // a single union fence. The SurfaceTexture will close the file descriptor
+    // when finished with it.
+    void setReleaseFence(int fenceFd);
+
+    // setDefaultMaxBufferCount sets the default limit on the maximum number
+    // of buffers that will be allocated at one time. The image producer may
+    // override the limit.
+    status_t setDefaultMaxBufferCount(int bufferCount);
+
+    // getTransformMatrix retrieves the 4x4 texture coordinate transform matrix
+    // associated with the texture image set by the most recent call to
+    // updateTexImage.
+    //
+    // This transform matrix maps 2D homogeneous texture coordinates of the form
+    // (s, t, 0, 1) with s and t in the inclusive range [0, 1] to the texture
+    // coordinate that should be used to sample that location from the texture.
+    // Sampling the texture outside of the range of this transform is undefined.
+    //
+    // This transform is necessary to compensate for transforms that the stream
+    // content producer may implicitly apply to the content. By forcing users of
+    // a SurfaceTexture to apply this transform we avoid performing an extra
+    // copy of the data that would be needed to hide the transform from the
+    // user.
+    //
+    // The matrix is stored in column-major order so that it may be passed
+    // directly to OpenGL ES via the glLoadMatrixf or glUniformMatrix4fv
+    // functions.
+    void getTransformMatrix(float mtx[16]);
+
+    // getTimestamp retrieves the timestamp associated with the texture image
+    // set by the most recent call to updateTexImage.
+    //
+    // The timestamp is in nanoseconds, and is monotonically increasing. Its
+    // other semantics (zero point, etc) are source-dependent and should be
+    // documented by the source.
+    int64_t getTimestamp();
+
+    // setDefaultBufferSize is used to set the size of buffers returned by
+    // requestBuffers when a with and height of zero is requested.
+    // A call to setDefaultBufferSize() may trigger requestBuffers() to
+    // be called from the client.
+    // The width and height parameters must be no greater than the minimum of
+    // GL_MAX_VIEWPORT_DIMS and GL_MAX_TEXTURE_SIZE (see: glGetIntegerv).
+    // An error due to invalid dimensions might not be reported until
+    // updateTexImage() is called.
+    status_t setDefaultBufferSize(uint32_t width, uint32_t height);
+
+    // setFilteringEnabled sets whether the transform matrix should be computed
+    // for use with bilinear filtering.
+    void setFilteringEnabled(bool enabled);
+
+    // getCurrentBuffer returns the buffer associated with the current image.
+    sp<GraphicBuffer> getCurrentBuffer() const;
+
+    // getCurrentTextureTarget returns the texture target of the current
+    // texture as returned by updateTexImage().
+    GLenum getCurrentTextureTarget() const;
+
+    // getCurrentCrop returns the cropping rectangle of the current buffer.
+    Rect getCurrentCrop() const;
+
+    // getCurrentTransform returns the transform of the current buffer.
+    uint32_t getCurrentTransform() const;
+
+    // getCurrentScalingMode returns the scaling mode of the current buffer.
+    uint32_t getCurrentScalingMode() const;
+
+    // getCurrentFence returns the fence indicating when the current buffer is
+    // ready to be read from.
+    sp<Fence> getCurrentFence() const;
+
+    // doGLFenceWait inserts a wait command into the OpenGL ES command stream
+    // to ensure that it is safe for future OpenGL ES commands to access the
+    // current texture buffer.  This must be called each time updateTexImage
+    // is called before issuing OpenGL ES commands that access the texture.
+    status_t doGLFenceWait() const;
+
+    // isSynchronousMode returns whether the SurfaceTexture is currently in
+    // synchronous mode.
+    bool isSynchronousMode() const;
+
+    // set the name of the SurfaceTexture that will be used to identify it in
+    // log messages.
+    void setName(const String8& name);
+
+    // These functions call the corresponding BufferQueue implementation
+    // so the refactoring can proceed smoothly
+    status_t setDefaultBufferFormat(uint32_t defaultFormat);
+    status_t setConsumerUsageBits(uint32_t usage);
+    status_t setTransformHint(uint32_t hint);
+    virtual status_t setSynchronousMode(bool enabled);
+
+    // getBufferQueue returns the BufferQueue object to which this
+    // SurfaceTexture is connected.
+    sp<BufferQueue> getBufferQueue() const {
+        return mBufferQueue;
+    }
+
+    // detachFromContext detaches the SurfaceTexture from the calling thread's
+    // current OpenGL ES context.  This context must be the same as the context
+    // that was current for previous calls to updateTexImage.
+    //
+    // Detaching a SurfaceTexture from an OpenGL ES context will result in the
+    // deletion of the OpenGL ES texture object into which the images were being
+    // streamed.  After a SurfaceTexture has been detached from the OpenGL ES
+    // context calls to updateTexImage will fail returning INVALID_OPERATION
+    // until the SurfaceTexture is attached to a new OpenGL ES context using the
+    // attachToContext method.
+    status_t detachFromContext();
+
+    // attachToContext attaches a SurfaceTexture that is currently in the
+    // 'detached' state to the current OpenGL ES context.  A SurfaceTexture is
+    // in the 'detached' state iff detachFromContext has successfully been
+    // called and no calls to attachToContext have succeeded since the last
+    // detachFromContext call.  Calls to attachToContext made on a
+    // SurfaceTexture that is not in the 'detached' state will result in an
+    // INVALID_OPERATION error.
+    //
+    // The tex argument specifies the OpenGL ES texture object name in the
+    // new context into which the image contents will be streamed.  A successful
+    // call to attachToContext will result in this texture object being bound to
+    // the texture target and populated with the image contents that were
+    // current at the time of the last call to detachFromContext.
+    status_t attachToContext(GLuint tex);
+
+protected:
+
+    // abandonLocked overrides the ConsumerBase method to clear
+    // mCurrentTextureBuf in addition to the ConsumerBase behavior.
+    virtual void abandonLocked();
+
+    // dumpLocked overrides the ConsumerBase method to dump SurfaceTexture-
+    // specific info in addition to the ConsumerBase behavior.
+    virtual void dumpLocked(String8& result, const char* prefix, char* buffer,
+           size_t size) const;
+
+    // acquireBufferLocked overrides the ConsumerBase method to update the
+    // mEglSlots array in addition to the ConsumerBase behavior.
+    virtual status_t acquireBufferLocked(BufferQueue::BufferItem *item);
+
+    // releaseBufferLocked overrides the ConsumerBase method to update the
+    // mEglSlots array in addition to the ConsumerBase.
+    virtual status_t releaseBufferLocked(int buf, EGLDisplay display,
+           EGLSyncKHR eglFence);
+
+    static bool isExternalFormat(uint32_t format);
+
+private:
+    // this version of updateTexImage() takes a functor used to reject or not
+    // the newly acquired buffer.
+    // this API is TEMPORARY and intended to be used by SurfaceFlinger only,
+    // which is why class Layer is made a friend of SurfaceTexture below.
+    class BufferRejecter {
+        friend class SurfaceTexture;
+        virtual bool reject(const sp<GraphicBuffer>& buf,
+                const BufferQueue::BufferItem& item) = 0;
+    protected:
+        virtual ~BufferRejecter() { }
+    };
+    friend class Layer;
+    status_t updateTexImage(BufferRejecter* rejecter, bool skipSync);
+
+    // createImage creates a new EGLImage from a GraphicBuffer.
+    EGLImageKHR createImage(EGLDisplay dpy,
+            const sp<GraphicBuffer>& graphicBuffer);
+
+    // freeBufferLocked frees up the given buffer slot.  If the slot has been
+    // initialized this will release the reference to the GraphicBuffer in that
+    // slot and destroy the EGLImage in that slot.  Otherwise it has no effect.
+    //
+    // This method must be called with mMutex locked.
+    virtual void freeBufferLocked(int slotIndex);
+
+    // computeCurrentTransformMatrixLocked computes the transform matrix for the
+    // current texture.  It uses mCurrentTransform and the current GraphicBuffer
+    // to compute this matrix and stores it in mCurrentTransformMatrix.
+    // mCurrentTextureBuf must not be NULL.
+    void computeCurrentTransformMatrixLocked();
+
+    // doGLFenceWaitLocked inserts a wait command into the OpenGL ES command
+    // stream to ensure that it is safe for future OpenGL ES commands to
+    // access the current texture buffer.  This must be called each time
+    // updateTexImage is called before issuing OpenGL ES commands that access
+    // the texture.
+    status_t doGLFenceWaitLocked() const;
+
+    // syncForReleaseLocked performs the synchronization needed to release the
+    // current slot from an OpenGL ES context.  If needed it will set the
+    // current slot's fence to guard against a producer accessing the buffer
+    // before the outstanding accesses have completed.
+    status_t syncForReleaseLocked(EGLDisplay dpy);
+
+    // The default consumer usage flags that SurfaceTexture always sets on its
+    // BufferQueue instance; these will be OR:d with any additional flags passed
+    // from the SurfaceTexture user. In particular, SurfaceTexture will always
+    // consume buffers as hardware textures.
+    static const uint32_t DEFAULT_USAGE_FLAGS = GraphicBuffer::USAGE_HW_TEXTURE;
+
+    // mCurrentTextureBuf is the graphic buffer of the current texture. It's
+    // possible that this buffer is not associated with any buffer slot, so we
+    // must track it separately in order to support the getCurrentBuffer method.
+    sp<GraphicBuffer> mCurrentTextureBuf;
+
+    // mCurrentCrop is the crop rectangle that applies to the current texture.
+    // It gets set each time updateTexImage is called.
+    Rect mCurrentCrop;
+
+    // mCurrentTransform is the transform identifier for the current texture. It
+    // gets set each time updateTexImage is called.
+    uint32_t mCurrentTransform;
+
+    // mCurrentScalingMode is the scaling mode for the current texture. It gets
+    // set to each time updateTexImage is called.
+    uint32_t mCurrentScalingMode;
+
+    // mCurrentFence is the fence received from BufferQueue in updateTexImage.
+    sp<Fence> mCurrentFence;
+
+    // mCurrentTransformMatrix is the transform matrix for the current texture.
+    // It gets computed by computeTransformMatrix each time updateTexImage is
+    // called.
+    float mCurrentTransformMatrix[16];
+
+    // mCurrentTimestamp is the timestamp for the current texture. It
+    // gets set each time updateTexImage is called.
+    int64_t mCurrentTimestamp;
+
+    uint32_t mDefaultWidth, mDefaultHeight;
+
+    // mFilteringEnabled indicates whether the transform matrix is computed for
+    // use with bilinear filtering. It defaults to true and is changed by
+    // setFilteringEnabled().
+    bool mFilteringEnabled;
+
+    // mTexName is the name of the OpenGL texture to which streamed images will
+    // be bound when updateTexImage is called. It is set at construction time
+    // and can be changed with a call to attachToContext.
+    GLuint mTexName;
+
+    // mUseFenceSync indicates whether creation of the EGL_KHR_fence_sync
+    // extension should be used to prevent buffers from being dequeued before
+    // it's safe for them to be written. It gets set at construction time and
+    // never changes.
+    const bool mUseFenceSync;
+
+    // mTexTarget is the GL texture target with which the GL texture object is
+    // associated.  It is set in the constructor and never changed.  It is
+    // almost always GL_TEXTURE_EXTERNAL_OES except for one use case in Android
+    // Browser.  In that case it is set to GL_TEXTURE_2D to allow
+    // glCopyTexSubImage to read from the texture.  This is a hack to work
+    // around a GL driver limitation on the number of FBO attachments, which the
+    // browser's tile cache exceeds.
+    const GLenum mTexTarget;
+
+    // EGLSlot contains the information and object references that
+    // SurfaceTexture maintains about a BufferQueue buffer slot.
+    struct EGLSlot {
+        EGLSlot()
+        : mEglImage(EGL_NO_IMAGE_KHR),
+          mEglFence(EGL_NO_SYNC_KHR) {
+        }
+
+        // mEglImage is the EGLImage created from mGraphicBuffer.
+        EGLImageKHR mEglImage;
+
+        // mFence is the EGL sync object that must signal before the buffer
+        // associated with this buffer slot may be dequeued. It is initialized
+        // to EGL_NO_SYNC_KHR when the buffer is created and (optionally, based
+        // on a compile-time option) set to a new sync object in updateTexImage.
+        EGLSyncKHR mEglFence;
+    };
+
+    // mEglDisplay is the EGLDisplay with which this SurfaceTexture is currently
+    // associated.  It is intialized to EGL_NO_DISPLAY and gets set to the
+    // current display when updateTexImage is called for the first time and when
+    // attachToContext is called.
+    EGLDisplay mEglDisplay;
+
+    // mEglContext is the OpenGL ES context with which this SurfaceTexture is
+    // currently associated.  It is initialized to EGL_NO_CONTEXT and gets set
+    // to the current GL context when updateTexImage is called for the first
+    // time and when attachToContext is called.
+    EGLContext mEglContext;
+
+    // mEGLSlots stores the buffers that have been allocated by the BufferQueue
+    // for each buffer slot.  It is initialized to null pointers, and gets
+    // filled in with the result of BufferQueue::acquire when the
+    // client dequeues a buffer from a
+    // slot that has not yet been used. The buffer allocated to a slot will also
+    // be replaced if the requested buffer usage or geometry differs from that
+    // of the buffer allocated to a slot.
+    EGLSlot mEglSlots[BufferQueue::NUM_BUFFER_SLOTS];
+
+    // mCurrentTexture is the buffer slot index of the buffer that is currently
+    // bound to the OpenGL texture. It is initialized to INVALID_BUFFER_SLOT,
+    // indicating that no buffer slot is currently bound to the texture. Note,
+    // however, that a value of INVALID_BUFFER_SLOT does not necessarily mean
+    // that no buffer is bound to the texture. A call to setBufferCount will
+    // reset mCurrentTexture to INVALID_BUFFER_SLOT.
+    int mCurrentTexture;
+
+    // mAttached indicates whether the ConsumerBase is currently attached to
+    // an OpenGL ES context.  For legacy reasons, this is initialized to true,
+    // indicating that the ConsumerBase is considered to be attached to
+    // whatever context is current at the time of the first updateTexImage call.
+    // It is set to false by detachFromContext, and then set to true again by
+    // attachToContext.
+    bool mAttached;
+};
+
+// ----------------------------------------------------------------------------
+}; // namespace android
+
+#endif // ANDROID_GUI_SURFACETEXTURE_H
diff -Naur a/frameworks/native/libs/gui/SurfaceTexture.cpp b/frameworks/native/libs/gui/SurfaceTexture.cpp
--- a/frameworks/native/libs/gui/SurfaceTexture.cpp	1969-12-31 19:00:00.000000000 -0500
+++ b/frameworks/native/libs/gui/SurfaceTexture.cpp	2013-08-14 04:13:30.000000000 -0400
@@ -0,0 +1,915 @@
+/*
+ * Copyright (C) 2010 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#define LOG_TAG "SurfaceTexture"
+#define ATRACE_TAG ATRACE_TAG_GRAPHICS
+//#define LOG_NDEBUG 0
+
+#define GL_GLEXT_PROTOTYPES
+#define EGL_EGLEXT_PROTOTYPES
+
+#include <EGL/egl.h>
+#include <EGL/eglext.h>
+#include <GLES2/gl2.h>
+#include <GLES2/gl2ext.h>
+
+#include <hardware/hardware.h>
+
+#include <gui/IGraphicBufferAlloc.h>
+#include <gui/ISurfaceComposer.h>
+#include <gui/SurfaceComposerClient.h>
+#include <gui/SurfaceTexture.h>
+
+#include <private/gui/ComposerService.h>
+
+#include <utils/Log.h>
+#include <utils/String8.h>
+#include <utils/Trace.h>
+
+// This compile option makes SurfaceTexture use the
+// EGL_ANDROID_native_fence_sync extension to create Android native fences to
+// signal when all GLES reads for a given buffer have completed.  It is not
+// compatible with using the EGL_KHR_fence_sync extension for the same
+// purpose.
+#ifdef USE_NATIVE_FENCE_SYNC
+#ifdef USE_FENCE_SYNC
+#error "USE_NATIVE_FENCE_SYNC and USE_FENCE_SYNC are incompatible"
+#endif
+static const bool useNativeFenceSync = true;
+#else
+static const bool useNativeFenceSync = false;
+#endif
+
+// This compile option makes SurfaceTexture use the EGL_ANDROID_sync_wait
+// extension to insert server-side waits into the GLES command stream.  This
+// feature requires the EGL_ANDROID_native_fence_sync and
+// EGL_ANDROID_wait_sync extensions.
+#ifdef USE_WAIT_SYNC
+static const bool useWaitSync = true;
+#else
+static const bool useWaitSync = false;
+#endif
+
+// Macros for including the SurfaceTexture name in log messages
+#define ST_LOGV(x, ...) ALOGV("[%s] "x, mName.string(), ##__VA_ARGS__)
+#define ST_LOGD(x, ...) ALOGD("[%s] "x, mName.string(), ##__VA_ARGS__)
+#define ST_LOGI(x, ...) ALOGI("[%s] "x, mName.string(), ##__VA_ARGS__)
+#define ST_LOGW(x, ...) ALOGW("[%s] "x, mName.string(), ##__VA_ARGS__)
+#define ST_LOGE(x, ...) ALOGE("[%s] "x, mName.string(), ##__VA_ARGS__)
+
+namespace android {
+
+// Transform matrices
+static float mtxIdentity[16] = {
+    1, 0, 0, 0,
+    0, 1, 0, 0,
+    0, 0, 1, 0,
+    0, 0, 0, 1,
+};
+static float mtxFlipH[16] = {
+    -1, 0, 0, 0,
+    0, 1, 0, 0,
+    0, 0, 1, 0,
+    1, 0, 0, 1,
+};
+static float mtxFlipV[16] = {
+    1, 0, 0, 0,
+    0, -1, 0, 0,
+    0, 0, 1, 0,
+    0, 1, 0, 1,
+};
+static float mtxRot90[16] = {
+    0, 1, 0, 0,
+    -1, 0, 0, 0,
+    0, 0, 1, 0,
+    1, 0, 0, 1,
+};
+static float mtxRot180[16] = {
+    -1, 0, 0, 0,
+    0, -1, 0, 0,
+    0, 0, 1, 0,
+    1, 1, 0, 1,
+};
+static float mtxRot270[16] = {
+    0, -1, 0, 0,
+    1, 0, 0, 0,
+    0, 0, 1, 0,
+    0, 1, 0, 1,
+};
+
+static void mtxMul(float out[16], const float a[16], const float b[16]);
+
+
+SurfaceTexture::SurfaceTexture(GLuint tex, bool allowSynchronousMode,
+        GLenum texTarget, bool useFenceSync, const sp<BufferQueue> &bufferQueue) :
+    ConsumerBase(bufferQueue == 0 ? new BufferQueue(allowSynchronousMode) : bufferQueue),
+    mCurrentTransform(0),
+    mCurrentTimestamp(0),
+    mFilteringEnabled(true),
+    mTexName(tex),
+#ifdef USE_FENCE_SYNC
+    mUseFenceSync(useFenceSync),
+#else
+    mUseFenceSync(false),
+#endif
+    mTexTarget(texTarget),
+    mEglDisplay(EGL_NO_DISPLAY),
+    mEglContext(EGL_NO_CONTEXT),
+    mCurrentTexture(BufferQueue::INVALID_BUFFER_SLOT),
+    mAttached(true)
+{
+    ST_LOGV("SurfaceTexture");
+
+    memcpy(mCurrentTransformMatrix, mtxIdentity,
+            sizeof(mCurrentTransformMatrix));
+
+    mBufferQueue->setConsumerUsageBits(DEFAULT_USAGE_FLAGS);
+}
+
+status_t SurfaceTexture::setDefaultMaxBufferCount(int bufferCount) {
+    Mutex::Autolock lock(mMutex);
+    return mBufferQueue->setDefaultMaxBufferCount(bufferCount);
+}
+
+
+status_t SurfaceTexture::setDefaultBufferSize(uint32_t w, uint32_t h)
+{
+    Mutex::Autolock lock(mMutex);
+    mDefaultWidth = w;
+    mDefaultHeight = h;
+    return mBufferQueue->setDefaultBufferSize(w, h);
+}
+
+status_t SurfaceTexture::updateTexImage() {
+    return SurfaceTexture::updateTexImage(NULL, false);
+}
+
+status_t SurfaceTexture::acquireBufferLocked(BufferQueue::BufferItem *item) {
+    status_t err = ConsumerBase::acquireBufferLocked(item);
+    if (err != NO_ERROR) {
+        return err;
+    }
+
+    int slot = item->mBuf;
+    if (item->mGraphicBuffer != NULL) {
+        if (mEglSlots[slot].mEglImage != EGL_NO_IMAGE_KHR) {
+            eglDestroyImageKHR(mEglDisplay, mEglSlots[slot].mEglImage);
+            mEglSlots[slot].mEglImage = EGL_NO_IMAGE_KHR;
+        }
+    }
+
+    // Update the GL texture object. We may have to do this even when
+    // item.mGraphicBuffer == NULL, if we destroyed the EGLImage when
+    // detaching from a context but the buffer has not been re-allocated.
+    if (mEglSlots[slot].mEglImage == EGL_NO_IMAGE_KHR) {
+        EGLImageKHR image = createImage(mEglDisplay, mSlots[slot].mGraphicBuffer);
+        if (image == EGL_NO_IMAGE_KHR) {
+            return UNKNOWN_ERROR;
+        }
+        mEglSlots[slot].mEglImage = image;
+    }
+
+    return NO_ERROR;
+}
+
+status_t SurfaceTexture::releaseBufferLocked(int buf, EGLDisplay display,
+       EGLSyncKHR eglFence) {
+    status_t err = ConsumerBase::releaseBufferLocked(buf, mEglDisplay,
+           eglFence);
+
+    mEglSlots[buf].mEglFence = EGL_NO_SYNC_KHR;
+
+    return err;
+}
+
+status_t SurfaceTexture::updateTexImage(BufferRejecter* rejecter, bool skipSync) {
+    ATRACE_CALL();
+    ST_LOGV("updateTexImage");
+    Mutex::Autolock lock(mMutex);
+
+    status_t err = NO_ERROR;
+
+    if (mAbandoned) {
+        ST_LOGE("updateTexImage: SurfaceTexture is abandoned!");
+        return NO_INIT;
+    }
+
+    if (!mAttached) {
+        ST_LOGE("updateTexImage: SurfaceTexture is not attached to an OpenGL "
+                "ES context");
+        return INVALID_OPERATION;
+    }
+
+    EGLDisplay dpy = eglGetCurrentDisplay();
+    EGLContext ctx = eglGetCurrentContext();
+
+    if ((mEglDisplay != dpy && mEglDisplay != EGL_NO_DISPLAY) ||
+            dpy == EGL_NO_DISPLAY) {
+        ST_LOGE("updateTexImage: invalid current EGLDisplay");
+        return INVALID_OPERATION;
+    }
+
+    if ((mEglContext != ctx && mEglContext != EGL_NO_CONTEXT) ||
+            ctx == EGL_NO_CONTEXT) {
+        ST_LOGE("updateTexImage: invalid current EGLContext");
+        return INVALID_OPERATION;
+    }
+
+    mEglDisplay = dpy;
+    mEglContext = ctx;
+
+    BufferQueue::BufferItem item;
+
+    // In asynchronous mode the list is guaranteed to be one buffer
+    // deep, while in synchronous mode we use the oldest buffer.
+    err = acquireBufferLocked(&item);
+    if (err == NO_ERROR) {
+        int buf = item.mBuf;
+
+        // we call the rejecter here, in case the caller has a reason to
+        // not accept this buffer. this is used by SurfaceFlinger to
+        // reject buffers which have the wrong size
+        if (rejecter && rejecter->reject(mSlots[buf].mGraphicBuffer, item)) {
+            releaseBufferLocked(buf, dpy, EGL_NO_SYNC_KHR);
+            glBindTexture(mTexTarget, mTexName);
+            return NO_ERROR;
+        }
+
+        GLint error;
+        while ((error = glGetError()) != GL_NO_ERROR) {
+            ST_LOGW("updateTexImage: clearing GL error: %#04x", error);
+        }
+
+        EGLImageKHR image = mEglSlots[buf].mEglImage;
+        glBindTexture(mTexTarget, mTexName);
+        glEGLImageTargetTexture2DOES(mTexTarget, (GLeglImageOES)image);
+
+        while ((error = glGetError()) != GL_NO_ERROR) {
+            ST_LOGE("updateTexImage: error binding external texture image %p "
+                    "(slot %d): %#04x", image, buf, error);
+            err = UNKNOWN_ERROR;
+        }
+
+        if (err == NO_ERROR) {
+            err = syncForReleaseLocked(dpy);
+        }
+
+        if (err != NO_ERROR) {
+            // Release the buffer we just acquired.  It's not safe to
+            // release the old buffer, so instead we just drop the new frame.
+            releaseBufferLocked(buf, dpy, EGL_NO_SYNC_KHR);
+            return err;
+        }
+
+        ST_LOGV("updateTexImage: (slot=%d buf=%p) -> (slot=%d buf=%p)",
+                mCurrentTexture,
+                mCurrentTextureBuf != NULL ? mCurrentTextureBuf->handle : 0,
+                buf, mSlots[buf].mGraphicBuffer->handle);
+
+        // release old buffer
+        if (mCurrentTexture != BufferQueue::INVALID_BUFFER_SLOT) {
+            status_t status = releaseBufferLocked(mCurrentTexture, dpy,
+                    mEglSlots[mCurrentTexture].mEglFence);
+            if (status != NO_ERROR && status != BufferQueue::STALE_BUFFER_SLOT) {
+                ST_LOGE("updateTexImage: failed to release buffer: %s (%d)",
+                       strerror(-status), status);
+                err = status;
+            }
+        }
+
+        // when in miracast...
+        // /frameworks/av/media/libstagefright/wifi-display/sink/TunnelRenderer.cpp
+        //        mSurfaceControl = mComposerClient->createSurface( String8("A Sink Surface"),
+        if (rejecter && mName == "A Sink Surface") {
+            item.mTransform |= 0x04;
+            ST_LOGW("updateTexImage() Force Transform::ROT_90 [%d, %d]", mSlots[buf].mGraphicBuffer->getWidth(), mSlots[buf].mGraphicBuffer->getHeight());
+        }
+
+        // Update the SurfaceTexture state.
+        mCurrentTexture = buf;
+        mCurrentTextureBuf = mSlots[buf].mGraphicBuffer;
+        mCurrentCrop = item.mCrop;
+        mCurrentTransform = item.mTransform;
+        mCurrentScalingMode = item.mScalingMode;
+        mCurrentTimestamp = item.mTimestamp;
+        mCurrentFence = item.mFence;
+        if (!skipSync) {
+            // SurfaceFlinger needs to lazily perform GLES synchronization
+            // only when it's actually going to use GLES for compositing.
+            // Eventually SurfaceFlinger should have its own consumer class,
+            // but for now we'll just hack it in to SurfaceTexture.
+            // SurfaceFlinger is responsible for calling doGLFenceWait before
+            // texturing from this SurfaceTexture.
+            doGLFenceWaitLocked();
+        }
+        computeCurrentTransformMatrixLocked();
+    } else  {
+        if (err < 0) {
+            ST_LOGE("updateTexImage: acquire failed: %s (%d)",
+                strerror(-err), err);
+            return err;
+        }
+        // We always bind the texture even if we don't update its contents.
+        glBindTexture(mTexTarget, mTexName);
+        return OK;
+    }
+
+    return err;
+}
+
+void SurfaceTexture::setReleaseFence(int fenceFd) {
+    sp<Fence> fence(new Fence(fenceFd));
+    if (fenceFd == -1 || mCurrentTexture == BufferQueue::INVALID_BUFFER_SLOT)
+        return;
+    status_t err = addReleaseFence(mCurrentTexture, fence);
+    if (err != OK) {
+        ST_LOGE("setReleaseFence: failed to add the fence: %s (%d)",
+                strerror(-err), err);
+    }
+}
+
+status_t SurfaceTexture::detachFromContext() {
+    ATRACE_CALL();
+    ST_LOGV("detachFromContext");
+    Mutex::Autolock lock(mMutex);
+
+    if (mAbandoned) {
+        ST_LOGE("detachFromContext: abandoned SurfaceTexture");
+        return NO_INIT;
+    }
+
+    if (!mAttached) {
+        ST_LOGE("detachFromContext: SurfaceTexture is not attached to a "
+                "context");
+        return INVALID_OPERATION;
+    }
+
+    EGLDisplay dpy = eglGetCurrentDisplay();
+    EGLContext ctx = eglGetCurrentContext();
+
+    if (mEglDisplay != dpy && mEglDisplay != EGL_NO_DISPLAY) {
+        ST_LOGE("detachFromContext: invalid current EGLDisplay");
+        return INVALID_OPERATION;
+    }
+
+    if (mEglContext != ctx && mEglContext != EGL_NO_CONTEXT) {
+        ST_LOGE("detachFromContext: invalid current EGLContext");
+        return INVALID_OPERATION;
+    }
+
+    if (dpy != EGL_NO_DISPLAY && ctx != EGL_NO_CONTEXT) {
+        status_t err = syncForReleaseLocked(dpy);
+        if (err != OK) {
+            return err;
+        }
+
+        glDeleteTextures(1, &mTexName);
+    }
+
+    // Because we're giving up the EGLDisplay we need to free all the EGLImages
+    // that are associated with it.  They'll be recreated when the
+    // SurfaceTexture gets attached to a new OpenGL ES context (and thus gets a
+    // new EGLDisplay).
+    for (int i =0; i < BufferQueue::NUM_BUFFER_SLOTS; i++) {
+        EGLImageKHR img = mEglSlots[i].mEglImage;
+        if (img != EGL_NO_IMAGE_KHR) {
+            eglDestroyImageKHR(mEglDisplay, img);
+            mEglSlots[i].mEglImage = EGL_NO_IMAGE_KHR;
+        }
+    }
+
+    mEglDisplay = EGL_NO_DISPLAY;
+    mEglContext = EGL_NO_CONTEXT;
+    mAttached = false;
+
+    return OK;
+}
+
+status_t SurfaceTexture::attachToContext(GLuint tex) {
+    ATRACE_CALL();
+    ST_LOGV("attachToContext");
+    Mutex::Autolock lock(mMutex);
+
+    if (mAbandoned) {
+        ST_LOGE("attachToContext: abandoned SurfaceTexture");
+        return NO_INIT;
+    }
+
+    if (mAttached) {
+        ST_LOGE("attachToContext: SurfaceTexture is already attached to a "
+                "context");
+        return INVALID_OPERATION;
+    }
+
+    EGLDisplay dpy = eglGetCurrentDisplay();
+    EGLContext ctx = eglGetCurrentContext();
+
+    if (dpy == EGL_NO_DISPLAY) {
+        ST_LOGE("attachToContext: invalid current EGLDisplay");
+        return INVALID_OPERATION;
+    }
+
+    if (ctx == EGL_NO_CONTEXT) {
+        ST_LOGE("attachToContext: invalid current EGLContext");
+        return INVALID_OPERATION;
+    }
+
+    // We need to bind the texture regardless of whether there's a current
+    // buffer.
+    glBindTexture(mTexTarget, tex);
+
+    if (mCurrentTextureBuf != NULL) {
+        // The EGLImageKHR that was associated with the slot was destroyed when
+        // the SurfaceTexture was detached from the old context, so we need to
+        // recreate it here.
+        EGLImageKHR image = createImage(dpy, mCurrentTextureBuf);
+        if (image == EGL_NO_IMAGE_KHR) {
+            return UNKNOWN_ERROR;
+        }
+
+        // Attach the current buffer to the GL texture.
+        glEGLImageTargetTexture2DOES(mTexTarget, (GLeglImageOES)image);
+
+        GLint error;
+        status_t err = OK;
+        while ((error = glGetError()) != GL_NO_ERROR) {
+            ST_LOGE("attachToContext: error binding external texture image %p "
+                    "(slot %d): %#04x", image, mCurrentTexture, error);
+            err = UNKNOWN_ERROR;
+        }
+
+        // We destroy the EGLImageKHR here because the current buffer may no
+        // longer be associated with one of the buffer slots, so we have
+        // nowhere to to store it.  If the buffer is still associated with a
+        // slot then another EGLImageKHR will be created next time that buffer
+        // gets acquired in updateTexImage.
+        eglDestroyImageKHR(dpy, image);
+
+        if (err != OK) {
+            return err;
+        }
+    }
+
+    mEglDisplay = dpy;
+    mEglContext = ctx;
+    mTexName = tex;
+    mAttached = true;
+
+    return OK;
+}
+
+status_t SurfaceTexture::syncForReleaseLocked(EGLDisplay dpy) {
+    ST_LOGV("syncForReleaseLocked");
+
+    if (mCurrentTexture != BufferQueue::INVALID_BUFFER_SLOT) {
+        if (useNativeFenceSync) {
+            EGLSyncKHR sync = eglCreateSyncKHR(dpy,
+                    EGL_SYNC_NATIVE_FENCE_ANDROID, NULL);
+            if (sync == EGL_NO_SYNC_KHR) {
+                ST_LOGE("syncForReleaseLocked: error creating EGL fence: %#x",
+                        eglGetError());
+                return UNKNOWN_ERROR;
+            }
+            glFlush();
+            int fenceFd = eglDupNativeFenceFDANDROID(dpy, sync);
+            eglDestroySyncKHR(dpy, sync);
+            if (fenceFd == EGL_NO_NATIVE_FENCE_FD_ANDROID) {
+                ST_LOGE("syncForReleaseLocked: error dup'ing native fence "
+                        "fd: %#x", eglGetError());
+                return UNKNOWN_ERROR;
+            }
+            sp<Fence> fence(new Fence(fenceFd));
+            status_t err = addReleaseFenceLocked(mCurrentTexture, fence);
+            if (err != OK) {
+                ST_LOGE("syncForReleaseLocked: error adding release fence: "
+                        "%s (%d)", strerror(-err), err);
+                return err;
+            }
+        } else if (mUseFenceSync) {
+            EGLSyncKHR fence = mEglSlots[mCurrentTexture].mEglFence;
+            if (fence != EGL_NO_SYNC_KHR) {
+                // There is already a fence for the current slot.  We need to
+                // wait on that before replacing it with another fence to
+                // ensure that all outstanding buffer accesses have completed
+                // before the producer accesses it.
+                EGLint result = eglClientWaitSyncKHR(dpy, fence, 0, 1000000000);
+                if (result == EGL_FALSE) {
+                    ST_LOGE("syncForReleaseLocked: error waiting for previous "
+                            "fence: %#x", eglGetError());
+                    return UNKNOWN_ERROR;
+                } else if (result == EGL_TIMEOUT_EXPIRED_KHR) {
+                    ST_LOGE("syncForReleaseLocked: timeout waiting for previous "
+                            "fence");
+                    return TIMED_OUT;
+                }
+                eglDestroySyncKHR(dpy, fence);
+            }
+
+            // Create a fence for the outstanding accesses in the current
+            // OpenGL ES context.
+            fence = eglCreateSyncKHR(dpy, EGL_SYNC_FENCE_KHR, NULL);
+            if (fence == EGL_NO_SYNC_KHR) {
+                ST_LOGE("syncForReleaseLocked: error creating fence: %#x",
+                        eglGetError());
+                return UNKNOWN_ERROR;
+            }
+            glFlush();
+            mEglSlots[mCurrentTexture].mEglFence = fence;
+        }
+    }
+
+    return OK;
+}
+
+bool SurfaceTexture::isExternalFormat(uint32_t format)
+{
+    switch (format) {
+    // supported YUV formats
+    case HAL_PIXEL_FORMAT_YV12:
+    // Legacy/deprecated YUV formats
+    case HAL_PIXEL_FORMAT_YCbCr_422_SP:
+    case HAL_PIXEL_FORMAT_YCrCb_420_SP:
+    case HAL_PIXEL_FORMAT_YCbCr_422_I:
+        return true;
+    }
+
+    // Any OEM format needs to be considered
+    if (format>=0x100 && format<=0x1FF)
+        return true;
+
+    return false;
+}
+
+GLenum SurfaceTexture::getCurrentTextureTarget() const {
+    return mTexTarget;
+}
+
+void SurfaceTexture::getTransformMatrix(float mtx[16]) {
+    Mutex::Autolock lock(mMutex);
+    memcpy(mtx, mCurrentTransformMatrix, sizeof(mCurrentTransformMatrix));
+}
+
+void SurfaceTexture::setFilteringEnabled(bool enabled) {
+    Mutex::Autolock lock(mMutex);
+    if (mAbandoned) {
+        ST_LOGE("setFilteringEnabled: SurfaceTexture is abandoned!");
+        return;
+    }
+    bool needsRecompute = mFilteringEnabled != enabled;
+    mFilteringEnabled = enabled;
+
+    if (needsRecompute && mCurrentTextureBuf==NULL) {
+        ST_LOGD("setFilteringEnabled called with mCurrentTextureBuf == NULL");
+    }
+
+    if (needsRecompute && mCurrentTextureBuf != NULL) {
+        computeCurrentTransformMatrixLocked();
+    }
+}
+
+void SurfaceTexture::computeCurrentTransformMatrixLocked() {
+    ST_LOGV("computeCurrentTransformMatrixLocked");
+
+    float xform[16];
+    for (int i = 0; i < 16; i++) {
+        xform[i] = mtxIdentity[i];
+    }
+    if (mCurrentTransform & NATIVE_WINDOW_TRANSFORM_FLIP_H) {
+        float result[16];
+        mtxMul(result, xform, mtxFlipH);
+        for (int i = 0; i < 16; i++) {
+            xform[i] = result[i];
+        }
+    }
+    if (mCurrentTransform & NATIVE_WINDOW_TRANSFORM_FLIP_V) {
+        float result[16];
+        mtxMul(result, xform, mtxFlipV);
+        for (int i = 0; i < 16; i++) {
+            xform[i] = result[i];
+        }
+    }
+    if (mCurrentTransform & NATIVE_WINDOW_TRANSFORM_ROT_90) {
+        float result[16];
+        mtxMul(result, xform, mtxRot90);
+        for (int i = 0; i < 16; i++) {
+            xform[i] = result[i];
+        }
+    }
+
+    sp<GraphicBuffer>& buf(mCurrentTextureBuf);
+
+    if (buf == NULL) {
+        ST_LOGD("computeCurrentTransformMatrixLocked: mCurrentTextureBuf is NULL");
+    }
+
+    Rect cropRect = mCurrentCrop;
+    float tx = 0.0f, ty = 0.0f, sx = 1.0f, sy = 1.0f;
+    float bufferWidth = buf->getWidth();
+    float bufferHeight = buf->getHeight();
+    if (!cropRect.isEmpty()) {
+        float shrinkAmount = 0.0f;
+        if (mFilteringEnabled) {
+            // In order to prevent bilinear sampling beyond the edge of the
+            // crop rectangle we may need to shrink it by 2 texels in each
+            // dimension.  Normally this would just need to take 1/2 a texel
+            // off each end, but because the chroma channels of YUV420 images
+            // are subsampled we may need to shrink the crop region by a whole
+            // texel on each side.
+            switch (buf->getPixelFormat()) {
+                case PIXEL_FORMAT_RGBA_8888:
+                case PIXEL_FORMAT_RGBX_8888:
+                case PIXEL_FORMAT_RGB_888:
+                case PIXEL_FORMAT_RGB_565:
+                case PIXEL_FORMAT_BGRA_8888:
+                case PIXEL_FORMAT_RGBA_5551:
+                case PIXEL_FORMAT_RGBA_4444:
+                    // We know there's no subsampling of any channels, so we
+                    // only need to shrink by a half a pixel.
+                    shrinkAmount = 0.5;
+                    break;
+
+                default:
+                    // If we don't recognize the format, we must assume the
+                    // worst case (that we care about), which is YUV420.
+                    shrinkAmount = 1.0;
+                    break;
+            }
+        }
+
+        // Only shrink the dimensions that are not the size of the buffer.
+        if (cropRect.width() < bufferWidth) {
+            tx = (float(cropRect.left) + shrinkAmount) / bufferWidth;
+            sx = (float(cropRect.width()) - (2.0f * shrinkAmount)) /
+                    bufferWidth;
+        }
+        if (cropRect.height() < bufferHeight) {
+            ty = (float(bufferHeight - cropRect.bottom) + shrinkAmount) /
+                    bufferHeight;
+            sy = (float(cropRect.height()) - (2.0f * shrinkAmount)) /
+                    bufferHeight;
+        }
+    }
+    float crop[16] = {
+        sx, 0, 0, 0,
+        0, sy, 0, 0,
+        0, 0, 1, 0,
+        tx, ty, 0, 1,
+    };
+
+    float mtxBeforeFlipV[16];
+    mtxMul(mtxBeforeFlipV, crop, xform);
+
+    // SurfaceFlinger expects the top of its window textures to be at a Y
+    // coordinate of 0, so SurfaceTexture must behave the same way.  We don't
+    // want to expose this to applications, however, so we must add an
+    // additional vertical flip to the transform after all the other transforms.
+    mtxMul(mCurrentTransformMatrix, mtxFlipV, mtxBeforeFlipV);
+}
+
+nsecs_t SurfaceTexture::getTimestamp() {
+    ST_LOGV("getTimestamp");
+    Mutex::Autolock lock(mMutex);
+    return mCurrentTimestamp;
+}
+
+EGLImageKHR SurfaceTexture::createImage(EGLDisplay dpy,
+        const sp<GraphicBuffer>& graphicBuffer) {
+    EGLClientBuffer cbuf = (EGLClientBuffer)graphicBuffer->getNativeBuffer();
+    EGLint attrs[] = {
+        EGL_IMAGE_PRESERVED_KHR,    EGL_TRUE,
+        EGL_NONE,
+    };
+    EGLImageKHR image = eglCreateImageKHR(dpy, EGL_NO_CONTEXT,
+            EGL_NATIVE_BUFFER_ANDROID, cbuf, attrs);
+    if (image == EGL_NO_IMAGE_KHR) {
+        EGLint error = eglGetError();
+        ST_LOGE("error creating EGLImage: %#x", error);
+    }
+    return image;
+}
+
+sp<GraphicBuffer> SurfaceTexture::getCurrentBuffer() const {
+    Mutex::Autolock lock(mMutex);
+    return mCurrentTextureBuf;
+}
+
+Rect SurfaceTexture::getCurrentCrop() const {
+    Mutex::Autolock lock(mMutex);
+
+    Rect outCrop = mCurrentCrop;
+    if (mCurrentScalingMode == NATIVE_WINDOW_SCALING_MODE_SCALE_CROP) {
+        int32_t newWidth = mCurrentCrop.width();
+        int32_t newHeight = mCurrentCrop.height();
+
+        if (newWidth * mDefaultHeight > newHeight * mDefaultWidth) {
+            newWidth = newHeight * mDefaultWidth / mDefaultHeight;
+            ST_LOGV("too wide: newWidth = %d", newWidth);
+        } else if (newWidth * mDefaultHeight < newHeight * mDefaultWidth) {
+            newHeight = newWidth * mDefaultHeight / mDefaultWidth;
+            ST_LOGV("too tall: newHeight = %d", newHeight);
+        }
+
+        // The crop is too wide
+        if (newWidth < mCurrentCrop.width()) {
+            int32_t dw = (newWidth - mCurrentCrop.width())/2;
+            outCrop.left -=dw;
+            outCrop.right += dw;
+        // The crop is too tall
+        } else if (newHeight < mCurrentCrop.height()) {
+            int32_t dh = (newHeight - mCurrentCrop.height())/2;
+            outCrop.top -= dh;
+            outCrop.bottom += dh;
+        }
+
+        ST_LOGV("getCurrentCrop final crop [%d,%d,%d,%d]",
+            outCrop.left, outCrop.top,
+            outCrop.right,outCrop.bottom);
+    }
+
+    return outCrop;
+}
+
+uint32_t SurfaceTexture::getCurrentTransform() const {
+    Mutex::Autolock lock(mMutex);
+    return mCurrentTransform;
+}
+
+uint32_t SurfaceTexture::getCurrentScalingMode() const {
+    Mutex::Autolock lock(mMutex);
+    return mCurrentScalingMode;
+}
+
+sp<Fence> SurfaceTexture::getCurrentFence() const {
+    Mutex::Autolock lock(mMutex);
+    return mCurrentFence;
+}
+
+status_t SurfaceTexture::doGLFenceWait() const {
+    Mutex::Autolock lock(mMutex);
+    return doGLFenceWaitLocked();
+}
+
+status_t SurfaceTexture::doGLFenceWaitLocked() const {
+
+    EGLDisplay dpy = eglGetCurrentDisplay();
+    EGLContext ctx = eglGetCurrentContext();
+
+    if (mEglDisplay != dpy || mEglDisplay == EGL_NO_DISPLAY) {
+        ST_LOGE("doGLFenceWait: invalid current EGLDisplay");
+        return INVALID_OPERATION;
+    }
+
+    if (mEglContext != ctx || mEglContext == EGL_NO_CONTEXT) {
+        ST_LOGE("doGLFenceWait: invalid current EGLContext");
+        return INVALID_OPERATION;
+    }
+
+    if (mCurrentFence != NULL) {
+        if (useWaitSync) {
+            // Create an EGLSyncKHR from the current fence.
+            int fenceFd = mCurrentFence->dup();
+            if (fenceFd == -1) {
+                ST_LOGE("doGLFenceWait: error dup'ing fence fd: %d", errno);
+                return -errno;
+            }
+            EGLint attribs[] = {
+                EGL_SYNC_NATIVE_FENCE_FD_ANDROID, fenceFd,
+                EGL_NONE
+            };
+            EGLSyncKHR sync = eglCreateSyncKHR(dpy,
+                    EGL_SYNC_NATIVE_FENCE_ANDROID, attribs);
+            if (sync == EGL_NO_SYNC_KHR) {
+                close(fenceFd);
+                ST_LOGE("doGLFenceWait: error creating EGL fence: %#x",
+                        eglGetError());
+                return UNKNOWN_ERROR;
+            }
+
+            // XXX: The spec draft is inconsistent as to whether this should
+            // return an EGLint or void.  Ignore the return value for now, as
+            // it's not strictly needed.
+            eglWaitSyncANDROID(dpy, sync, 0);
+            EGLint eglErr = eglGetError();
+            eglDestroySyncKHR(dpy, sync);
+            if (eglErr != EGL_SUCCESS) {
+                ST_LOGE("doGLFenceWait: error waiting for EGL fence: %#x",
+                        eglErr);
+                return UNKNOWN_ERROR;
+            }
+        } else {
+            status_t err = mCurrentFence->waitForever(1000,
+                    "SurfaceTexture::doGLFenceWaitLocked");
+            if (err != NO_ERROR) {
+                ST_LOGE("doGLFenceWait: error waiting for fence: %d", err);
+                return err;
+            }
+        }
+    }
+
+    return NO_ERROR;
+}
+
+bool SurfaceTexture::isSynchronousMode() const {
+    Mutex::Autolock lock(mMutex);
+    return mBufferQueue->isSynchronousMode();
+}
+
+void SurfaceTexture::freeBufferLocked(int slotIndex) {
+    ST_LOGV("freeBufferLocked: slotIndex=%d", slotIndex);
+    if (slotIndex == mCurrentTexture) {
+        mCurrentTexture = BufferQueue::INVALID_BUFFER_SLOT;
+    }
+    EGLImageKHR img = mEglSlots[slotIndex].mEglImage;
+    if (img != EGL_NO_IMAGE_KHR) {
+        ST_LOGV("destroying EGLImage dpy=%p img=%p", mEglDisplay, img);
+        eglDestroyImageKHR(mEglDisplay, img);
+    }
+    mEglSlots[slotIndex].mEglImage = EGL_NO_IMAGE_KHR;
+    ConsumerBase::freeBufferLocked(slotIndex);
+}
+
+void SurfaceTexture::abandonLocked() {
+    ST_LOGV("abandonLocked");
+    mCurrentTextureBuf.clear();
+    ConsumerBase::abandonLocked();
+}
+
+void SurfaceTexture::setName(const String8& name) {
+    Mutex::Autolock _l(mMutex);
+    mName = name;
+    mBufferQueue->setConsumerName(name);
+}
+
+status_t SurfaceTexture::setDefaultBufferFormat(uint32_t defaultFormat) {
+    Mutex::Autolock lock(mMutex);
+    return mBufferQueue->setDefaultBufferFormat(defaultFormat);
+}
+
+status_t SurfaceTexture::setConsumerUsageBits(uint32_t usage) {
+    Mutex::Autolock lock(mMutex);
+    usage |= DEFAULT_USAGE_FLAGS;
+    return mBufferQueue->setConsumerUsageBits(usage);
+}
+
+status_t SurfaceTexture::setTransformHint(uint32_t hint) {
+    Mutex::Autolock lock(mMutex);
+    return mBufferQueue->setTransformHint(hint);
+}
+
+// Used for refactoring BufferQueue from SurfaceTexture
+// Should not be in final interface once users of SurfaceTexture are clean up.
+status_t SurfaceTexture::setSynchronousMode(bool enabled) {
+    Mutex::Autolock lock(mMutex);
+    return mBufferQueue->setSynchronousMode(enabled);
+}
+
+void SurfaceTexture::dumpLocked(String8& result, const char* prefix,
+        char* buffer, size_t size) const
+{
+    snprintf(buffer, size,
+       "%smTexName=%d mCurrentTexture=%d\n"
+       "%smCurrentCrop=[%d,%d,%d,%d] mCurrentTransform=%#x\n",
+       prefix, mTexName, mCurrentTexture, prefix, mCurrentCrop.left,
+       mCurrentCrop.top, mCurrentCrop.right, mCurrentCrop.bottom,
+       mCurrentTransform);
+    result.append(buffer);
+
+    ConsumerBase::dumpLocked(result, prefix, buffer, size);
+}
+
+static void mtxMul(float out[16], const float a[16], const float b[16]) {
+    out[0] = a[0]*b[0] + a[4]*b[1] + a[8]*b[2] + a[12]*b[3];
+    out[1] = a[1]*b[0] + a[5]*b[1] + a[9]*b[2] + a[13]*b[3];
+    out[2] = a[2]*b[0] + a[6]*b[1] + a[10]*b[2] + a[14]*b[3];
+    out[3] = a[3]*b[0] + a[7]*b[1] + a[11]*b[2] + a[15]*b[3];
+
+    out[4] = a[0]*b[4] + a[4]*b[5] + a[8]*b[6] + a[12]*b[7];
+    out[5] = a[1]*b[4] + a[5]*b[5] + a[9]*b[6] + a[13]*b[7];
+    out[6] = a[2]*b[4] + a[6]*b[5] + a[10]*b[6] + a[14]*b[7];
+    out[7] = a[3]*b[4] + a[7]*b[5] + a[11]*b[6] + a[15]*b[7];
+
+    out[8] = a[0]*b[8] + a[4]*b[9] + a[8]*b[10] + a[12]*b[11];
+    out[9] = a[1]*b[8] + a[5]*b[9] + a[9]*b[10] + a[13]*b[11];
+    out[10] = a[2]*b[8] + a[6]*b[9] + a[10]*b[10] + a[14]*b[11];
+    out[11] = a[3]*b[8] + a[7]*b[9] + a[11]*b[10] + a[15]*b[11];
+
+    out[12] = a[0]*b[12] + a[4]*b[13] + a[8]*b[14] + a[12]*b[15];
+    out[13] = a[1]*b[12] + a[5]*b[13] + a[9]*b[14] + a[13]*b[15];
+    out[14] = a[2]*b[12] + a[6]*b[13] + a[10]*b[14] + a[14]*b[15];
+    out[15] = a[3]*b[12] + a[7]*b[13] + a[11]*b[14] + a[15]*b[15];
+}
+
+}; // namespace android
diff -Naur a/packages/apps/Mira4U/AndroidManifest.xml b/packages/apps/Mira4U/AndroidManifest.xml
--- a/packages/apps/Mira4U/AndroidManifest.xml	1969-12-31 19:00:00.000000000 -0500
+++ b/packages/apps/Mira4U/AndroidManifest.xml	2013-08-14 04:13:30.000000000 -0400
@@ -0,0 +1,56 @@
+<?xml version="1.0" encoding="utf-8"?>
+<manifest xmlns:android="http://schemas.android.com/apk/res/android"
+    package="com.example.mira4u"
+    android:sharedUserId="android.uid.system"
+    android:versionCode="1"
+    android:versionName="1.1" >
+
+    <uses-sdk
+        android:minSdkVersion="17"
+        android:targetSdkVersion="17" />
+
+    <uses-permission android:name="android.permission.ACCESS_NETWORK_STATE"/>
+    <uses-permission android:name="android.permission.ACCESS_WIFI_STATE"/>
+    <uses-permission android:name="android.permission.CHANGE_WIFI_STATE" />
+    <uses-permission android:name="android.permission.INTERNET"/>
+
+    <uses-permission android:name="android.permission.MODIFY_AUDIO_SETTINGS"/>
+    <uses-permission android:name="android.permission.ACCESS_SURFACE_FLINGER"/>
+    <uses-permission android:name="android.permission.CONFIGURE_WIFI_DISPLAY"/>
+    <uses-permission android:name="android.permission.CONTROL_WIFI_DISPLAY"/>
+
+    <uses-permission android:name="android.permission.WRITE_SETTINGS" />
+    <uses-permission android:name="android.permission.WRITE_SECURE_SETTINGS" />
+
+    <application
+        android:allowBackup="true"
+        android:icon="@drawable/ic_launcher"
+        android:label="@string/app_name"
+        android:theme="@style/AppTheme" >
+        <activity
+            android:name="com.example.mira4u.MainActivity"
+            android:label="@string/app_name"
+            android:screenOrientation="portrait"
+            >
+            <intent-filter>
+                <action android:name="android.intent.action.MAIN" />
+                <category android:name="android.intent.category.LAUNCHER" />
+            </intent-filter>
+        </activity>
+
+        <activity
+            android:name="com.example.mira4u.P2pSinkActivity"
+            android:label="@string/p2p_name"
+            android:screenOrientation="portrait"
+            >
+        </activity>
+
+        <activity
+            android:name="com.example.mira4u.SettingsActivity"
+            android:label="@string/set_name"
+            android:screenOrientation="portrait" >
+        </activity>
+
+    </application>
+
+</manifest>
diff -Naur a/packages/apps/Mira4U/Android.mk b/packages/apps/Mira4U/Android.mk
--- a/packages/apps/Mira4U/Android.mk	1969-12-31 19:00:00.000000000 -0500
+++ b/packages/apps/Mira4U/Android.mk	2013-08-14 04:13:30.000000000 -0400
@@ -0,0 +1,15 @@
+LOCAL_PATH:= $(call my-dir)
+include $(CLEAR_VARS)
+
+LOCAL_MODULE_TAGS := optional
+
+LOCAL_SRC_FILES := $(call all-subdir-java-files)
+
+LOCAL_PACKAGE_NAME := Mira4U
+LOCAL_CERTIFICATE := platform
+
+LOCAL_JNI_SHARED_LIBRARIES := libMira4U
+LOCAL_REQUIRED_MODULES := libMira4U
+
+include $(BUILD_PACKAGE)
+include $(call all-makefiles-under, $(LOCAL_PATH))
diff -Naur a/packages/apps/Mira4U/.classpath b/packages/apps/Mira4U/.classpath
--- a/packages/apps/Mira4U/.classpath	1969-12-31 19:00:00.000000000 -0500
+++ b/packages/apps/Mira4U/.classpath	2013-08-14 04:13:30.000000000 -0400
@@ -0,0 +1,17 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<classpath>
+	<classpathentry kind="src" path="src"/>
+	<classpathentry kind="con" path="com.android.ide.eclipse.adt.ANDROID_FRAMEWORK"/>
+	<classpathentry kind="con" path="com.android.ide.eclipse.adt.LIBRARIES"/>
+	<classpathentry exported="true" kind="con" path="com.android.ide.eclipse.adt.DEPENDENCIES"/>
+	<classpathentry kind="src" path="gen"/>
+	<classpathentry kind="lib" path="/Users/sato/bin/android-sdk-macosx/platforms/android-16/android.jar">
+		<attributes>
+			<attribute name="javadoc_location" value="http://developer.android.com/reference/"/>
+		</attributes>
+		<accessrules>
+			<accessrule kind="nonaccessible" pattern="com/android/internal/**"/>
+		</accessrules>
+	</classpathentry>
+	<classpathentry kind="output" path="bin/classes"/>
+</classpath>
diff -Naur a/packages/apps/Mira4U/.cproject b/packages/apps/Mira4U/.cproject
--- a/packages/apps/Mira4U/.cproject	1969-12-31 19:00:00.000000000 -0500
+++ b/packages/apps/Mira4U/.cproject	2013-08-14 04:13:30.000000000 -0400
@@ -0,0 +1,53 @@
+<?xml version="1.0" encoding="UTF-8" standalone="no"?>
+<?fileVersion 4.0.0?>
+
+<cproject storage_type_id="org.eclipse.cdt.core.XmlProjectDescriptionStorage">
+	<storageModule moduleId="org.eclipse.cdt.core.settings">
+		<cconfiguration id="com.android.toolchain.gcc.1831276399">
+			<storageModule buildSystemId="org.eclipse.cdt.managedbuilder.core.configurationDataProvider" id="com.android.toolchain.gcc.1831276399" moduleId="org.eclipse.cdt.core.settings" name="Default">
+				<externalSettings/>
+				<extensions>
+					<extension id="org.eclipse.cdt.core.ELF" point="org.eclipse.cdt.core.BinaryParser"/>
+					<extension id="org.eclipse.cdt.core.VCErrorParser" point="org.eclipse.cdt.core.ErrorParser"/>
+					<extension id="org.eclipse.cdt.core.GmakeErrorParser" point="org.eclipse.cdt.core.ErrorParser"/>
+					<extension id="org.eclipse.cdt.core.CWDLocator" point="org.eclipse.cdt.core.ErrorParser"/>
+					<extension id="org.eclipse.cdt.core.MakeErrorParser" point="org.eclipse.cdt.core.ErrorParser"/>
+					<extension id="org.eclipse.cdt.core.GCCErrorParser" point="org.eclipse.cdt.core.ErrorParser"/>
+					<extension id="org.eclipse.cdt.core.GASErrorParser" point="org.eclipse.cdt.core.ErrorParser"/>
+					<extension id="org.eclipse.cdt.core.GLDErrorParser" point="org.eclipse.cdt.core.ErrorParser"/>
+				</extensions>
+			</storageModule>
+			<storageModule moduleId="cdtBuildSystem" version="4.0.0">
+				<configuration artifactName="${ProjName}" buildProperties="" description="" id="com.android.toolchain.gcc.1831276399" name="Default" parent="org.eclipse.cdt.build.core.emptycfg">
+					<folderInfo id="com.android.toolchain.gcc.1831276399.598790396" name="/" resourcePath="">
+						<toolChain id="com.android.toolchain.gcc.1813654155" name="com.android.toolchain.gcc" superClass="com.android.toolchain.gcc">
+							<targetPlatform binaryParser="org.eclipse.cdt.core.ELF" id="com.android.targetPlatform.555914066" isAbstract="false" superClass="com.android.targetPlatform"/>
+							<builder id="com.android.builder.1947070149" keepEnvironmentInBuildfile="false" managedBuildOn="false" name="Android Builder" superClass="com.android.builder">
+								<outputEntries>
+									<entry flags="VALUE_WORKSPACE_PATH|RESOLVED" kind="outputPath" name="obj"/>
+									<entry flags="VALUE_WORKSPACE_PATH|RESOLVED" kind="outputPath" name="libs"/>
+								</outputEntries>
+							</builder>
+							<tool id="com.android.gcc.compiler.1389299274" name="Android GCC Compiler" superClass="com.android.gcc.compiler">
+								<inputType id="com.android.gcc.inputType.2010598097" superClass="com.android.gcc.inputType"/>
+							</tool>
+						</toolChain>
+					</folderInfo>
+					<sourceEntries>
+						<entry flags="VALUE_WORKSPACE_PATH|RESOLVED" kind="sourcePath" name="jni"/>
+					</sourceEntries>
+				</configuration>
+			</storageModule>
+			<storageModule moduleId="org.eclipse.cdt.core.externalSettings"/>
+		</cconfiguration>
+	</storageModule>
+	<storageModule moduleId="cdtBuildSystem" version="4.0.0">
+		<project id="Mira4U.null.768701485" name="Mira4U"/>
+	</storageModule>
+	<storageModule moduleId="scannerConfiguration">
+		<autodiscovery enabled="true" problemReportingEnabled="true" selectedProfileId=""/>
+		<scannerConfigBuildInfo instanceId="com.android.toolchain.gcc.1831276399;com.android.toolchain.gcc.1831276399.598790396;com.android.gcc.compiler.1389299274;com.android.gcc.inputType.2010598097">
+			<autodiscovery enabled="true" problemReportingEnabled="true" selectedProfileId="com.android.AndroidPerProjectProfile"/>
+		</scannerConfigBuildInfo>
+	</storageModule>
+</cproject>
diff -Naur a/packages/apps/Mira4U/ic_launcher-web.png b/packages/apps/Mira4U/ic_launcher-web.png
--- a/packages/apps/Mira4U/ic_launcher-web.png	1969-12-31 19:00:00.000000000 -0500
+++ b/packages/apps/Mira4U/ic_launcher-web.png	2013-08-14 04:13:30.000000000 -0400
@@ -0,0 +1,518 @@
+PNG
+
+   IHDR         x   IDATxXg6pM&d7EcED(M;bvVD,("HAA H?g33=fw98s;4jDP(
+BP(
+BP(
+BP(
+BP(
+BP(
+BP(
+BP(
+BP(
+BP(
+BP(
+BP(
+BP(
+BP(
+BP(
+BP(
+BP(
+BP(
+BP(
+BP(
+BP(
+B+RSEP(tPP(:IS(tlQ(
+):(
+uU7y>L|w>:ISL|J9f&/UAMxN'JPD'P`'Mt1,1,5/r/sb-my^1J9<?BPv85e2f<qfNy]6b6<#[}B*B@BU
+B
+ 
+ 
+
+  
+ 
+B>6R( jT^1cGFGDD#ycl[s6xM~Rc'=NU&wa_yV&Mry"fxA97ngo=JP$'Y.PoM,.kO7\4zG8*|>x\]k&!&t=RT?qdpWZ-n#ObC_r1:sP(* T  PP(* T  PP(* T  PP(zUB6[=eOEwx q^ () S ) 	/z[U;]_~.[ slCBi"-PyJwQEFx;.Vd*<+L8yx'g)]LF A
+^xt_ 06B EW8U1"l_MxxBW=%n7'k;y. 
+B
+  * 
+B
+  * 
+B
+  * 
+;d+.t(%Fm5z4~GblAhLX{L[<}1(\(}-b EHBC~_a!*W7Z?f-Zsy4-'<u2ovNi7tZO]Bz\RP(pSR5G2'Xmr33[[c7o'
+#O^bC9^)ArMnY=jdl5K9}\xSNU]Xb.WBP@
+ BP@
+ BP@
+ BGbC_B|iL=df%<@]w$6Ip?5x[iby)u.Q_G^=xZW`HmBj`l^-#{.k,1<JyaOrpU+n"^)<_PQ#{N1Lh-pPDB#1Y k^<~7rvv"b:Q(?/+_\ t
+X=Ih9m7MA~o{lyDCxLc%`5f(v]`C
+v2<7<"$nGD +xUJp_Txe6[n,~.w7Cj'=p~`@-o~xp\5k
+B
+  * 
+B
+  * 
+B
+  * 
+?_Xl|or:o]fjNGbEDX1T^5v4a@cx=m<
+\ThcX_x2Vb
+2%G)UI)9`~BX{ 
+a-LZ K`+j}yy9uyu.
+f.;@6a9K:7aYqcVnsrjXP(infkv:V7g\`f {_X'?ztm&<x,aC?W;U
+x@%D,I1y0Q&&HL0Ub{$f3X) W+
+aUf';y.=]oN{`)oJ/^2(~^0Y=}X?nP(* T  PP(* T  P(
+
+  * 
+t,LhwFm6m:eqt=f3Lf15zW+BV
+F<uj^YTj>3"LI~RTNHb/$`H-UOMJKP=4/f"JFZtOL*[`'SYm\y'yxJXe`S(
+E
+/Hr\N\h<?}ugO4<6Wy T_+e-eW2X"b	>xz^JGJ
+ 3"H:gIfG=/'[q AwCo/r[3$O\\7+T7; zBj]/pFqgo9JoMLP(* T  PP(* T  P(
+
+  * 
+ByA9U-z>{_}UT^~RXX)_l
+6i0B2VJ!WX?}> f09 F#Y#3@$@"8!>pK"Vpb4XTZF:g=6lccn:bUe~U/FmweoD[R( x{;>ztn_&=`Sw.AS\+^-#X"%0Wbs~*GzH.Aa4& XX	%Bg{YHd}7TxVUV^6Q><AYs1xs-5jutSP(* T  PP(* T  P(
+?V ~~^]3}\+Y
+f A^ 	R
+k _KyR5 9:)(VP3OkXD\) /W (
+|+ %x\S( zQP({5MaM/1)[?XS0Y(*6y5*Vvp?Sw2R?e-]  O sPL=#uE)#t$f -?	Xu)s^y!Y#Wv<k5X+xk]~i8okRJ!
+B
+  
+BP@BP(T  PP(
+?c&y0m^L{1,0e22hu^R^pics
+X$ D\/}Tov6<sRT "i( CV`rm	x~$VW z}C;R/\}hO7_'5Gg\[7<qTMxT (
+_|v0JpUq`W(LJ%fWaacW@}+y!1	n	qH{_iRa$$p$Vx3+XuDT	{(;HPq7|`'
+][\dWw<kPTA#dG+< {5mLP(T  PP(
+ * T (
+
+  * T (
+9$H iy_?ex`J{.%Z=BL@P	q?H>LEiL`y+xR^D5xCjVFXIldTVaJ@</bCwbC?QG&qOBp 6y]Ky=/I?w8+'VoM'~PAWe
+O6o\12{ LUjVS	.+aW00U({;|90Ja9Ht(\{x-+{nTV~]w{exHgE
+c$Rp^0ni !n QO&HpIwvo\yK[Dg2p2r4bB{^N<7q
+
+  * T (
+
+  * T (
+
+  * T (
+ IWr`z^	t+O<U`K-1/dvVCXL6'!y0]q^=Po?aL@j{Y`=R
+k{c{Lx$?IQlDlEbDT	"+EH`a7g( 8)g|S-9zOv
+}+o3hx P(?h^gQw*ZA^2!kxP
++W^L6xwce)%@*`4jAcv ij"fJk =hb{w$&?Ic%  ^gn	# N3 $I&Lp#ra|kls6pv*M,Vow0WxWvl|1-0*
+
+  * T (
+
+  * T (
+
+  * T (
+19L}&L+a%cRW	l
+alx\mvGL@:
+r]
+lhRD31%)_\V~CT 
+@*LD)+ 1uC v0Q5@&/VP !	9eg3mSiV + ;k'vREkxQu{MS!;v^4@PWOacL+6YK |-/t6xmnlr`lXj*b ?}+129[o
+reEF*|LdILB?!XHF#!HD@~}!aOD[ 
+#r!+cg2lSib@X	uu!&sl#_E 
+B
+  * T (
+ * T  PP(T  P@P(ap)-KqLy
+=MU385)0\A.2+En<q[TnwSlcC_V,#E$(warOkoFyeId8$xh$~$DjcgQ1V^HPQO6{ 
+]L-j>)8;!GnZh5jux/^t8Q#qs;<*
+wU >OpaT?^>,.l6$F!?IQ`WEg@& lI`lpi/Hdk<OZ0DY?qr0d`66U;yg&l5chfHDUHx33^	az!W(p,; `)6l(Xp75qx.fo<q;r 8wHK 
+B
+  * T (
+ * T  P(
+ * T  P(o9_$^k^&Xs
+amC(bM,@g%x*^pm:;lVAJp4(1A&][>i(SeMST /gMERYaIa#/Dqc[1W?
+	xVD=+p~wbwIHb1xKpSa_5
+4Rv\2|L<^kw;;WTJQ	P( ]/?>7?px0W'B-wl63Ig.F %`P#i[f iZK@^&ioeCW
++1qcJmqsXWjv_5x<nTAB^H`~O
+l{NW8Id9howB
+"|)6V +Fv ?A{-q+@g&
+B
+  * 
+B
+  * 
+B
+  * 
+axy&,7x	}o'e	Rsa[!s[3ZS^z rS=H3@ Zrsn4$MEBL0GH#s[-ce#Yaa2Th
+ I;If<!qc?O^LM?^c6+"a3'$A_/\	@&9j'$89ohc84g,PSduSpb,v^6\uD6h,=OeWG	B@4J	#jr=Xbc77IoS7j 5c v[3V{5d0F&	~Ia([}s%kWcI
+/t}6yquc v4S#D<7"b-\+v>RW;yrX9emk8q9$9!'nuc7mQ? y`$l=tCxk[M{
+OBP@
+ BP@
+ BP@
+ B(x7jY9xv>i<5,H0KHbYz!Q $f ]3nW-B2jvB6RjM>RVEuHJ:	!7G0#8V-rGIb4rA.W?N&vSt($G|<eGC\+vHPaR]G^lG8p HD
+[?N|2*U25Oa^7G<B-h(lXrzOX^NfQcYl+P(u<jT^b3i|a(L^Du?6{"J 	aKl# .I +  A r7. 15u* 7t_W ];P]WUL$zJx\>W [mKo~}[* 
+
+  * T  P(* T  P@Pv2j^b "nT "2HD $z8$UBjcu&R~)R8$z3VNAU;-EY77- a mX8"GUl?Bs-j{p:o> R6lc	 
+Q^y'zy#GTO/O/I+$jf#15c!j8r7<rD=paH\\`<?&pB{ QU0'Qblg=tM6bT%Q1+7#}Pzy8VHP\\+snOw0q$3|D[{x4r<9;Gx;?^  ;ad_Ga)C5owaW{-lyy3PV%,GP P@BP P@BP@
+  
+* J
+w[+~S=_7q~z&".$<Jp\"J"NS:?pWKO5! r|$\+D9r8V=LbXjX	%gbkF(VZ'G>/P6y_<	~W )S\&v6'!) A?Z]-7oNF$` %.j"oI)=6r
+E1c}	,Up
+G|c/f_7S,DW<yJ W{@PqwbcKHxIP^'*>@?WmnH%>&WGHTO7e#dA.Z2!lB:|{?_f3inp,92f"QkjD$$o
+_
+[.@\/ Sd%cp=|A[w!`WX::ZS)x:Q(* T  PP(* T  PP(T  P@B1]H)w>~;{n
+<V?yQRr1.?u)n>\$?K!HOV:$G[bd(&W!>Q>\DPScA|~ $~r^_xr>Nb;3SF#^P]WYIc	p6|S)"+ :  Q* KTMdvP(Rd<nCBFEOxe?ixY. p9+o/czrp- @:uT 6aXA_RV<B!ei6W[;	~ 'A@pwB.gr.w Y/Tnnp<9vX 2&OVQ)M=sz{l>
+|dct 6G
+fmi`vvj,EgC
+
+  * T  P(* T  P@P P@
+ Bc ?YHtz\~{)^XX6xW\K\oZCHh,xXWkWyPU[V?$ltG>8I>8#`\]+VaK])\'$|E6/dEz;e`gS/s2+rvWCmOY;EXDkKe9)C`~g>l7B7!OG7do;Y.-6+ 
+".%:q4/ a.)\/]{0B#(s{{]{][.2s9vp*HvQ(u((?!w rz	+\B'yqP.WD
+n~L@.s)`scWJFe{|d|..p,;k^QXa\M^
+	#qu=`7D+~Sl4DyW<vn--A| 'FlHP@
+  
+B
+  * T (
+ * T  PP(Qx. ?w!Caj^` l[s62wFevXp){N;\Z?/2we',O>hwd=a} ?`>'r6Q6OtS)oee9
+@dg`Dg8f~7'!AWAHd>K7'1 M4kyK<[o\&V)o:CR(?Ks<cWasj{}5w.eYKD\9D,'-vp:6d+IDwc^re.QWGK9nW8`eWg9#Tt_w7^dBW[]dm^ag>]x;Xu"^Kl:k)l1G{
+lkxKYXx37(y}+[)O\R5zU
+ * T  PP(T  P@BP@
+  
+5^s(<-N:f5V_\fL-`6p:
+9a#3NHorW	;MbN!gt/;I^:,[_YlhKQWaWt%|R1$q5=r;~K\i_\d3?\, G"n+ s=g2N!Yp9=f<q=m5j^OSc):cR(} 	Z9LJJ;w>S\1SI&J9Z'!N]Xb`}="~LlX0i!rT ^2@aWRQaNi=mORO>x|W|"^x/!|_}ab`	3S, f37G66ybXuQ70uwj6mV8l@P@
+  
+B
+  * T (
+ * T  PP(TWuYdjOlZow:Q.$02>
+|Std##.i?VB\h's*+r:k@{m1x2s/g%wDdIT9%+v}ao]SGbmeG[#wFa/n<'\v_iXyv\\H+.|t\|'G`!
+^=oFV }Y4S,. 
+OX N&ct8IY1IK<X($L+<BpZ,gu T
+IuS({_4O$tgwT;c##'%|vv|8=#{{\ Ln_J l:m<7F+zn69 h`Gw)6@
+
+  * T  PP P@
+ B@
+  * 
+)
+lSzxGW7m]y6xK:1XB'Y	%VrLI"#] SR0d{PxOR7L]VW6+6}lj~kDt7?_joli&&q_\e6(m`zwG^`~d`70ew9gsrrj/IPhtVuqw-zZ}Vg:1T:Z /u.%ONK@nrA/"B:Up6=ozW;e-s0JFk
+N@:u. p 
+`{;yM&'- ":CR(T  P@BP@
+  
+B
+  * T (Vt;w,ot5Wy+xprGov&N-KV"kx2'OPE|8OGi>c
+C\;cm0`<-eI_s=w6w/|lE#6e( qa7`[} Vj,KCj#
+y0yu3d*Ly=}sN( ,:S(t
+- ^T 
+ _ |~l'T (* T  P@B@
+  * T (?\hx,0?', , q/_ t/a HJ STpSZ) ?@ZRZPzt7ToEt;n/T-n
+S84Rb
+%XE+$9RJwZD>k#J$)]?RJ]i+8%[=RWM|l;.a/6\GMg:l`9)Zl#+e%{B`U!g|vx}Vo|..TM0C
+yA`D}M
+hC
+ * T  P@P@
+  * 
+ * T  P@`?Q t/yoz'(q<N	ag/TJ  ^C0CJHsR`C1aG,ZVR)PJHO|JG*vaOv) n~
+U
+t_eiyXX u, m`;+ -kl#0HwJ MjC	_8/\krX:|
+E2PhM c)'}z/xG#yGn/K`S5ffH1nxiC8840Q,20/:xEu93KFi+_[C[J[t%`"'"wpld?g;$.U~aYl2;a k>0y nZIz/n_AU 895jx7j[^evcaoCWjhQ P@
+  
+
+  * T  PP@
+  * T (Hu9"qqH.qzw8lp&Ply C_#! (50LZ LN(!w ;(IKQ |`:K_5+;L8v\2fy2y3.l? [}T, XCxFM[J=umdo4f~tqrT5j|$^fbX0
+bXxtG^z}Lc^z9Nz,!!}oa&}Pn .g4Y?gWu9=.Ml_\vBZk$T;L_rY03
+srnX&nC@N2:vmy\F^V>97q~)~%6/#m-~-~7AfY}=H{X-?}}dG;X6IaZ# 6G:B`qnp+!lO*/6/
+`M&Sa
+grrfM^ztDL!_vd@
+  * T  P P@
+  * * T  P@
+ uqUG`Xe~u7^1,Q
+aBX:3s4iNKV,#|N%sK.zM{4qiaKv]_0*hXrnA`#s`ttd'3"396T1)h>u0r_q%0d>{"-_Hm
+ 6IH */lka"^d]cvUiUoaSZ(S>er5K6_^!,.)<4W0f\^l}x!%]uetYt8umY6rWa}rp+Y_Y+UXEC^fN/K=';vV/fyeC
+}*UTtJ{u90N lr-6+t@<P#d_t[a-N=0{yX(PxWV<(*})wj-PNibE#D;[JWo=\:m>+z>X;X=mz02m])+[&jymyY,>FaukyU	la{0x6bXa=(O% 	}lWb][TCx"-Fn	;-]T^	J
+  * T  PP@
+  * T (T  P@
+  qul&90-^!,+Ce.@PEKx`W 'aEqy	c"Zs6w2`^mxB/UP=0
+/UKT%:RNo9:h9lk!Ot'-gYt&;T6iUB00+u/Lb:] ]K&`M11l>c[s#9-?` x`{{dne{GdVC4xKM}+xciI<vz|EJzNT1V#vBF\Q];2U3M+,
+<a _7VU7QRG/n=;wB<@Nu.xTx' H_`{|X9Vy
+WwA.,D
+a<`W|X5Tl\)tK9=;=+N'{gp..PZ>>o&\lBystM`0cfh6!0;#vgVzIcd1z3E@qX t++zy_L|/MCy9Hy-
+R
+*o,q`;fx<	lyo,oK=Xyz{0e12y)L\?
+"FM"F?=cco}!6Q%10w9OX,aU4U?=S9NXKwk=tz;#c5{#yf%>xOvTY6=yF  * T  P@
+ 
+  * T  P@@
+  * T  P~+Gxs[%K}8n]^rjl&n&^P],BRk
+eB@^obNOnjo}[U}6i[7>s?Tno+?plW^PO}^<.lkOxw~CMNOWb,{|-=8{;9<%2dj+152jnk LXMZWCma7v6u:@l#d.cXfA[bwh?`\WCdfQGd)>2~q;-2j~152lz+<%2`B75986;Y:3ck0N{01n6m.F%o^-x}Z&u.=[5oSl:i;v@exMj^`^MH0$dQ:>&?<g/r6p<9zJ8p1lv(__[`jWPWhnjI:LyT?Sr</^bk/f:z\fUsyHB$rZ2	).\>dW;`>k=W;o9k\[s`1)Z)!c'r',c!S`a/ka^Pk7@,Z^fHKo6_#~6iSVDZ|	&Dco3;dCX>Z 'f6M>]F32} LR"SVtWILJ%F/4eLZj_lol >]"#[!Fn:9|7'}Z?Xo~6WUSXY#W.HAv0`(ws]z<3pmoIX~Y3n;iMg ^`@R91X!#;5S-Xa=oFy[oy8J&NK@
+  * T  P P@
+  * * T  P@
+ mANO7hF`BNj$Qs[ 5@\F/CE<[w62T<N[0go?7Om/(o^pe}HHRxmI-~B =?!> =g+_fo!}&7/?{7O$>fo?>m?grx_/we]{H)|3}(&M{'oc}wA~CD#hvtu'2`BSas8<rNkQ:xjNNYa-n5<Gxljy-C6;!n/	!p7Av\2nx|3g:o5oG;mOK?:`yC|RT5j;785|_R{Y3.d;y~=6S)]4+JNuKJ'c1?aWm&u']zlto)?.YBu}7lDFiSAl>C,;~o#_|
+{wj8._>__^{xm|:d~Aoow`j!?B	fW5g2rNs>SY"n<'y'.br-eWx".'Gy47xc|y}'}g"T  P@
+  * * T  P@
+ 
+  * T  P@7.l  O^?jW=A~T;~H~xG^<uaCD`;1p{OYZM[-n^ydx"2b z/ #WA|ge:txxpdv[uGa~cdn#Xb 3#[##g7A!L"}|=>Kmd%MO'H^L:|b?3,N>>!V.?<?:0+mxW~k[LB$%N8	n-RjR9s&>7omv?,as;2{b-,%#+R, eSB,'I\jIkr`Y,	7;F$Z0vzhEGg9y$e@]@PD+2Z@Ew2HY'WGx+"nnrf1cnL"{c@o?[
+4v wj i<<+#j+\:y2:8,!H~w'}CXAH,+hjq$8[sW0jxvYK{Cux}	?u=/a|B#to03&"GdG/.@^0|;Tv/=g[lyw,[*VspRom#5n,.tby-$
+YcZ s4^l3d<#cvccfcf>fh#jH/ec#g>F{(2aQ7>{>l~>li9\{eBp"lYtIXy8$B[Y~?pi:6,#PmoHC~iddfi=I_/5Px{U6Jm7mv6@vgj%`{V*ltf< JF]VE$`                 wi T(@SK 
+_< ly |7I] W zP$;i1]+S"4)qa\G}{)z"	{ Fkxx5^pnLLsA1DIK#|{pf^lA>o'dX!A,4PA@}.P~CB1By7w@691dMr;VL68 IuZ*;Ydcd>_4l`!-OECE[A[xAY3F7@Ael<mxdg'3?b9BK..cB]/v_Kg!GN/yBg+[3c<9p2O}5Mfev}2Afq2>l}kw'k>:i<25jmwE
+~HFs5:3]XVVbQd$t!$JD<
+\"}\_ls
+}/~ Q_3]P< Xk< t*nrA78Jip4&8 v2-\#vP P P P P P P P P P P P P P P P P P P P P P P u@k|za0T{B, 6M. Y! jUs{M]k@^jnno*l:m8WAO9]a1HD@1<WM 9m'EbGcc<>@f<?A^Cr|vQ>|bg)X /{y$?,B~|>a}6rY|OG'/}KM]O#qA;m~g4m>=YvM/{@>>;>8(UXjhAZ,a#kmC"0lY9.(Dm l 6>xh"b!nr6?V$&N|^qrXZ-Tco3@ XoBSCPuCA|eP a,A{#\YAllX3rJu~a,LKCPj~S/l#dZ^QkQ^83.#;yOC=,94Dj '"\ie.Wxgj{`7l:uRHO5: )<uuR-XX`6+dv5a62lO'y(8rk%s6:-bP;d o.HvB  7-H( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( (  (jy D(.? 6O	8wnf-e	# GL 9U3
+  v.F4yV@9!`!^Ce_/&LO v\>.T>5!sv8|4`;]\FL^i
+zRZ! Jnm j}^
+;0 Mp~EP0(wu|Y6q[rVl;]WngYZYM[k>5ut^(ke79I_0j_XAE.)ap0rOT Nn%T? 
+1kUOLs)RN()zJH#hM;|H|P~3Ji9?<1j5%N,[B C'*}\wIe~Sf< 6`kjk WZ/%>)(B	e >kCay	6<nn;4 v pgMzuT@< }d0iQU56v(vFqSPd ],X# *Q*#BTTk!7d: tXD'Uo SJc%Xm,3-q@n.3(* x ;"1< \0 Xy
+@* +R 0;o9=R!
+r jh2iA #]QEV -3@]Cx h\jQui6sAYAGyNP1wcOPQe
+?OLw7)NH[	xA.=)=t\iWEiKEgmr<;x~<|HWZ ^"\G), 3O>! X`y
+*AIuJbn1_J|~x1 0v@:f[3R ?J       .
+ 
+ 
+ 
+ 
+ 
+ 
+ ~ X5Y! D VP/i* Q @Zq(}eG0'[n LXiakb- QWAWUT@='~VJxn)Hb.]y#RI1Vrvr@qK~fL:  mMxa6 heR 8 L?]! U.vH (S) q2@6s*  iQ  8vY4af wY `3@nMjo2 $	mV
+ ?d) lK sH@oCJZymZ-[A1[il)rJ1j#AqMr" wPN>;"YYz9Rm+1
+i9Rhmz!Z{AH7WJW{|H:PhKktYhX/C,S
+ A/M{>q Mm 3 n#<B+tER# =>4;b1su]                        t=>$@q\F\zV 7|.}Hm 8R3F5k-F-Wm|iN,I@iJv?@;7Dh"-X$z;Rk}yjvu_`|yw9kXYH`(?9] -6 1-*``*r+Z'_'~z3f8?AzX_E,*v`HH#p@+,A|!|C iyP@W%|KNyFhLs
+Js0T`9}
+= 9
+ 
+& X v
+>4_! .>F AiM>(;!bgS P*ZRai zWMloQ#I>f.Fs``lHdVs${FlE
+ pC
+(_:6/b*
+ lR u Z$,`jh ,r^g.[y d(@< B`V1sF(                        ]wb L,h`PWC) {S/IN,`i	5fY2hAT3{MXkD :I^ymr5Rm} E  D HuqbRa[!VKpK${V-lWc8x`q$9n={}?)rM]zp;q=/CVC*wMn"9X&G$m/,jCb*n+@z8O""-OD Y"3{2o?3sByR ,vZgjejk% >09n@q9 }%`%PHqy-D =1c  ]lD mb: R#aAYVg>	MXs1=@Mo :>! p ? [ 
+Q2 N]n2Jrm>/;' E#4"x=\Jap[a{^B-`6B2ZXJ9f7hv1 -tu
+ j@+B P 
+iQ
+  g~ O ~`V`z
+ 
+ 
+ 
+ 
+ 
+ 
+ 
+ 
+ 
+ 
+ 
+ 
+ 
+ 
+ 
+ 
+ 
+ 
+ 
+ 
+ 
+ 
+ 
+ 
+;0 .iP)E<l[UEm HR-k4H|= G# >g:M\h>9g[t#U&~$zGQzw@x`vH/UVcl!95,{Anr`{",A^p;;g?c.Dt\dCfs{@eo?>7e
+*vLf=[VH:;	{LNSlJpvN%%Tw .LPgiLj(<H [,K8A5vVgA! S\/
+ S<xvUhPp,A3(  80*9P  * @M<T=/ vl l`  HzkD]d3A|oBr"_Uc KDs>ZTG"MV,/" JoALN6 W 0 T@B  X`cb TD l .
+ 
+ 
+ 
+ 
+ 
+ 
+ ( ( ( ( ( ( (  h~fUSySlPz< 496he U$@)  :uC8	P b	':"h  $g
+b lwQ- ;-PwC\:cUZvoXE\Z,Cd'ON!.5B;Vnd%]j%w?A})2Yy,KZk)Wo$7;R\?$t$_1 jdd x UP>,ZVZ 3x 0C<yN;?SZVX,dPB]n<qg`WZ: dG4;7&Hbr>l +.1|CM;( =059v:  *@dYu}PSKd~!c^@{g S\t [ %YbZs$Fm k~ 6tkxi C ` tQ P P P P P P E@@@@@@@ Jo (oUZ`2[!tU#` |  |Zvne/16h85
+V*@F& <'( (  h{>CAeldR 5eE.YA, XR=CPX-BG@41KmWC/ >?C*JbPR7H390HD8$?xm
+@JCG$kKjdg!|#:}nB/_B2.H,|n7"7Mf+m*s]09S$d]+I5<X |C~7ok6Z?IvDs^{N H) 6u G, 46~@;3 *vN he@W 7 !t>*|qk7 [bAQ?tHV{:H";F	7'?D	 0MP](]<yyg>D`yG M"v T 
+e@w7V] 5}( ] 16l,TsZNar
+&{ZSG*@\-cP*  o{t5k+h+%q0H3Z$"@rnMy[C\(]*"3^c(@{>ragX{Rsp2fo#t*G6[: :ZOP3_*liI6Gy LC4lZ}ZPm'vU!q)N (*>, CN$cHtsGR
+ )       tQ P P P P P P E@@@@@@@ Ml $D x 1Pb{HW>6 6t Rj`Rmq@LD?keukMaJ'Q 	 pL5/c;H,PIy $T UX*,  kn eV K4;Q3( ] m*vO-l)z(l7+$GB5b1@ AD=~a)hfM'_9%{J,w(A	61p0 FV-<nX&r[
+jb@$gxGj-a#>_e|z].
+ O]sL$l.-OR:(Rj (p`yNHhv?K5 t :s< x tl  o??Aq"	
+1.f>?2                        t>EvM*?sX]2 6?_}5OCPW>T>T +U m*` -lwfE`[#:i\<yW_|\tLa?l4uco!/}!	,,a&?%VDRg$N>hT $2,D};E"w?}kD) :?A~:-V$[u*`@ pT VN}6lTkZFH@jJ D) RHND Hw(> @x tx_kN]Mb_QCJ*-rd
+ NYH` * vH#%7jUYH'XHb6j!bO,rD+ul|Hyw ON#;w'XMc!(@'+oArF7$ICtu2 v0|(_(z5_Abwp$-;oL #< vghyQ@:Y l29vFnSf'D ( (AE L                        #pwld> CJJmW	 t^=xM}Xe X1[R R6+D,|h!H,{]lU1-R#mlza}1fv;\zUw_C^{V Y&-, ~Yj?ag1{He"Y?'t\cj%P Z (:*$`89zi>=i x*V >: RVuJM lT j2h9 O*vLK,<BeR [D} 3{B?_ u`# NSBD	 eW>X3@.KDNmpBBj7$TOdYNlI'BKO
+h^_S5.\d_@6!ky>d,$iR.~.]F~"u @|HlD9 b#y,*w5&[!+=cG@c-u 	Gg~:} M|N J/>$v(tJP`2eZ(>D@@@@@@@@@@@@@@@@@@@@@@@@p rz({! S)IO3[bm EZ# "g4@S^6wH"@b+,_eZ  H0PBzP D>~=6nT.Ehg$4y4O}GRP-r~Q:^KHMs6+KFEAFfBq,< kb/3gOs cXrHt[nCR(+A@$@$R <`
+88!Ab.6I8Q?_+PFB lp1- %!]MJS 8,gOB?
+)6~c= O
+, ]2 6CaP?t#k.yZUMo`W;.#ivFDt52b_YDB'#+3_yyT]v9'j:/gwG`s nCzH$<yyG/+|"I=%kX@|)Y .`3Twhy'!d `2Z@R 4O]" PHv?D                         C`A 4#)v,YjN.FN|H)EW[ AG<noL\hsr. ]@REW`oE	 N2uF $IwC]xXw9f 3%_#o{HVYA|`$:smAv>*[,x?{`BC~~-)/ko4mX"l^YeKbd8 }t:-riU3gO!"yy!Q%,&V;"S'RL$|#0O7$Y"O(g=hQuhJD%+my;@,Vl S 49!" ' @\"@dNMI3{ H@ |9 , jf-5 Hr`9r[;~HVKO"{+g["W!bQ2#o8--j? Av@">z?I`KCs`C,`l]Gpr7R3 N#k"Y*O$r-,@na DD ` `7TW8`W  7 [  |2'&s<&P P P P P P P P P P P P P P P P P P P P P P P P u [FP18S7 UX]SjDkXD
+5[!j@$@e>V
+	t8Yzk;d 3`&	g h|j	r" d(w)v#U"u3^hs6?DD?V!>3BAzToWQ 9^{edzY&.6Cfa#%zc{{p
+ptQ U#YT0$#+d-(C*?) a|{!kf>>`qe7Y q< RPz#}'$[,W ] I]C[gfZ~{)wt L_6 rx[=)X8tb67!;_lF`I}G}\p^G9GFj
+}Gx6?
+ccUnRTC* p `(!x;7i *! 2n" B 2e( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( Op*wzG>es>4<% } e#U N\}IBO'wab+ vbJ+%@9"%AEJp3U<Ej+_V{!">F}Nr7
+O? o*r,(f2+2|lz@$p}kK*JwlKM TFaHX5++
+{2,td
+B,E"s,O/$Y OOY?iI/X(pb+G#$ 	Q$MN,2ZMy HwR%f
+p6,sAf[?    7 j+W//y96v{r{"1Mo$,a:@^e#JGe  YzIDAT"baSK2C<;$Of;td9">R 7 ^< n (                 U" *~ m_! x |HKEw#C&1fG"!+ #=wp:qgA;e!2C{-F*{=?%r7ZJp 7.^J5{y l=dUV>$nEZ%+XZhL?HP\.|;#mkHAvLXd3ee1|CqF]^  Nm"b'H @J9" tjNO~t!+m]gdnl	'duK3'!F' '"H{n] ZU}q_|Wn/#>-V"8Y"9,L|"4lY2m~ X~  ,{= >lv48"7Qy-g2\Kc< ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( 3 R 0qQ#?6g) ^vCIFGQd2K6y-nP91dlI(C^zsgU.3(rkn  n8 ~ p Hw1J`u
+ :>%@qPW _$%VTu|(@ E 3ly}D 0h^xX/}@@\EP? X8hQ  M}uZo	r& n'j?d}yb?\7r_Xz|9}{T?v5%gz V,("8& v) 
+Hd >= ! q|C> WaPZ|` 5>k\F";"uJ':.H`qI&y!g
+ 
+ 
+ 
+ 
+ 
+ 
+ 
+ 
+ 
+ 
+ 
+ 
+ 
+ 
+ 
+ 
+ 
+ 
+ 
+ 
+ 
+ 
+ 
+  $N: m G@j @Vv` N
+CAe vo_L Uo`!}gcIj6$ >t.nu^xe hU.T+ [V>Q'ioB h 6BE \@?$0E*qA&>_ w./&h5{fow
+pIW?\Q
+JP% m 	fD LiK#'*}KJv!@z<OV< 2E <@Op{l3Uni#E>UwWCaxK3Hekl@@>!qoLQ
+ c#0qo 9CYhCc2d=$ $nh	\|kPZ#yuB9" ]*s\ n@\#) ;Y~Q^C#= rr4=3A }F aB T*@-C,eay$(fIwz (E@R HCil2dalN[0{aG@C<W:` 08TeX p )@&vl`B d aCTHA wY l?W3l 8d3 
+ RJYlUX`aE8}Hyc!o7 |c1 )S  mNL_o	;? 1 }O7;yb3#nA7?8|;nt /gN5tw$(@vD;UP(@XPlLei{, Hmt?O J VCbl@P,h>4hL?~d9Oo                        t|_3wq_BYl$@W1@I|KuO"VFb"@>kdX|S! EDNi>R
+ ]Pb-Pcj4@Hz2Rr iG\ t J jbm9dv["~0; ]\s?  D@P9b
+ >3x;1"
+5HdE:a< =lw>IaK" XbMZm7iAT+B>r CQ
+EH@j?(tB wU Y=sIq@9NV FY 9& B@5naM Sx CR
+1G!]p 2P   P cYdO?:	3gN'@,g>N\E/%r 8ce2 }h@X7 iA $)r DP P P P P P P P P P P P P P P P P P P P P P P P P P={->[LaXo@x $V2L$R[a[nG
+gX*@o  rQHW1@t R-rx 4EvP 4u|C3#`Bze C 		blk$D#"
+4B yHg F'%+"< !c5aIS, xYQd S iFGluV rbK)|'< SD8w@+#]<@ `y X7 H@/ a< L# b+ -6j @] X` hT@DB +U0EE l|c]o|,  t_(A#) ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( `k=s HCR klJ	FJ|(D9 d w`< F)b%|e@vz{U5esB2>Hz=} '@a  _>
+ ] |C?	!
+ =4h%4rUt$;/17Y9 t|C$fGDiidg8 k,BcDJy !< :F8]9yw_()Nu[ +o4 @8 / pNj@/  H HQ 7 (~Wy7;bCU-,:#(u|3L 	?YY%Oz]bCFw2z1Hm $uLP>fTh`A`<  j= JGMus"do}x9 HtF-Yp9"pq
+"{$k,}1(m L9 yZt'iz'M|\/2C>IB>E <  PRjIEcbKP=
+'
+( nA{,(:_= EpcL@@o !Y \|o
+ 3eVzD@@@@@@@@@@@@@@@@@@@@@@@@o{1vd ?KLynu?<MCHX`M>FF) "
+<kd(&.29B *F?{Ub 
+|cI @"Pz>; T|Z( a	. _>52_kyHx#A,<Jw3@&X}L^2<Qs[h$;Hhs=p;`&VUR< _(@@) 1/yNg!o=Q P P P P P P P P P P P P P P P P P P P P P P P Ek@] vE {ngN@, "IVd ;	hLuC 7H}B D ,.:M(uB 5@" ++md*Y)Y v|H(FBWY^ 4s,z  HuBTb	|K9%@ JQ EhP_Wo	 0({( "x {+ s>;HA.H`(`> 	cay$/DbHdpcxh@.52iQ4 <wK_}G! 7;)fgzG$y_h{[fgbV;
+1?yEf:-txAQ P P P P P P P P P P P P P P P P P P P P P P P u g@#k Xw+b]4 _.9{3  ,y)`'W4BrG#G"I|["ST"@Y $+@ vnQ7lyv<<#] GO>fie[e:.| 1}\lX/=7@X#< 2-|CC{7B\>T6)CB1( e>_ERy {9W@@@:Q:
+X) f=wG HN|WkFk3D$(Z"ny ((p=,addec|TdfW&,~rd:Mp(\ bi P2iM"#N*	1@YYeZ#1p(<0y{; X8~h=qi< 4i W29 (LGc!*E * RGL o Hovp`+D,\yv0};w?|._\ L:d~2 f<K{`? " 27 |EF	H\$clddE$ i,A" f>04^`2[#HZcJ# ]M 4*@-{Rj)2BCO,64?h$[[?A wT I)=Y U5tPvjfb2@-WZU,?7@Bc2, e3cE" CJZ5\1+ZWVuH c;ZhT3 E4HNH-9&w_#.SI^_?
+n& >Y< ><	 W(WN}{H"Y!!g	[J) M$L*[D@L;VbG#Q9lY2qq]aXee:.}Z`E; ]\k@M.2|K%uBtu=WaoZmw.rcPpcK<zqD.
+ 
+ 
+ 
+ 
+ 
+ 
+ ( ( ( ( ( ( ( M@^EAC?P*lq(@ 3,Or_>zhfPBw(4fL?K/H,S;$dxB WZ:)^m)F=+'eW^ANS xgoPFRtp<r/+o<*Yl@d~5[8"@:m|u yJ0\ ?f	E/?0wO[[[Q.u3Q5&V7@nHz#446I$79Rg}T&(dH0d#2t9NGY=8Po$Ti*BV2
+'J+cleT*/ -/{yi{hi9/waA({T WV:t UZ + iT@T9?X`76IY ~;,UR um@^Ps8~XAE=yM/6uE ~ [0Y53		JbICI\7E}eoOp-$2(4K@Rk3F]2:2=Pz0TjP]`=X5#p`GQ
+}ZY>}D>?tDS.
+ 
+ 
+ 
+ 
+ 
+ 
+ ( ( ( ( ( ( ( m/1!J&yPBWMGx,B[aaFUVX10 dZlaqnnMY1szA` SXRx?4JW7&T9u`@H^Nu (Hk"+0^lNh0f-/eo""]zQ0PrHbA>Z"F YvSgGG<V"I9Kvl}DBrlXh95?OU) 
+" tD$$e4D&.{y  Y xu~Xhqe+Z,+^Z; 6yVL7"2YS)HBHCD`=;rxPh= !3giz@"W8IN?^J5%V>?VxeUyNW\>8	4HdX oI/K<$$$EJ{zjWJw[Bp$.G.;qpw#v~91^'gy^=H~3F2bR6qY5NJ-{&Ai3%[qxRhD3hL7p;fUtY#MXB:gVGN?4>Yw-{og7[F+wO Kccvidj Jy;X4"GVwEX06-|7	9 ?aY K}$! &5Fo*e4lT/!zNWGjW5`%2@A2YT{m$'v(z<HAz1:A) ( ( ( ( ( ( h       4
+ 
+ 
+ 
+ 
+ 
+ 
+ 7K{ PhR)`zP@)Gr(?kD}Z/WmC*~\+n97xj$:<%VGeRJ_)qlj~a<M=n@vNy1Jo,@8pW'2!1gV?Tkb=V;[9^BAoc{Ep d\<	R>|g_9d|k`H5:"J+#ezGVmtAj{]Y}qg1L@ ]@ l!Ca> LiHz'/(0FqLq>("
+*^;y<0Z;Tu/%N>QEf,C?& OPj7&4s-CjtZ<^Ykw
+*{7odz &!H^RD*/`ZV)Xv}3nuv$pHjm={DCw'$oi X3,aC%U|:}77( 3g!+~:@{x/+8 v[gg|f)Gj}XtHb=Hcw8Ol5y`<7D=Z'< D ?BV*V^7Ox8O);fBOeS?Sht[+)B=I4PiE=Z^3D       F@@@@@@@P\)h% <nLHJ5^ZYR*}+.UA_Ai:O_rk3+r\;(Fy!?oILCrs<D	$~G+ &"4z6H'X@3nuud"?;m3W-?C/\D!i ]%2wg _gm#U_6+XDRc
+	)mwbu}pjinRf\Oy"z0 $f0\ bB  rNcZS*^c98}L[7Wot@})N}n<l?3xbdOrVMZ+MV@_Hv9 bHvZb_Vq*T954;C+m:T	yB:T&Ty9ekyA9^)NqPjm-b{C, A> @N)}@z6(FkkaUGCL,4o|ko|gwC"7 +{S> p<+_g|/B,.Tof[B;$:!!<4v=@xoQ  (uw|'Qai (n
+hjy? F@@@@@@@       }pS5nr*72+y_f`9d48_!.DCT	dc)#o={|JJ?ZN`]"@[  =jt1pFjAb=G:nUC*Xi4Fm7]i^D:O yg(@~O%dQW"~,)h<O*_5h$Wu~L;%T] ^ LcB t>d\8G@*5#p"HZm~zwM=FKCAtV1+S qqVPrPJ>H}C9 > c 0 K|9vf5R)D|-N ?f_FmK@2*Y.$Ou"169/	q \t_ 	 'mn  0} G( ( ( ( ( ( h4
+ 
+ 
+ 
+ 
+ 
+ 2#B\"@jv @[||#H0=is 9{_@7y]{k
+ ;;o#?|)dv qw#| l
+ N?C`5  bBwkZUOp,s,`IM?DUP]hTY|pUJ{q\/f !>g<2X|G>$#	S}#>H="CH1O gWs_XDB=^}+k^? I~G>Bg};P;$Kg;Dd~~=O8d`>;Kf2]?k>8|3Qi<$B( ( ( ( ( ( h4
+ 
+ 
+ 
+ 
+ 
+ F)/)D l#O,=VAsY 8 e@&z6Hl oCi\XEP{eEQk`!==rvWD^x3_<^6HFaVA]vW Q|v KWp#	]/kJ@K_( h($o{_@b^3M^}	3W^&+|{`+osW
+("g,[
+, Yg w[m"]++aOAk*gBy7_tl`u%C-6rW*c_SlY(
+O.gC?MbdnDTZVTxT	R*>A_i4
+ 
+ 
+ 
+ 
+ F@@@@@( ( ( ( ( h4!k<k \|z 'lsNL4q1H'yb)t(;Xex@xE ^ G XR &{Vf8XA3RbUzD#M,I-R{f~wXT|*ZL.V 0:R (DCi	~:gRtc<tao,slN):Z}|4:K+`7Y>xAH~m`PBzu;w@rQ#lspe=pDiwx"y~zgUt#+y]!44;.?}nUsYx5uIT~Mw	|>&nIb>)wN!SMe;'rw `*9NGxB@Q P P P P h4
+ 
+ 
+ 
+ 
+ F@@@@@>0ujV0P\fBsfsZc kXPL!}VY$ 6 EtuiveC.HpwD8Mpvi5pw, *j_z;W_(L	FB|H?:390ifBq\]g8rr[RZ,{ Fha|M BABl_G:cLy<Ogn^I%!{g,dA \ -L {]
+Z8X8&z}j_|/UL^'Cck||V?D7+:%	D7N|3>iM1rZ3Tf(juI:W-4     F     h     41'@x5BG|1hAQT#z}N!AA]+t@D8j~!>e^^&w`>&]OQ t	3uKlHmy'nt?e)?3,b9?	/e->"u44\h$[8HmnCj:^.ms*')nnRqULjEh+~W@+| @3fnv4i/cgXbPJq{1vI-MuM[8>{;x7M n[g=[`	
+:1BgWz_yO$E!)by rj1v3{6TVQwKi4     F     h    4'wQ$
+)o^':5z$dqi@7345aqu81sHJ[bk"a{kAHz96 )oK+TwSdC&.#8yQW-'zEjHb$G L?M2T 3k /om/sU]#j0BV_^&	 }W`fvB=U>5{A.<gq"6>.t$[IAWS6X0DWyaHZ+J!$z7-'g+*.%s`[QW5p*NJN1xS	R2st1R,~:sh#fST[>?V%n!=DHe
+<,+i4F( ( ( ( h4FDO_,GM([pp jRC^/+^C4|.>8UH"=,ldp5sDz'#}$Pj,/YEGoPFDFfx	wI	$tNNRmAvZm3V2(6DVY
+S#gk>If$D?(6MDK;GBM_|iQojML*rOFw1`GcBt1P>oA5=nqaP+d{6.+B6Qo
+dw%Ag5Vj%ZjM}1oIz`"!9C|x;;!)u:Kbh+[$cp#Kb`_b}XRYD2qt!^2+t^5<<gv3*j_>:i4    FQ P P P h4    F]s!1;fNnS/C6/Tq
+[%Ej5|2taHt4KBzC``)1PI 5>>VDrZ \i#[jS>+#94nrES,R`gx
+2$;]*e#[{yHJ:OT4U;K4ajA:pH5>5L%Fx?vc%R> @?Hm%J-t.'N&@0#11~	2^FK$L"BZgZ3CCyfa.U("%v).D^zOW-FF5vyGWHD3K_MWCmSmG |>K&D D>F    h4
+ 
+ 
+ 
+ F    h>
+O&b&/o[odTrK,]v\Rae9\NVz>%5lb\H`Hj2Cg[EV18]*\Jdr?@`Sgj}u6s?6@Cld15[}B*rNkAhbKc"lh+X`$D?ZGVB'e]HYW2(.AnzIIqp8C'oWN G2J*:%dPL=G!%aYH~+:!7V4?m2O!]q|#chT	#xW!B LAzdFVGl{RFbI b"8[$}Pxpcp~pRc<JuHI%h
+r+BqXFPKD]j_E@h    4F@@@@h 	C@Yc6rD4{f/bm!a6u""ilp-G$dd?KDJ] ^%2qj dLyL2splBj2/>G[PK=!kfK"K>\<}Ev	xD;NVubU.W*
+ Fj / flo!dh*sPJ!.. brX~z H;EH(HJ1ZeK79#*WVFYGH7ulW \Ks1/cq>;B=K?K:0EY]O Ree6/VMH~vD2*;,eHlQz?\X$IiN/@rJYnY$lx(C0bn4F( ( ( ( h4F>0^
+8]l2pPZa. _ QXdA{y ?G5TbKJ;$e8"9uPZ<VpCGC9X|By[N_I}2'C?yz(Zc j:YUV~\;
+VD
+%rj]l^zVn!' A >DfD<%HNY8HD%$ yF}t2~cp5?
+#WcP
+Zlze#Hj<L8#3HDK>,p	I$,wh
+>t?H yccuBiu`uq12zAH(KO1//f?N. N&ARJDFbsWyHB-KT*E\\$:W_q
+Mro@??PBh4
+ 
+ 
+ 
+ F    h4
+ 
+ 
+ 
+ F__3gTmt*%pq $-G QuaIG ?rQiG#,40|E;");PPa?Xy&c2)oyG@-@)J_Osqw BpEd!$&Qga@P* sdps	
+ F`A |7}nt!sATe;T~"*[]odT
+,%`'xXV".F":(NHl=zt
+O"42i+r7SR*QE\h3vHn]=p5XrDJ;	?wKPA2#U"3
+ F    h     4F>?'3y_?CH5jnvfP]9N{VCmeT
+,Ex_	&w@@gw@ 1P*YEHp_K9`"p/
+~l&'-9Yj2RJbdQ$@/P h4uv/L}jp3]4AN\#p@*:X+ngX^2!={jU<	"@Yd2}\L. ^x{ ^ 
+e)~|7Rq~ 2 '<=#@O+wcr%HN7Sb5!
+ F    h4
+ 
+ 
+ 
+ F    h4I M=^f+{+SOpP3'P^'>GV:,aR-}z]R3kEeX@9 p "Dz;KrOSaH~](* -\wY<'( IEEyHjDFDfejc\ZW
+ 8K hk<:01H;A| krFY]V*;2=:@*,e`);:#\t KkwNt&%(0(2c?.}/s/J)x%Va'U:z':HV1.Q6 >Ba]y(,F( ( ( ( h4F( ( ( ( h4O?|/(qP](kte-|@Q4Z>*308!%:'V*j{$nB@( '\Lag}@plH}R(:kBqr	Tt#,V(skrBgf'$ETY:)nPTu h K
+~An2Gn{ '\j"aPcE!\bR]G.6f@ ?5Rkb_rogPtsLC\b,c5X^DADQ)3TsyM/+#%C 4F@@@@h    4F@@@@hWg/|\Q;<_pywN7 nekrCqC +kwe.ordvXK/sER(6* E:70(>9>](0RvA6,kr`XQDI+Rs??)8rj;U"eCQq!'_xF5 (|!!  Or 
+\;tgjb@}n|`|'D*Q;q;Pl rwz3";^^o><*2(?s!m-XEBppr^AZG}R@q 4F@@@@h    4F@@@@h: >dqKXL.
+tHXk<X	6.L|Y6:`N,(wv >n | 4u&7T|A)Gw	{R)msb:gTRm`5"Fwc\6`H:B?
+ FbI ^{ /F TP"@itbHF f7K1(ep*hcj{D8YVvIXmR@B ;"5B tE  4F@@@@h    4F@@@@h~ }
+_5/ vi&1'k=$Vv#&<uvJ$g$E> Ux#AYu]H
+[1THez%<%$H}'@.\	3HJ}BG(..."u% 4	 N!  u6 h	vi *  4F@@@@h    4`gC5/. k PBrkP;h m0EZkeFs9 FWi tS h4 ?rvV*{g 7Ky0hme,x"s|`m3
+	N`#y@W%mNiTmN+s9%:FtKa%1KwRay{#AJ13Bmv\i=Xu3R&4)-<4xqHCokD/TFS\?F( ( ( ( h4F( ( ( h4@ z n
+ $ <XCr?
+}vC%w:Cw v( 9_a?Tbg.PB%:;L/\/V?c<`-^QoL.  Dj{$T +5oAI.H+@cN@h 4| <TKPo2,'C<2AN@9^@i/1@.^~J*:*}JYx.9X
+;5 ,9;z
+C&_z#X!ZNw|WdZ$Z%>(" w@-P|\tB+;h4
+ 
+ 
+ 
+ F    h4
+ 
+ 
+ 
+ F? W?Sw]> <aQ -6 P[ gp*tH|fb)`C O}`Pgo\9qT`L81Wbq/	HWb ZLQG{e[/'/	LQ"F
+ :-y%XcA}~on3(~AX@lPM
+or2Pg L17A)?!9yIHUf`6ThsbP,hL$
+%6]w j0Bm(c]8Xy5nh4F( ( ( ( h4FnJ& f~8W`\gXVxAK - /fm3>fp94ys7W*;=vO2n!|HIuJk/!z8_5xL
+D5	OQmW<8!\L;Z8H5hA}Tt(Ii&Kcn?TA?FNx~wya:m~y Y_	j5z.@]>o0HrV1f&XZ}\|{:XhLKcPBL> f<mui~.Pc>DvUPN7l46*T<Xq&-h4    F    h4
+ 
+ 
+ 
+ F(LykZZ,[}:QS>\bq	Z1O  sA\(/3fk{v*T=TYc{OB^n6-	iCP-/tDw$zV9fTi+J7dOE3JMr{R*[E4vs>&U2p@z$@{I_jZGYLWRPRa.r p^b#])T}"Amc;
+VSPQ{^A~YrfTn&0NLd\cJ:N3<\dLE"!S'r5A@Qc^1W4F@@@h4
+ 
+ 
+ FQ P P h4E31sx%M&Aiz8'$N$?s&ter,kFJ;zf$`L|CK)SCPOfxq! FoMWh<[AsWI,>V/(6pyh+iCqN4{{C:mKh45{Upses&T^_
+4#X"'R,LgKgrxH\>OtMJ'
+jAu2*/  n}W@?z}7g4m?hbnR-= VH,?,<RDVz_:b[s!ta\R h4    FQ P P h4Fh9
+VUk;=ER}varRG~u$9m4'=iG4#P@d<b
+j	8Xw^>)n6L@L4 r7,(:[0	-D3Rz}!l]x~uFRi.INU5=aaJ)Ae$aH#XbH4\X )u66 =ju.d#4pdAd;{TJ=4C-yKoOh4   F( ( ( h4F@@@h'
+~d+Ts{CW]P`-b:_)Hq? 9[MW?o"}iA)wMn%|-h2)nEkF8p~q >,K@h    4F@@@h4
+ 
+ 
+ Fh4Fh4Fh4Fh4Fh4Fh4Fh4Fh4Fh4Fh4Fh4Fh4Fh4Fh4Fh4Fh4Fh4Fh4Fh4Fh4Fh4Fh4 A    IENDB`
\ No newline at end of file
diff -Naur a/packages/apps/Mira4U/jni/Android.mk b/packages/apps/Mira4U/jni/Android.mk
--- a/packages/apps/Mira4U/jni/Android.mk	1969-12-31 19:00:00.000000000 -0500
+++ b/packages/apps/Mira4U/jni/Android.mk	2013-08-14 04:13:30.000000000 -0400
@@ -0,0 +1,27 @@
+LOCAL_PATH := $(call my-dir)
+
+include $(CLEAR_VARS)
+
+LOCAL_MODULE    := libMira4U
+LOCAL_SRC_FILES := Mira4U.cpp
+
+LOCAL_C_INCLUDES += \
+    $(JNI_H_INCLUDE) \
+    $(TOP)/frameworks/native/include \
+    $(TOP)/frameworks/native/include/media/openmax \
+    $(TOP)/frameworks/base/include \
+    $(TOP)/frameworks/av/include/media/stagefright/foundation \
+    $(TOP)/frameworks/av/media/libstagefright/wifi-display
+
+LOCAL_SHARED_LIBRARIES:= \
+    libbinder                       \
+    libgui                          \
+    libmedia                        \
+    libstagefright                  \
+    libstagefright_foundation       \
+    libstagefright_wfd              \
+    libutils                        \
+
+LOCAL_CERTIFICATE := platform
+
+include $(BUILD_SHARED_LIBRARY)
diff -Naur a/packages/apps/Mira4U/jni/Mira4U.cpp b/packages/apps/Mira4U/jni/Mira4U.cpp
--- a/packages/apps/Mira4U/jni/Mira4U.cpp	1969-12-31 19:00:00.000000000 -0500
+++ b/packages/apps/Mira4U/jni/Mira4U.cpp	2013-08-14 04:13:30.000000000 -0400
@@ -0,0 +1,198 @@
+#include <jni.h>
+#include <string.h>
+#include <cstring>
+
+//#define LOG_NDEBUG 0
+#define LOG_TAG "Mira_for_You_JNI"
+#include <utils/Log.h>
+
+#include "sink/WifiDisplaySink.h"
+#include "source/WifiDisplaySource.h"
+
+#include <binder/ProcessState.h>
+#include <binder/IServiceManager.h>
+#include <gui/SurfaceComposerClient.h>
+#include <media/AudioSystem.h>
+#include <media/IMediaPlayerService.h>
+#include <media/IRemoteDisplay.h>
+#include <media/IRemoteDisplayClient.h>
+#include <media/stagefright/DataSource.h>
+#include <media/stagefright/foundation/ADebug.h>
+
+// base src:/frameworks/av/media/libstagefright/wifi-display/wfd.cpp
+
+namespace android {
+
+// Sink JNI
+extern "C" void Java_com_example_mira4u_MainActivity_nativeInvokeSink(JNIEnv* env, jobject thiz, jstring ipaddr, jint port) {
+
+    ProcessState::self()->startThreadPool();
+    DataSource::RegisterDefaultSniffers();
+
+    sp<ANetworkSession> session = new ANetworkSession;
+    session->start();
+
+    sp<ALooper> looper = new ALooper;
+
+    sp<WifiDisplaySink> sink = new WifiDisplaySink(session);
+    looper->registerHandler(sink);
+
+    const char *ip = env->GetStringUTFChars(ipaddr, NULL);
+    ALOGD("Source[%s] Port[%d]", ip, port);
+    sink->start(ip, port);
+    //env->ReleaseStringUTFChars(ipaddr, ip);
+
+    looper->start(true /* runOnCallingThread */);
+}
+
+
+// Source lib
+struct RemoteDisplayClient : public BnRemoteDisplayClient {
+    RemoteDisplayClient();
+
+    virtual void onDisplayConnected(
+            const sp<ISurfaceTexture> &surfaceTexture,
+            uint32_t width,
+            uint32_t height,
+            uint32_t flags);
+
+    virtual void onDisplayDisconnected();
+    virtual void onDisplayError(int32_t error);
+
+    void waitUntilDone();
+
+protected:
+    virtual ~RemoteDisplayClient();
+
+private:
+    Mutex mLock;
+    Condition mCondition;
+
+    bool mDone;
+
+    sp<SurfaceComposerClient> mComposerClient;
+    sp<ISurfaceTexture> mSurfaceTexture;
+    sp<IBinder> mDisplayBinder;
+
+    DISALLOW_EVIL_CONSTRUCTORS(RemoteDisplayClient);
+};
+
+RemoteDisplayClient::RemoteDisplayClient()
+    : mDone(false) {
+    mComposerClient = new SurfaceComposerClient;
+    CHECK_EQ(mComposerClient->initCheck(), (status_t)OK);
+}
+
+RemoteDisplayClient::~RemoteDisplayClient() {
+}
+
+void RemoteDisplayClient::onDisplayConnected(
+        const sp<ISurfaceTexture> &surfaceTexture,
+        uint32_t width,
+        uint32_t height,
+        uint32_t flags) {
+    ALOGI("onDisplayConnected width=%u, height=%u, flags = 0x%08x",
+          width, height, flags);
+
+    mSurfaceTexture = surfaceTexture;
+    mDisplayBinder = mComposerClient->createDisplay(
+            String8("foo"), false /* secure */);
+
+    SurfaceComposerClient::openGlobalTransaction();
+    mComposerClient->setDisplaySurface(mDisplayBinder, mSurfaceTexture);
+
+    Rect layerStackRect(1280, 720);  // XXX fix this.
+    Rect displayRect(1280, 720);
+
+    mComposerClient->setDisplayProjection(
+            mDisplayBinder, 0 /* 0 degree rotation */,
+            layerStackRect,
+            displayRect);
+
+    SurfaceComposerClient::closeGlobalTransaction();
+}
+
+void RemoteDisplayClient::onDisplayDisconnected() {
+    ALOGI("onDisplayDisconnected");
+
+    Mutex::Autolock autoLock(mLock);
+    mDone = true;
+    mCondition.broadcast();
+}
+
+void RemoteDisplayClient::onDisplayError(int32_t error) {
+    ALOGI("onDisplayError error=%d", error);
+
+    Mutex::Autolock autoLock(mLock);
+    mDone = true;
+    mCondition.broadcast();
+}
+
+void RemoteDisplayClient::waitUntilDone() {
+    Mutex::Autolock autoLock(mLock);
+    while (!mDone) {
+        mCondition.wait(mLock);
+    }
+}
+
+static status_t enableAudioSubmix(bool enable) {
+    status_t err = AudioSystem::setDeviceConnectionState(
+            AUDIO_DEVICE_IN_REMOTE_SUBMIX,
+            enable
+                ? AUDIO_POLICY_DEVICE_STATE_AVAILABLE
+                : AUDIO_POLICY_DEVICE_STATE_UNAVAILABLE,
+            NULL /* device_address */);
+
+    if (err != OK) {
+        return err;
+    }
+
+    err = AudioSystem::setDeviceConnectionState(
+            AUDIO_DEVICE_OUT_REMOTE_SUBMIX,
+            enable
+                ? AUDIO_POLICY_DEVICE_STATE_AVAILABLE
+                : AUDIO_POLICY_DEVICE_STATE_UNAVAILABLE,
+            NULL /* device_address */);
+
+    return err;
+}
+
+static void createSource(const AString &addr, int32_t port) {
+    sp<IServiceManager> sm = defaultServiceManager();
+    sp<IBinder> binder = sm->getService(String16("media.player"));
+    sp<IMediaPlayerService> service =
+        interface_cast<IMediaPlayerService>(binder);
+
+    CHECK(service.get() != NULL);
+
+    enableAudioSubmix(true /* enable */);
+
+    String8 iface;
+    iface.append(addr.c_str());
+    iface.append(StringPrintf(":%d", port).c_str());
+
+    sp<RemoteDisplayClient> client = new RemoteDisplayClient;
+    sp<IRemoteDisplay> display = service->listenForRemoteDisplay(client, iface);
+
+    client->waitUntilDone();
+
+    display->dispose();
+    display.clear();
+
+    enableAudioSubmix(false /* enable */);
+}
+
+// Source JNI
+extern "C" void Java_com_example_mira4u_MainActivity_nativeInvokeSource(JNIEnv* env, jobject thiz, jstring ipaddr, jint port) {
+
+    ProcessState::self()->startThreadPool();
+    DataSource::RegisterDefaultSniffers();
+
+    const char *ip = env->GetStringUTFChars(ipaddr, NULL);
+    ALOGD("Source[%s] Port[%d]", ip, port);
+
+    createSource(ip, port);
+}
+
+}  // namespace android
+
diff -Naur a/packages/apps/Mira4U/proguard-project.txt b/packages/apps/Mira4U/proguard-project.txt
--- a/packages/apps/Mira4U/proguard-project.txt	1969-12-31 19:00:00.000000000 -0500
+++ b/packages/apps/Mira4U/proguard-project.txt	2013-08-14 04:13:30.000000000 -0400
@@ -0,0 +1,20 @@
+# To enable ProGuard in your project, edit project.properties
+# to define the proguard.config property as described in that file.
+#
+# Add project specific ProGuard rules here.
+# By default, the flags in this file are appended to flags specified
+# in ${sdk.dir}/tools/proguard/proguard-android.txt
+# You can edit the include path and order by changing the ProGuard
+# include property in project.properties.
+#
+# For more details, see
+#   http://developer.android.com/guide/developing/tools/proguard.html
+
+# Add any project specific keep options here:
+
+# If your project uses WebView with JS, uncomment the following
+# and specify the fully qualified class name to the JavaScript interface
+# class:
+#-keepclassmembers class fqcn.of.javascript.interface.for.webview {
+#   public *;
+#}
diff -Naur a/packages/apps/Mira4U/.project b/packages/apps/Mira4U/.project
--- a/packages/apps/Mira4U/.project	1969-12-31 19:00:00.000000000 -0500
+++ b/packages/apps/Mira4U/.project	2013-08-14 04:13:30.000000000 -0400
@@ -0,0 +1,97 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<projectDescription>
+	<name>Mira4U</name>
+	<comment></comment>
+	<projects>
+	</projects>
+	<buildSpec>
+		<buildCommand>
+			<name>org.eclipse.cdt.managedbuilder.core.genmakebuilder</name>
+			<triggers>clean,full,incremental,</triggers>
+			<arguments>
+				<dictionary>
+					<key>?children?</key>
+					<value>?name?=outputEntries\|?children?=?name?=entry\\\\\\\|\\\|?name?=entry\\\\\\\|\\\|\||</value>
+				</dictionary>
+				<dictionary>
+					<key>?name?</key>
+					<value></value>
+				</dictionary>
+				<dictionary>
+					<key>org.eclipse.cdt.make.core.append_environment</key>
+					<value>true</value>
+				</dictionary>
+				<dictionary>
+					<key>org.eclipse.cdt.make.core.buildArguments</key>
+					<value></value>
+				</dictionary>
+				<dictionary>
+					<key>org.eclipse.cdt.make.core.buildCommand</key>
+					<value>ndk-build</value>
+				</dictionary>
+				<dictionary>
+					<key>org.eclipse.cdt.make.core.cleanBuildTarget</key>
+					<value>clean</value>
+				</dictionary>
+				<dictionary>
+					<key>org.eclipse.cdt.make.core.contents</key>
+					<value>org.eclipse.cdt.make.core.activeConfigSettings</value>
+				</dictionary>
+				<dictionary>
+					<key>org.eclipse.cdt.make.core.enableAutoBuild</key>
+					<value>false</value>
+				</dictionary>
+				<dictionary>
+					<key>org.eclipse.cdt.make.core.enableCleanBuild</key>
+					<value>true</value>
+				</dictionary>
+				<dictionary>
+					<key>org.eclipse.cdt.make.core.enableFullBuild</key>
+					<value>true</value>
+				</dictionary>
+				<dictionary>
+					<key>org.eclipse.cdt.make.core.stopOnError</key>
+					<value>true</value>
+				</dictionary>
+				<dictionary>
+					<key>org.eclipse.cdt.make.core.useDefaultBuildCmd</key>
+					<value>true</value>
+				</dictionary>
+			</arguments>
+		</buildCommand>
+		<buildCommand>
+			<name>com.android.ide.eclipse.adt.ResourceManagerBuilder</name>
+			<arguments>
+			</arguments>
+		</buildCommand>
+		<buildCommand>
+			<name>com.android.ide.eclipse.adt.PreCompilerBuilder</name>
+			<arguments>
+			</arguments>
+		</buildCommand>
+		<buildCommand>
+			<name>org.eclipse.jdt.core.javabuilder</name>
+			<arguments>
+			</arguments>
+		</buildCommand>
+		<buildCommand>
+			<name>com.android.ide.eclipse.adt.ApkBuilder</name>
+			<arguments>
+			</arguments>
+		</buildCommand>
+		<buildCommand>
+			<name>org.eclipse.cdt.managedbuilder.core.ScannerConfigBuilder</name>
+			<triggers>full,incremental,</triggers>
+			<arguments>
+			</arguments>
+		</buildCommand>
+	</buildSpec>
+	<natures>
+		<nature>com.android.ide.eclipse.adt.AndroidNature</nature>
+		<nature>org.eclipse.jdt.core.javanature</nature>
+		<nature>org.eclipse.cdt.core.cnature</nature>
+		<nature>org.eclipse.cdt.core.ccnature</nature>
+		<nature>org.eclipse.cdt.managedbuilder.core.managedBuildNature</nature>
+		<nature>org.eclipse.cdt.managedbuilder.core.ScannerConfigNature</nature>
+	</natures>
+</projectDescription>
diff -Naur a/packages/apps/Mira4U/project.properties b/packages/apps/Mira4U/project.properties
--- a/packages/apps/Mira4U/project.properties	1969-12-31 19:00:00.000000000 -0500
+++ b/packages/apps/Mira4U/project.properties	2013-08-14 04:13:30.000000000 -0400
@@ -0,0 +1,14 @@
+# This file is automatically generated by Android Tools.
+# Do not modify this file -- YOUR CHANGES WILL BE ERASED!
+#
+# This file must be checked in Version Control Systems.
+#
+# To customize properties used by the Ant build system edit
+# "ant.properties", and override values to adapt the script to your
+# project structure.
+#
+# To enable ProGuard to shrink and obfuscate your code, uncomment this (available properties: sdk.dir, user.home):
+#proguard.config=${sdk.dir}/tools/proguard/proguard-android.txt:proguard-project.txt
+
+# Project target.
+target=android-17
diff -Naur a/packages/apps/Mira4U/res/drawable-hdpi/ic_launcher.png b/packages/apps/Mira4U/res/drawable-hdpi/ic_launcher.png
--- a/packages/apps/Mira4U/res/drawable-hdpi/ic_launcher.png	1969-12-31 19:00:00.000000000 -0500
+++ b/packages/apps/Mira4U/res/drawable-hdpi/ic_launcher.png	2013-08-14 04:13:30.000000000 -0400
@@ -0,0 +1,42 @@
+PNG
+
+   IHDR   H   H   UG  IDATxTUM&L2M^*MDD@TTH;Hol 5DFcI4{)rfEc2"os=>ammmCu'g7!b^
+6?6s9#Y:EoyC6d-C$Zlfa{u MMs>63|4kg}>oIHUF{-{,0|w  CHQ^,F#]A?rS.48 {sH FK\=&^U&}Ew	=AADuw_Gc1w#e.$<WVo1}^-i}w|o{/{	!{1$*3#x'z|]wg/jkSY!}#UK=>t&'\H)Q	]H9)x0}]]-eoCU=/j}>A,B
+h<F8P9j$HK /M=.d|=7^;Z_hzr!	FwO]$:"H%Li Ub<x@
+tY8=$l>.ZcIsn![u;o:Jz.!o pixB*nRz]'W)D<bs#<trW!@h;b52WY/za|iGn!;{2bi6R#gyqaB\@8Y@zq/>=l1_\<fq!WIFvk,h?el_>Q7	JS|0p?{p>])ttn^N>Xrvj[!Z{"gsNp1OJaWEv`~_8{q?7]4-W$x}_ pQ{hp}}	}?M;s </?TOba6?'s|h){~b`<4lJq"8XuA{ID-*jr/nSk	-'}_~lf~;f`=zA?[.NXwOLDQq.~?*6kl4eu6q~t`^J-g`Gl@m`u
+Wz>UW\I5g&cIXy+~,xZX~$GF,\oN#>Y_P~^^Iz1O8p_s9cg@mP/PW@Kc9GXsrVg6Xv1G^3,e/PeQ+A)IzTlS^ 8jc,y+[RXQ;a''2XP>5`hXK0neou][Q>eeHizEq{f4?:pZv`%{6E3
+s`AbIaE >,PF+ja Nv0mE*mR2Z5Pqwa*+ @_q#y!Z5B~cZ$AXbwf,,Tbi!0kC
+:C:BN&qI]fo/K3v1&=E9NXBbo%>@].I<gQL=,qjrmzu;hT>#cgBga:fg&2 i%SL9H9[0oBROZH]U.xF*]Amd|uiWNr?u;]TA?7A2}o/.jp=X\^z}rr+d4!g.=Tm1EM,H]S~),O^Vwwz(pu_BC$^8!~{Yy%Hpi3%T#Tnkt!gt%w;pl~\^KI2MUuhKf~FpH%O3BsMGYL	n0Sg0i?y}Vf#)pSc?XO$p 
+iz
+~h;l%xgXLK*[4}I-]~1jVhk$o].BfPNs]ln)[-Z2`8{(M6@P7 a4s5awX~C`4>d>_sbb^p<$"H6j^vBu/MP<rkj#dP{VkIF6UM$Ab3BL9%TmgzG-KKvu*9q;Y_WW<l\DnBg]q)u3,"M-WGp 'AY?TzJm@&zzt:X9e_2P;4GI5>0UrveNa4+6RESBk LS}ZD5eZ{ fu#sZ6Zh#{R`t,,D`<+; XN~_
+;Abc$K@; 3 bs([ASO+lsY\x6_^Hr]Wh+a/@8af6'?a*"Q(D@O}g`}KQYcBsz<e\PYJ&r	PuuW
+d'.v^X|	RqH&XlEz]4mwKxj{RHVL 9m%tH=)@x&SyG)Bm|:0i^{VPLPiS'h5c_){\N	3Kiy+YMg]e /t\pt3p*t=&\pqy|s@9R``t>[`n;S20AP#4;RhA 3c*4^&s\AERg7MB/3
+,tk4Pq&t><^l9-8[f#-|VsKk[!S ?Yw/NlAc2<S_Z
+YA-SE
+}4"@X+Y
+$7=9(uz(s"%kTc`Jjt!{'1M
+M=}XCPO:_PR-Z(\u%^-Cse/Yj2@L?PzJj|RPS R/z\gpTE"aAH#F
+my?'7!gAv_ /r34 Q tjWJ:R1ppFfDw=$@KD$k!Y $(WfV~'I))gpTERzCpARLn7xNRslaHCF (e%)R1@se z^.4W<glW|Q%iI .c}NxJ
+jU~SR&}2'#Dw-0rZ,HrD`
+7nPHsVWlE
+R/
+Q&*;3 #_i$c*FQWCR*5HG"?h*H^nubg!8Z^{ .Fp1;nr}ZH(	R@PJIA3jh{??Sb/^xVDpjjHUG  DgQbu(Y~7LnA"ywym4d)'NF__{qn!( _Bu
+uO| i K /yzS$U#@
+;oJGuZcL=Mj 	MX#zL8r ~]WwoQx#T.JG^Y4<CMxx-YC`qeT'{%8(I2ZYGXK@X?`N-YJZd2 R[&X\kJ
+9CyuT/Gh!brq	ub~Y|2t
+5D"q{?IYPPjGydG
+ixdqf> -"@tTYBP5jq:7p]@K-wm teiSPanR
+	8R'N9$[AL]7SOL`;7U#p%V'TBVAxx:aH!' [4T+x%w|4B2YQSFTyf+*$9 -gPPcuwG3E .RXK*TV4 H6,% VgH?pa7g.]=UDROB y;z$x(lfd0xaD`#m>TftXaIJ/> 1$S 4i>,~KbZB<K3@v D
+hPTJk qsd@
+TD&eBha[g>^EPO|22+p		"?$p(_C
+z~k*"!@,QEB3Dd/W1sZRa$}ws{%v):eLZL	 QVdi ov_X?$u\~
+!YDPb-K9
+,($bil&@Xf
+]>(;$Vn_J*XL]YH6{FJ1Z>[	3Tf,bC+ @mb/gOvD!(]A TYL]qEyhunLWhnzm.k>hI&Zu
+p0H	7XgY&,*!9%%@1z3~Ji 31iI9
+*:_7eFH Y! pvdcHV/Ud_l:ZgZ56M0;Z%/0rP(Yv9}Yf}
+	3 C*b?(8u4gSfH(&}}8Jc1#D!(M	2,DQ Y#p2k7M&xXV/LkhJs*0OTg[?Lf9_#=H8va}UEMqI_HDFU[>RDYX_@DpnErk/T U,A=rzlFCz nvB<aT2LTs2^c+V)$Yw.'M6"nZS5h[]HcxFQ#PT 2ib" ';H_b^Rn~g]bP,t,y]SJ!HE*)a\*0_%b=- ~|d#7}hQafr-Sg6 `9DB4k:0p"q5ovC@$TIY"u\sJW?qMuTVb]s\h+5Fb	hbpiFr!j)j>ORRgSzS$TXafz\P/:2SBA|+\l ;/M?YtuDX"	jgV#IH2E!)5HFZ-vHoGF29"^[jG$O<s!w;k
+XFQKPCX)xR] rCz4dPGf|~7_(Z < {l*	N3:*o4-t#xm8f,+3R@HJ)|&jUq+n$qET_l0?@)~]y;WQ8n}J0}WYnUr#9&z|s8|00K3a>X{Eh:Vvq8,]F}4&Li	jU$VKC.X2p3G}\Fq$#"OpsxGOhWf
+a?s4k wWN/,)`n|0+r,&L]V8'3c;I;fqBL=Jfq-l( E+"@VE(C9n2]F7smd43B1+B0}8+X4UU_E/TIf(vd<R0;RSa1 
+Kr4qP=ci9;RqJKToxDJxq@gf)Q#XY3iJUOV#G7MfvC`1dn*7)dI54.Re#Th UA`2<TxW_-a/fFHXAVa^*_YC[hhnzSE	nijgd_-Iy*|hZ(AXV$>9=HE}ls|oAFST^oBs.@Ud$)%1zlM<)jg.KqsMQ-17e[NF;)p: ;J[w]06Tk|REnn>KIs*23/.#($T+4h{Gg
+*o'l(QbS8mmm7\'    IENDB`
\ No newline at end of file
diff -Naur a/packages/apps/Mira4U/res/drawable-ldpi/ic_launcher.png b/packages/apps/Mira4U/res/drawable-ldpi/ic_launcher.png
--- a/packages/apps/Mira4U/res/drawable-ldpi/ic_launcher.png	1969-12-31 19:00:00.000000000 -0500
+++ b/packages/apps/Mira4U/res/drawable-ldpi/ic_launcher.png	2013-08-14 04:13:30.000000000 -0400
@@ -0,0 +1,12 @@
+PNG
+
+   IHDR   $   $      	IDATxyPTW12,SfI\)}ieqCEQ i}kiQYZEcLY'jf$!lvXL&5Tuss{oNT~`0E@mE  TpF\jJf?`o7n-h	<cR(_)=fxd9d'78?3Wu7$1oF]6wGL:` 0Jygw_Q`C#:#(RC<
+	_tN8xk8*;0]y_HH Bqa6#>8vcN29:+s0;	c~4[=fQ.HfoVuu;|?g!Bu8`N}{8~g=}h3(nE~	iR~;}4`6ha/o$~8=j/byK(;Vpa}.yO^>s.Y5hlGF;-kY@yj)J"iDK!}r^?w<L iWw(n~'M(9&DemADMUTg-P'iS"HX|qp{7~~KsZ>|k#6P\{UKUXXeNO;{p~:ClhDp+l@r&u\5Zy5:5}hM;u+Z.hV`6 4CN	\gE*+ek]} [-d4p,qqWf#O['Pve'[;(:,$27En	H"4:0,529lbo@gBe5
+4:6RhtK?H`rulOtxmVkd6-#"`ZXP?h:i"q\)x/AIeS 0d{\8=7C"D
+60=P8+a#( 2&U,5QLL	>+kf0.4E-f?lWptv'*Kquj5Be-!b L$(['q>Kc~,~vFx&>dQ!>o06>ZIU>Agw=#Jb1H[Be0AF=P>O|;S{]pr5<#q%kLF>A}2H|v
+#?DILqGb.{~"syfZ%*vI0~HHu7zM@,1
+&yr`2jy9
+'ULYB8~IJX^HI=B@tlQ "7r0xmJKTI! "Y75"$;cjzB %1S DHdJL!:O=T%J1tdi7p$LjZRa2},qxF~@#CkQ  1B$,ves$J+]Du#YV1-VW3r-o
+_Y<\-e/1bsmp(jlh||G;k&5'gD<H<3KnLDRIN6"+%PLr*@zkBtI\I@)1	eI\s4DqZ'`<K8IJ2V<	P# |r- g@ GXy=*D*lc	qJHV"|%\K*O$8$D@wV_H]tyb"Fd9DKJC@!Vyu4oWdvnd1<?Y~n/cw(gXu):w&^J,E!4[Ke/@;Us73$6*2&$m6f9
+"RR=n{'0M G8G}aA;s$&#qEVT
+NzD-/Hi;NX=Ph{_D[fs2    IENDB`
\ No newline at end of file
diff -Naur a/packages/apps/Mira4U/res/drawable-mdpi/ic_launcher.png b/packages/apps/Mira4U/res/drawable-mdpi/ic_launcher.png
--- a/packages/apps/Mira4U/res/drawable-mdpi/ic_launcher.png	1969-12-31 19:00:00.000000000 -0500
+++ b/packages/apps/Mira4U/res/drawable-mdpi/ic_launcher.png	2013-08-14 04:13:30.000000000 -0400
@@ -0,0 +1,16 @@
+PNG
+
+   IHDR   0   0   W  IDATxZTTw&ulI6QL104jHDADDHa CPbC1bhDCJo{&'1H'ro=73wwW[ynT:='>oO
+k|^_  }Qc|av}j{&Z2YX@9F5-.T=Tu9iH^W gzv*j3,<2i1|1waGI!d6#{HQA_9d>p}EtnIO{~2!w9,owG6zI*bmV^'}UbBA$.82\]W9SpI"+0XxQda
+]Z| !f3{3`2"n'X,>QCYzN
+"
+GMQWj./+x)j8vF=p7*|4{a;>8s+!|pN^=dmf?(_[[+6wWGUgn2:_}.se	v|-3;r(.AV.S"h}"u{pLEt_a5l]sSZ@@aSl7T~mY.~x	SG[NS1#ZAT]YY`kznO,J?14oTY(zHmEdi>T;`C#&h:aF |'>,9yQe{QC"VmjDVg<s+!=g Wk5}+1QObYU#M LP	'Sz+~>"Sfm$Vi]Pc|A<XYwW&Ku_rj?k@Y[$g$/lTQ1y[d]FPth@"HkE^k .i0L0A[gGA'v,&r6Z>~l#lA~i}}*CVeM8aw`dthM*4$7_u}&vom,|%xFb(;rDdN9Nc~%hVd6wM6];bLZ7C:o3G2'\pF9GtcsQ;`Nr2FnC}* V{=A	HS&PZLz>D>9=&)sp.wW{HY+5DNC;U'[&U^IJT>4^-UCrN@GpZIkN{NyMPjHn	
+ztQCmhn2Gj#.STub.cTs5jDVn	t?Q4h!"!#v$Y'bt od,.=4'_nT14zK'Fm$I>Z!PNUF3>qyv[$7zYD^`yK2EL	FQ )h?=8^`8}i;jv$iP
+mbB{w5eI{x#fo<*}N^$
+QH^0&XyKik!{6Gk7t[[ %G9D-'U*nA[^zl}/(6%0!$jd6+"2hN,gD;wnrGh7#BRS`4#V:T]dHO@OOswT&Y\><d"	qVZ[8Yrx+Dj1{wdtwBa}	K@d	Pvf*D/^k/3v|Fpqg_(Y.mzs[!Bl;q#Q-DT+Lx }6)}b{<U'J`~O#:;K"i2J}_r9sJ:]@Q$myN!z?S;;<*4&n3lyRgB}7=7J+A&0JI	lfAQds
+}H`1=?qfZ	i_Pc)	,Q@ $>]hO		0v^cR"L	tme	<&G&fdU=Na9Xy=G7\8K ,GH0D$/{HN/On3M@*>yO*fMnQu j*<_F7pf2Ky+z=FI+WDF,od AvD7Uj(
+uBJrMJuP7rDkOo$+f[8D 4tQG;n5YcMLx"3bE8oG^IJ/VtQksNlewj/JA&
+#t.|_td&G ,#Tnx,%R/cS*RdOVnjavo*EHH"R!=:y=QQX<M'*1,rffrzhvT
+T4)*<Icg1Zl RP_'4/e:k6@l)bDq Pn2sc}"6Pc'Z/j+FT|!d%yRIvCT!*P|&Pj|((Y64Ix@ob[XbW-eTYSyt50	pC6nB8.&ke5/
+)tE;cYjg._g,IL*l;7Im^f+aM4tkEa*-:6k>*sW?lwf8aq,}	n0Y_CX:MPK,W{?g:<&b{M.bK#yT.vC^fbocC.k2+c?)0Pb`D&5!& /y_B@~W)R4SBI%^,
+4eJ2,XEd> /wPflrede2l70<$e!sWIVui&B/eMb'7?xN#    IENDB`
\ No newline at end of file
diff -Naur a/packages/apps/Mira4U/res/drawable-xhdpi/ic_launcher.png b/packages/apps/Mira4U/res/drawable-xhdpi/ic_launcher.png
--- a/packages/apps/Mira4U/res/drawable-xhdpi/ic_launcher.png	1969-12-31 19:00:00.000000000 -0500
+++ b/packages/apps/Mira4U/res/drawable-xhdpi/ic_launcher.png	2013-08-14 04:13:30.000000000 -0400
@@ -0,0 +1,78 @@
+PNG
+
+   IHDR   `   `   w8  4IDATx|TgvW !M\ $!M @-C =3$ot-~N'$3s#&?n7 x
+~pG{bO'y~{VWqmVFJ0?,Xrr@>={8s_j515kJ|m^(za-_~(|vetl3~0sjY(xUt` !F7~=s{P:s.3+yOoQ{Q+[`a6u0QoE@2&l]CShv{f@1AXs=tiZ<T]I|>}:k5}[EKV-AJ PgPJ?hCGPt>B;6	y72HI=(l[l<8SIIz{oTT2_'e]&7k{>~\aD>OzhERIELxPg:>|z=wZSw[k/s}'URGS]s7=]|Cr)@B<,>d 	'>Nph{8,pp<q}w{[zbKu+"z"aOy<i]i#51$YS0 30^{MwRv<p|HJ]c/[,>[d/CPx
+K'~BO	p9NAO@[?p4  OvG`;7]0?d=ctet)7!a(iCOAQw ~^}bD P9hia><x@<p! /n=ailn	/Y.=pwwsfm :z~ ^/y5AoO^ E{P0z90U|<BL?pa /!g=leZ! sXv
+R;~hlh?"	.B=TW!;zb^sMecDL+v	Gp48N=Oal9^U,`Y3X|R={:jWkL;'KTu5HN^$>E5N@IQ(nsEEc<<v8>*{z!wylg:l+[SgT
+TVQ82B 5~q1p
+@FSt8gI cC"bg1(>p.z4Xy7:TjMdz{R',j7w?tJ8}?EE`\>_#(?Q`Hc'ap?J |_v	`:K|8x
+6fKZ@ZMl>YYg4i*:4E;~Vag-8>uIAC s _?Cp?=`OzX^t3r<~~qt2:wC@RM*EI&^R[.]>&H?0?fgGFl0OI1D|Sb$~(} <ao+&pj-;qu)toZPF*5CiMK-~GG<v4i77(B}ne31xOvOqwzLraqPai0x5uBKi XNk	F/\^}NgYvl=^jk.Yx*itQr[obNwCzvE'
+gQxGz{X~z,=aY-`!sz*n._?	c|+4kM` 4)	ekhjn)Xsq:h&4sO]&emcl
+3[#ua-,9n CAS]C"^+~.T.~m*Yq8TfN _s1mEYu^v@D3C3MA5c+b590ZhPp+3vN$,:jG,'\c];}4mCCufT-3Z R2hWwDE9tj	B`Nd]rDh,9vaDA`Y-%2L1Na?ADTc[B`{vacYbe:PDJ@^&5*	^O%5l-mwg*1`c
+'T2D(fb<?0x"<I9&P|}FN#@S%PPi@N+yR'q?wo9b^p5v~}}aA{Fb\#fF0#,#B3g:1a5C7z<:^_k	Uz: HCQ<?]9zghG[g-z,;g]]w}`rD;Dq14SF&Nxj=w|o_t>zBn2*B|<-Im=&K'	}k0~#z 9@;7];:Rus'1=g>& 
+K#B
+n)"') 
+=:kc2BN
+p JxDOZk$!'* -;gW 9 mY:;.M7 %Pj|roANe*-t*^moX{aYk3 vpz>c={XmC#b3^.tR`1mz=
+|"ZUg/ @v
+41JJO[:I#rQ?
+A[w&d:I>lww,;kHnsJ{(	} -(|zr$3ol}&!ov5[^=(J2]5@}F"#&|Qiktwa35 ]R4 Rbg(|qf?^1{{=9
+K]CwS.ZPmQT]_`c)R^$|{XiYGN#nW-N,U@y/HaaM"(gO=tTS{i)`*>2"^
+|%(P25Hzl YhmM:RI5ZP	EZxp'Y9%j2I,q`vq:,1w"]Ps&{x~+unK-x-lxB_}v }u7^xk/8k/<wQkFr{T%p[Z7[WYj+m5k|>?q?/ _||1|#xO)>	E70~Oz?} >
+_k=>_80-8Nh9?I[LWRUb
+{XgbAe)SAS;fK{wVbP$]t{;	47AQIuCr[vji<-l?l7P2_xp7A$)`2Lx0q
+mec_g}	\q`=*17EB]*5
+.eSew*CjP@$O`4Q1@96QN"5M`J[Kh-P	U#Zj7\;?5;uCsRm|
+EZ8b-nb:N*HK?t]7|r:#];ui9`dgj<o/;<fmO}gl@s7v@]7`@z6]gK?hNv;!/AvHXHd{Nd2]Px4vq'%-YFUb&hb+ U*X ~# v||6U<L,TIQ4m74(Ry2OfFNH}[|pJ<6mmta;]U!o1rL+2?`s[@^sc)t42Z73B7a&/8WU+CR2Dp 8{*2q[,j{TeZPCy
+z qRJh7k*E`PEhTBZ9eHSBSML*q_6dAuj:yfav(Z*jCfaGE+JZLwQYal={]j mgmf
+f#K$bUz842)X &N2#Akca" 0z SDGH[1 LT/+#*G@ 3fKT&e/i,6\X*_LBSXdRY#sz'o&#J= if%:BeE	O#b-E
+1u6BBD) E 0 4we` .E QS)f QYP P|`T a,"^E v[5PPuEa0 Xfm63DoZm{aFm6.7"N2M(r-^/t:2
+1iVT*D(C`,d:T"W_r`pj" (C h_WPV^@b"9txF$	691L(TTBj$DTw]y,mk`t8za<~v(]a_n)mXbR3[x(q*8p   Reb\1 .ye*Dvj97`ZW(A tA?!(/Wf',[2 V~:=>Y"=daQ^/fj:83$C*Uc3;T .oGOnf ^sK`Da4*P|W/&L?lP|" '4?Lv(O[L!VT#J
+D i^T5t\%_ &*N5#8)k0>eFD	+Y$0ow@ 	]c=|h9JKEB  @@:d	L/)yL'O^V2Y } fZ2 
+ *3-hz`
+NmjS~H(]FAe(XABSBy(NGL&A@>	?^T@;R.9V>a` $	50j46AH7#Q8& zt eb%9D?b|NEqf+qT05  :|_"p9x>9ME' h>\}vve@P<EKW:)K0 d
+M'Ex?9d Q@OM"D e-19V^;;"ca1QSiiI+0ANm1ztC1VX_rz!Y~ {a E;" 7e4RJe4vt8=+
+Wm	ukr S8=,Y%D/rb^6j!PDH}Z;B2'RV '59O?5`5C\r @Ab)~	?E<Tf8G&x>;Sh
+_T ay7w]G-\cK (> dQ
+`>#\O"mZ IYE=4F:,`{CY[0Xy~	`tb##KWG6Xp4>
+ru"Rm%,SE tE-f
+ @
+YBJa kc1^EzF$ ilye0jzDX5pAF,r%yx@a&rn"r l%!	?%!^Wv@, |UFG   E%tUdHoV5iro TnQB')5 
+%:(SQ|!Q %ye8#LI	"aFH44w>ACu:lJ}+F*lax( |CT	XL PmqF,EKpU
+LoG   C#@6UO~`AmkGr ,V3bS<Dha S1Y,P~)>-,z,X)feYpe*H*e(6BXX### $k0B&Py	 7q,@'&F" \?~#;bc?h[\INc +bL]9KNiA>[Ji|o8we?[M5|uU0mepQLEc@/_ q`JT0p!k$WCL8b " eNj"~v
+&OZ
+ABe,1@6"c( Zj<Ybm}|L?
+~FW6^1=~'Ei`y79epa~D(<{,ul;'0(8Tr!P|? P%B \5viR\7cFO]BhSdf Udc"(C2y$4 sHD6T8Zd>x'X<33=
+ jyHEIIUP$jR2L. / 4"<fHu [ew)w`'A  k!LxaVMY?
++=4DE7 0BS~Gd/c:b})VCc'wT Q`
+ Mn,F J4Y!'~r.i5fHmP/D:?wrG   h zz3*$)l 
+GP tBd&S1Y*G K] rAnnI\JW ?BDI9(~ X|ND ~ 8tFc>f%A_C$f-D @~  	fi)B Sbhc=X  rSx| M  m<zjS0h403H_/U~nT4Q xjX |M`.wU ClVU6r-Ba /P
+U 1  !p 	 @R&0\-J@ >Ra/@p.ANWl3B,k_  8xNeoGhc''^j Y@X N0C Xb d>WbR,UbW e+l*  d_H zT]:u)@.{\&y<")s*3)9-mE  z8/PB  <%&YDRfX B l 1 Y 9 !ZO]]0 & [nb4R"
+is * HG  H;)@b8wm6/{~tO$D iu\HB. ELd#@^r  j5,u_ ICL]KNk^I<UAx4:z)	HDW@Tva}ud<I|5 x& Dsq
+,.<y#
+tj#Hk+^6kb[,V_O}sI&iNzFp Szh5;F
+*OSP-1r/M$MqXl,'Qq7Y MC%VK]T x*Yj,YK^gCspT4&O\VQ !lhxe,niJ$(_NkTu>]XnvFTJ Di7BWVM} (,9X@OVRd(^6,-9sd3 0D@7*)'CtYTgc^_Zx->~hh pq({	hJ[H,N$	lfNrU?B|P0JAH\t3]mGg4Q	eg1{R]?{|'/!J[BlM:8]OV=cT(`6&5YLJRW~Vh
+a(
+J \V4_fanc"?@rO)!S!$[@B R*l!L4rhw`gBTN`Vc}
+;.X)4k[|NG>
+1J.hy[&m${UBmK#CnwFQbj9v;8!<dI++6t5 Ev0oIdhy2lz<6$! f\H $[N3VJ6:vf8ZTiFd,^fsgY+9Y}NuYB+/CB#@v%fm)|b)9e2,$0aV<LQ`9<1IaR yLr5P ZN,SWWEG
+GUa9F=X}F^EyaChQb(_ Ev;+BnU|t,_3[a
+8Ka'&xjV.1'L?1 1k:!~g;5=r,iMwg8C:XdE_ ^I#\	e lgIKALd3#\$>JgK$:@R)$N\{0c3[^1	W&k*#IuLhM@,Klg`' 1_f!mveBt	;P"8%d#0sj	8R	b5H,GA`c ZQ*o 49@k(HnPx($KH`jE;r9$TG>E6CT*	*KsOT1*(
++c7Q_lIS#1r[$@^mLiWHAT"Pc@ZRz9ZdkAk%XzZ:J51y(>O-e4AF\$Bb.iAf3u}7?JWaa)
+e<QiYoV`zC?kCaY#bf4@fdCv	,!
+bYVg)Xnq&]hDGS5e(	HSlP\E1Fw*mfQc.o YvfK8&:ifO9yCs67ksV7mq~+3H*bz#5s5]q?$n	:sD;U : , z:d9"&kI<o.{/*0V1'a'~+3ix!Yjv	eq|.?o&!zlq`V4oqpT<.Fg/d78_m]ku~!d:b:C%c!zn
+'	>:tw&C+o^
+D9^qG!B
+Lc813g	M{I[gXab\e2-|ZRy3O@p'23&xuuFqodw Be^wR'g8FLo[t~<M"%*V\hO0r\Z``a*\zXML
+u'_E27Bp)aV$! $CX88HPTGudE=Q/iIi($L;(y:{
+-Oxk5.v*"%gG1{
+N$H`DN`Emh1mwlM^`7JC$p
+J
+=r 7d!\J!PBr_xI[8Ob72P} D[@\/Qh`'.!S5\
+OB,&C{	|5v 7j @2Y*\OA^,	6S(Wuzum31p"M/>QV3F6 VYHjY)#9Kt$3Be b*Q'y'O|dC@&_h__<jr<X#KM}r^QlD3krX0}DKQMTE 
+x*z''pq3~2!!!0
+AS 
+[iYcL*&{k,VT&kLW`#2C3FL<b%(TId+)IAJ6z13XTR b4,P).AJe 0QPfE3X(YOzK2Hed"v(TPT#')b:0^!@grTa	K?Imv3=#HU*y>F
+Wq(KiS_}#N)Y$_?'(]i_AHGkBlk2T_Yz5R\xIy
+m|Etr-:N5}AB 5MMxZ,,RW^_4l`VMV;*nv*~I1[y#i\c38[rvBI6tR-\6NpKG"rLKV%ga|M^+V/ej
+:y9t`?.xZm)2_g3qC"$5! U1$K4"hqL\LM^Z=U?)}XYm^R=%=6\<RCW!&9"'?'B2K(usu\"vYG._?nq {    IENDB`
\ No newline at end of file
diff -Naur a/packages/apps/Mira4U/res/layout/activity_main.xml b/packages/apps/Mira4U/res/layout/activity_main.xml
--- a/packages/apps/Mira4U/res/layout/activity_main.xml	1969-12-31 19:00:00.000000000 -0500
+++ b/packages/apps/Mira4U/res/layout/activity_main.xml	2013-08-14 04:13:30.000000000 -0400
@@ -0,0 +1,71 @@
+<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
+    xmlns:tools="http://schemas.android.com/tools"
+    android:layout_width="match_parent"
+    android:layout_height="match_parent"
+    android:orientation="vertical"
+    android:gravity="center_horizontal"
+    tools:context=".MainActivity" >
+
+    <RatingBar
+        android:id="@+id/ratingBar1"
+        android:layout_width="wrap_content"
+        android:layout_height="wrap_content"
+        android:layout_margin="10dip"
+        android:stepSize="1" />
+
+    <AutoCompleteTextView
+        android:id="@+id/autoCompleteTextView1"
+        android:layout_width="wrap_content"
+        android:layout_height="wrap_content"
+        android:layout_margin="10dip"
+        android:ems="10"
+        android:inputType="number"
+        android:text="@string/lbl_IP" />
+
+    <EditText
+        android:id="@+id/editText1"
+        android:layout_width="wrap_content"
+        android:layout_height="wrap_content"
+        android:layout_above="@+id/button1"
+        android:layout_margin="10dip"
+        android:ems="10"
+        android:text="@string/lbl_Port"
+        android:inputType="number"
+        />
+
+    <Button
+        android:id="@+id/button3"
+        android:layout_width="wrap_content"
+        android:layout_height="wrap_content"
+        android:layout_marginTop="15dip"
+        android:text="@string/lbl_fwwifisource" />
+
+    <Button
+        android:id="@+id/button31"
+        android:layout_width="wrap_content"
+        android:layout_height="wrap_content"
+        android:layout_marginTop="10dip"
+        android:text="@string/lbl_fwwfdsource" />
+
+    <Button
+        android:id="@+id/button4"
+        android:layout_width="wrap_content"
+        android:layout_height="wrap_content"
+        android:layout_marginTop="10dip"
+        android:text="@string/lbl_fwwifisink" />
+
+    <Button
+        android:id="@+id/button5"
+        android:layout_width="wrap_content"
+        android:layout_height="wrap_content"
+        android:layout_margin="10dip"
+        android:text="@string/lbl_fwp2psink" />
+
+    <Button
+        android:id="@+id/button2"
+        android:layout_width="wrap_content"
+        android:layout_height="wrap_content"
+        android:layout_marginTop="10dip"
+        android:text="@string/lbl_killwfd" />
+
+</LinearLayout>
diff -Naur a/packages/apps/Mira4U/res/layout/activity_p2p.xml b/packages/apps/Mira4U/res/layout/activity_p2p.xml
--- a/packages/apps/Mira4U/res/layout/activity_p2p.xml	1969-12-31 19:00:00.000000000 -0500
+++ b/packages/apps/Mira4U/res/layout/activity_p2p.xml	2013-08-14 04:13:30.000000000 -0400
@@ -0,0 +1,200 @@
+<?xml version="1.0" encoding="utf-8"?>
+<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
+    android:layout_width="fill_parent"
+    android:layout_height="fill_parent"
+    android:baselineAligned="false"
+    android:background="#000000"
+    android:orientation="vertical" >
+
+    <!-- API test button area -->
+
+    <ScrollView
+        android:id="@+id/layout_apibuttons"
+        android:layout_width="fill_parent"
+        android:layout_height="0dip"
+        android:layout_weight="1"
+        android:background="#ff0000"
+        android:fadeScrollbars="false"
+        android:orientation="vertical" >
+
+        <LinearLayout
+            android:layout_width="fill_parent"
+            android:layout_height="wrap_content"
+            android:layout_marginRight="4dip"
+            android:orientation="vertical" >
+
+            <ToggleButton
+                android:id="@+id/toggle_bc_all"
+                android:layout_width="wrap_content"
+                android:layout_height="wrap_content"
+                android:layout_marginTop="8dip"
+                android:checked="true"
+                android:textColor="#ffffff"
+                android:textOff="@string/button_broadcast_unregist"
+                android:textOn="@string/button_broadcast_regist" />
+
+            <Button
+                android:layout_width="wrap_content"
+                android:layout_height="wrap_content"
+                android:layout_marginTop="16dip"
+                android:onClick="onClickDiscoverPeers"
+                android:textColor="#ffffff"
+                android:text="@string/button_discoverPeers" />
+
+            <LinearLayout
+                android:layout_width="fill_parent"
+                android:layout_height="wrap_content"
+                android:orientation="horizontal" >
+
+                <Button
+                    android:layout_width="wrap_content"
+                    android:layout_height="wrap_content"
+                    android:onClick="onClickRequestPeers"
+                    android:textColor="#ffffff"
+                    android:text="@string/button_requestPeers" />
+
+                <Spinner
+                    android:id="@+id/spinner_peers"
+                    android:layout_width="fill_parent"
+                    android:layout_height="wrap_content"
+                    android:layout_gravity="bottom"
+                    android:drawSelectorOnTop="true"
+                    android:prompt="@string/spinner_peers"
+                    android:textColor="#ffffff"
+                    android:spinnerMode="dialog" />
+            </LinearLayout>
+
+            <Button
+                android:layout_width="wrap_content"
+                android:layout_height="wrap_content"
+                android:onClick="onClickCancelConnect"
+                android:textColor="#ffffff"
+                android:text="@string/button_cancelConnect" />
+
+            <Button
+                android:layout_width="wrap_content"
+                android:layout_height="wrap_content"
+                android:layout_marginTop="12dip"
+                android:onClick="onClickCreateGroup"
+                android:textColor="#ffffff"
+                android:text="@string/button_createGroup" />
+
+            <Button
+                android:layout_width="wrap_content"
+                android:layout_height="wrap_content"
+                android:onClick="onClickRemoveGroup"
+                android:textColor="#ffffff"
+                android:text="@string/button_removeGroup" />
+
+            <Button
+                android:layout_width="wrap_content"
+                android:layout_height="wrap_content"
+                android:layout_marginTop="12dip"
+                android:onClick="onClickRequestConnectionInfo"
+                android:textColor="#ffffff"
+                android:text="@string/button_requestConnectionInfo" />
+
+            <Button
+                android:layout_width="wrap_content"
+                android:layout_height="wrap_content"
+                android:onClick="onClickRequestGroupInfo"
+                android:textColor="#ffffff"
+                android:text="@string/button_requestGroupInfo" />
+
+            <LinearLayout
+                android:layout_width="fill_parent"
+                android:layout_height="wrap_content"
+                android:layout_marginTop="12dip"
+                android:gravity="right"
+                android:orientation="vertical" >
+
+                <Button
+                    android:layout_width="wrap_content"
+                    android:layout_height="wrap_content"
+                    android:onClick="onClickGotoWiFiSetting"
+                    android:textColor="#ffffff"
+                    android:text="@string/button_gotosetting" />
+
+                <LinearLayout
+                    android:layout_width="fill_parent"
+                    android:layout_height="wrap_content"
+                    android:layout_marginTop="4dip"
+                    android:gravity="right"
+                    android:orientation="horizontal" >
+
+                    <Button
+                        android:layout_width="wrap_content"
+                        android:layout_height="wrap_content"
+                        android:onClick="onClickResetLog"
+                        android:textColor="#ffffff"
+                        android:text="@string/button_resetlog" />
+
+                    <Button
+                        android:layout_width="wrap_content"
+                        android:layout_height="wrap_content"
+                        android:enabled="false"
+                        android:onClick="onClickSaveLog"
+                        android:textColor="#ffffff"
+                        android:text="@string/button_savelog" />
+                </LinearLayout>
+
+                <RadioGroup
+                    android:id="@+id/radiogroup_logkind"
+                    android:layout_width="wrap_content"
+                    android:layout_height="wrap_content"
+                    android:layout_marginRight="4dip"
+                    android:orientation="horizontal" >
+
+                    <RadioButton
+                        android:id="@+id/radiobutton_html"
+                        android:layout_width="wrap_content"
+                        android:layout_height="wrap_content"
+                        android:checked="true"
+                        android:textColor="#ffffff"
+                        android:text="@string/button_colorlog" />
+
+                    <RadioButton
+                        android:id="@+id/radiobutton_mono"
+                        android:layout_width="wrap_content"
+                        android:layout_height="wrap_content"
+                        android:textColor="#ffffff"
+                        android:text="@string/button_monolog" />
+                </RadioGroup>
+
+                <ToggleButton
+                    android:id="@+id/toggle_autoscroll"
+                    android:layout_width="wrap_content"
+                    android:layout_height="wrap_content"
+                    android:checked="true"
+                    android:textColor="#ffffff"
+                    android:textOff="@string/button_autoscroll_off"
+                    android:textOn="@string/button_autoscroll_on" />
+            </LinearLayout>
+        </LinearLayout>
+    </ScrollView>
+
+    <!-- log area -->
+
+    <LinearLayout
+        android:layout_width="fill_parent"
+        android:layout_height="0dip"
+        android:layout_weight="1"
+        android:orientation="vertical" >
+
+        <ScrollView
+            android:id="@+id/scrollview_log"
+            android:layout_width="fill_parent"
+            android:layout_height="fill_parent"
+            android:fadeScrollbars="false"
+            android:scrollbars="vertical" >
+
+            <TextView
+                android:id="@+id/textView_log"
+                android:layout_width="fill_parent"
+                android:layout_height="wrap_content"
+                android:textColor="#ffeeee"
+                android:textSize="18sp" />
+        </ScrollView>
+    </LinearLayout>
+
+</LinearLayout>
diff -Naur a/packages/apps/Mira4U/res/values/strings_p2p.xml b/packages/apps/Mira4U/res/values/strings_p2p.xml
--- a/packages/apps/Mira4U/res/values/strings_p2p.xml	1969-12-31 19:00:00.000000000 -0500
+++ b/packages/apps/Mira4U/res/values/strings_p2p.xml	2013-08-14 04:13:30.000000000 -0400
@@ -0,0 +1,71 @@
+<?xml version="1.0" encoding="utf-8"?>
+<resources>
+
+<!-- 
+    <string name="app_name">WiFiDirectTestApp</string>
+    <string name="app_about">About this App...</string>
+ -->
+
+    <string name="button_broadcast_regist">BroadcastReceiver Registered</string>
+    <string name="button_broadcast_unregist">BroadcastReceiver UnRegistered</string>
+    <string name="button_broadcast_state_regist">STATE_CHANGED Registered</string>
+    <string name="button_broadcast_state_unregist">STATE_CHANGED UnRegistered</string>
+    <string name="button_broadcast_connection_regist">CONNECTION_CHANGED Registered</string>
+    <string name="button_broadcast_connection_unregist">CONNECTION_CHANGED UnRegistered</string>
+    <string name="button_broadcast_peers_regist">PEERS_CHANGED Registered</string>
+    <string name="button_broadcast_peers_unregist">PEERS_CHANGED UnRegistered</string>
+    <string name="button_broadcast_this_regist">THIS_DEVICE_CHANGED Registered</string>
+    <string name="button_broadcast_this_unregist">THIS_DEVICE_CHANGED UnRegistered</string>
+
+    <string name="button_getSystemService">getSystemService</string>
+    <string name="button_initialize">initialize</string>
+    <string name="button_discoverPeers">discoverPeers</string>
+    <string name="button_requestPeers">requestPeers</string>
+    <string name="spinner_peers">Peers</string>
+    <string name="button_connect">connect</string>
+    <string name="spinner_go">Group Owner Intent</string>
+    <string name="spinner_wps">Wi-Fi Protected Setup</string>
+    <string name="button_cancelConnect">cancelConnect</string>
+    <string name="button_createGroup">createGroup</string>
+    <string name="button_removeGroup">removeGroup</string>
+    <string name="button_requestConnectionInfo">requestConnectionInfo</string>
+    <string name="button_requestGroupInfo">requestGroupInfo</string>
+
+    <string name="button_gotosetting">Go To Wi-Fi Setting Menu</string>
+    <string name="button_resetlog">Reset Log</string>
+    <string name="button_savelog">Save Log</string>
+    <string name="button_colorlog">Color Log</string>
+    <string name="button_monolog">Mono Log</string>
+    <string name="button_autoscroll_on">AutoScroll On</string>
+    <string name="button_autoscroll_off">AutoScroll Off</string>
+
+<!-- array.xml ^^;; -->
+    <string-array name="spinner_go_entry">
+        <item>-1:system can choose an appropriate value</item>
+        <item>0:least inclination to be a group owner</item>
+        <item>1</item>
+        <item>2</item>
+        <item>3</item>
+        <item>4</item>
+        <item>5</item>
+        <item>6</item>
+        <item>7</item>
+        <item>8</item>
+        <item>9</item>
+        <item>10</item>
+        <item>11</item>
+        <item>12</item>
+        <item>13</item>
+        <item>14</item>
+        <item>15:highest inclination to be a group owner</item>
+    </string-array>
+
+    <string-array name="spinner_wps_entry">
+        <item>PBC : Push button configuration</item>
+        <item>DISPLAY : Display pin method configuration</item>
+        <item>KEYPAD : Keypad pin method configuration</item>
+        <item>LABEL : Label pin method configuration</item>
+        <item>INVALID : Invalid configuration</item>
+    </string-array>
+
+</resources>
\ No newline at end of file
diff -Naur a/packages/apps/Mira4U/res/values/strings.xml b/packages/apps/Mira4U/res/values/strings.xml
--- a/packages/apps/Mira4U/res/values/strings.xml	1969-12-31 19:00:00.000000000 -0500
+++ b/packages/apps/Mira4U/res/values/strings.xml	2013-08-14 04:13:30.000000000 -0400
@@ -0,0 +1,29 @@
+<?xml version="1.0" encoding="utf-8"?>
+<resources>
+    <string name="app_name">Miracast for You</string>
+    <string name="p2p_name">P2p Sink</string>
+    <string name="set_name">Settings</string>
+
+    <string name="lbl_Source">Source</string>
+    <string name="lbl_Sink">Sink</string>
+    <string name="lbl_IP">(IP Address)</string>
+    <!-- 7236 = default port -->
+    <string name="lbl_Port">7236</string>
+    <string name="lbl_fwwifisource">F/W Wi-Fi Source listen on _ </string>
+    <string name="lbl_fwwfdsource">F/W Wi-Fi wfd Source listen on _ </string>
+    <string name="lbl_fwwifisink">F/W Wi-Fi Sink connect to _ </string>
+    <string name="lbl_fwp2psink">F/W p2p Sink Activity</string>
+
+    <string name="lbl_killwfd">kill wfd</string>
+
+    <string name="err_no_ip">No Valid Networks. Try Connect a Network.</string>
+
+<!-- Settings -->
+    <string name="checkbox_log">Diabled Log Output</string>
+    <string name="checkbox_hdcp">Skip HDCP Authentication</string>
+    <string name="checkbox_timeout">Extend Timeout Time</string>
+
+    <string name="checkbox_log_summary">for Better Performance</string>
+    <string name="checkbox_hdcp_summary">If HDCP Authentication Error Occurred, Try This Option</string>
+    <string name="checkbox_timeout_summary">RTSP Timeout Time Extend(15 -> 30secs)</string>
+</resources>
diff -Naur a/packages/apps/Mira4U/res/values/styles.xml b/packages/apps/Mira4U/res/values/styles.xml
--- a/packages/apps/Mira4U/res/values/styles.xml	1969-12-31 19:00:00.000000000 -0500
+++ b/packages/apps/Mira4U/res/values/styles.xml	2013-08-14 04:13:30.000000000 -0400
@@ -0,0 +1,20 @@
+<resources>
+
+    <!--
+        Base application theme, dependent on API level. This theme is replaced
+        by AppBaseTheme from res/values-vXX/styles.xml on newer devices.
+    -->
+    <style name="AppBaseTheme" parent="android:Theme.Light">
+        <!--
+            Theme customizations available in newer API levels can go in
+            res/values-vXX/styles.xml, while customizations related to
+            backward-compatibility can go here.
+        -->
+    </style>
+
+    <!-- Application theme. -->
+    <style name="AppTheme" parent="AppBaseTheme">
+        <!-- All customizations that are NOT specific to a particular API-level can go here. -->
+    </style>
+
+</resources>
\ No newline at end of file
diff -Naur a/packages/apps/Mira4U/res/values-ja/strings.xml b/packages/apps/Mira4U/res/values-ja/strings.xml
--- a/packages/apps/Mira4U/res/values-ja/strings.xml	1969-12-31 19:00:00.000000000 -0500
+++ b/packages/apps/Mira4U/res/values-ja/strings.xml	2013-08-14 04:13:30.000000000 -0400
@@ -0,0 +1,4 @@
+<?xml version="1.0" encoding="utf-8"?>
+<resources>
+    <string name="err_no_ip"></string>
+</resources>
\ No newline at end of file
diff -Naur a/packages/apps/Mira4U/res/values-v11/styles.xml b/packages/apps/Mira4U/res/values-v11/styles.xml
--- a/packages/apps/Mira4U/res/values-v11/styles.xml	1969-12-31 19:00:00.000000000 -0500
+++ b/packages/apps/Mira4U/res/values-v11/styles.xml	2013-08-14 04:13:30.000000000 -0400
@@ -0,0 +1,11 @@
+<resources>
+
+    <!--
+        Base application theme for API 11+. This theme completely replaces
+        AppBaseTheme from res/values/styles.xml on API 11+ devices.
+    -->
+    <style name="AppBaseTheme" parent="android:Theme.Holo.Light">
+        <!-- API 11 theme customizations can go here. -->
+    </style>
+
+</resources>
\ No newline at end of file
diff -Naur a/packages/apps/Mira4U/res/values-v14/styles.xml b/packages/apps/Mira4U/res/values-v14/styles.xml
--- a/packages/apps/Mira4U/res/values-v14/styles.xml	1969-12-31 19:00:00.000000000 -0500
+++ b/packages/apps/Mira4U/res/values-v14/styles.xml	2013-08-14 04:13:30.000000000 -0400
@@ -0,0 +1,12 @@
+<resources>
+
+    <!--
+        Base application theme for API 14+. This theme completely replaces
+        AppBaseTheme from BOTH res/values/styles.xml and
+        res/values-v11/styles.xml on API 14+ devices.
+    -->
+    <style name="AppBaseTheme" parent="android:Theme.Holo.Light.DarkActionBar">
+        <!-- API 14 theme customizations can go here. -->
+    </style>
+
+</resources>
\ No newline at end of file
diff -Naur a/packages/apps/Mira4U/res/xml/pref.xml b/packages/apps/Mira4U/res/xml/pref.xml
--- a/packages/apps/Mira4U/res/xml/pref.xml	1969-12-31 19:00:00.000000000 -0500
+++ b/packages/apps/Mira4U/res/xml/pref.xml	2013-08-14 04:13:30.000000000 -0400
@@ -0,0 +1,19 @@
+<?xml version="1.0" encoding="utf-8"?>
+<PreferenceScreen xmlns:android="http://schemas.android.com/apk/res/android">
+
+    <CheckBoxPreference
+        android:key="persist.sys.wfd.disablelog"
+        android:title="@string/checkbox_log"
+        android:summary="@string/checkbox_log_summary" />
+
+    <CheckBoxPreference
+        android:key="persist.sys.wfd.nohdcp"
+        android:title="@string/checkbox_hdcp"
+        android:summary="@string/checkbox_hdcp_summary" />
+
+    <CheckBoxPreference
+        android:key="persist.sys.wfd.longtimeout"
+        android:title="@string/checkbox_timeout"
+        android:summary="@string/checkbox_timeout_summary" />
+
+</PreferenceScreen>
diff -Naur a/packages/apps/Mira4U/src/com/example/mira4u/MainActivity.java b/packages/apps/Mira4U/src/com/example/mira4u/MainActivity.java
--- a/packages/apps/Mira4U/src/com/example/mira4u/MainActivity.java	1969-12-31 19:00:00.000000000 -0500
+++ b/packages/apps/Mira4U/src/com/example/mira4u/MainActivity.java	2013-08-14 04:13:30.000000000 -0400
@@ -0,0 +1,619 @@
+package com.example.mira4u;
+
+import java.io.BufferedReader;
+import java.io.DataOutputStream;
+import java.io.IOException;
+import java.io.InputStreamReader;
+import java.lang.reflect.InvocationTargetException;
+import java.lang.reflect.Method;
+import java.net.Inet4Address;
+import java.net.InetAddress;
+import java.net.NetworkInterface;
+import java.net.SocketException;
+import java.util.ArrayList;
+import java.util.Enumeration;
+
+import android.os.Bundle;
+import android.app.Activity;
+import android.content.Context;
+import android.content.Intent;
+import android.hardware.display.DisplayManager;
+import android.util.Log;
+import android.view.KeyEvent;
+import android.view.Menu;
+import android.view.MenuItem;
+import android.view.MotionEvent;
+import android.view.View;
+import android.view.View.OnClickListener;
+import android.view.View.OnKeyListener;
+import android.view.View.OnTouchListener;
+import android.view.inputmethod.InputMethodManager;
+import android.widget.AutoCompleteTextView;
+import android.widget.Button;
+import android.widget.EditText;
+import android.widget.RatingBar;
+import android.widget.RatingBar.OnRatingBarChangeListener;
+import android.widget.Toast;
+
+public class MainActivity extends Activity {
+
+    /** log tag */
+    private static final String TAG = "Mira_for_You";
+
+    /** static self for toast */
+    private static MainActivity mSelf;
+
+    /**
+     * App exit on back key pressed
+     */
+    @Override
+    public void onBackPressed() {
+        super.onBackPressed();
+        System.exit(0);
+    }
+
+    @Override
+    protected void onCreate(Bundle savedInstanceState) {
+        super.onCreate(savedInstanceState);
+        setContentView(R.layout.activity_main);
+        mSelf = this;
+    }
+
+    @Override
+    protected void onResume() {
+        super.onResume();
+        init();
+    }
+
+    /**
+     * initialize app screen
+     */
+    private void init() {
+        setIPAddressToRatingBar();
+        initIPEditText();
+        initFinishButton();
+        initFWButtons();
+    }
+
+    /**
+     * android device has some IP addresses, Wi-Fi, Wi-Fi Direct created group, 3G, Eth,,,
+     */
+    private ArrayList<String> mIPAddress = null;
+
+    /**
+     * Select IP address by rating bar
+     */
+    private void setIPAddressToRatingBar() {
+        final RatingBar rb = (RatingBar) findViewById(R.id.ratingBar1);
+
+        // get ip address
+        mIPAddress = getLocalIPAddress();
+        if (mIPAddress == null || mIPAddress.size() == 0) {
+            Toast.makeText(this, R.string.err_no_ip, Toast.LENGTH_SHORT).show();
+            disableAll();
+            return;
+        }
+
+        // set stars as number of ip address
+        final int ips = mIPAddress.size();
+        rb.setNumStars(ips);
+        rb.setStepSize(1);
+
+        // select ip address
+        rb.setOnRatingBarChangeListener(new OnRatingBarChangeListener() {
+            @Override
+            public void onRatingChanged(RatingBar ratingBar, float rating, boolean fromUser) {
+                int r = (int) rating;
+                Log.d(TAG, "onRatingChanged() rating[" + r + "]");
+                if (r <= 0 || r > ips) {
+                    return;
+                }
+
+                // set ip to textbox
+                try {
+                    String ipaddr = mIPAddress.get(r - 1);
+                    setIPAddrToEdit(ipaddr);
+                } catch (ArrayIndexOutOfBoundsException e) {
+                    e.printStackTrace();
+                }
+            }
+        });
+
+        // reload when on touch star
+        rb.setOnTouchListener(new OnTouchListener() {
+            @Override
+            public boolean onTouch(View v, MotionEvent event) {
+                // select first ip
+                rb.setRating(0);
+                rb.setRating(1);
+                return false;
+            }
+        });
+
+        // select first ip
+        rb.setRating(1);
+    }
+
+    /**
+     * get ip address<br />
+     * interface up && !loopback && IPv4
+     */
+    private ArrayList<String> getLocalIPAddress() {
+        ArrayList<String> addrs = null;
+        try {
+            // device has some network interfaces
+            for (Enumeration<NetworkInterface> en = NetworkInterface.getNetworkInterfaces(); en.hasMoreElements();) {
+                NetworkInterface intf = en.nextElement();
+                if (!intf.isUp()) { // skip !up interface
+                    Log.d(TAG, "getLocalIPAddress() [" + intf.getDisplayName() + "] is not up");
+                    continue;
+                }
+
+                // a network interface has some addresses
+                for (Enumeration<InetAddress> enumIpAddr = intf.getInetAddresses(); enumIpAddr.hasMoreElements();) {
+                    InetAddress inetAddress = enumIpAddr.nextElement();
+                    if (inetAddress.isLoopbackAddress()) { // skip loopback address
+                        continue;
+                    }
+                    if (!(inetAddress instanceof Inet4Address)) { // skip !IPv4 address
+                        continue;
+                    }
+
+                    // interface up && !loopback && IPv4
+                    Log.d(TAG, "getLocalIPaddress() IPAddress Found[" + inetAddress.getHostAddress() + "] Interface[" + intf.getName() + "]");
+                    if (addrs == null) {
+                        addrs = new ArrayList<String>();
+                    }
+                    addrs.add(inetAddress.getHostAddress());
+                }
+            }
+        } catch (SocketException e) {
+            e.printStackTrace();
+        }
+
+        return addrs;
+    }
+
+    /**
+     * screen gui disabled
+     */
+    private void disableAll() {
+        findViewById(R.id.ratingBar1).setEnabled(false);
+        findViewById(R.id.autoCompleteTextView1).setEnabled(false);
+        findViewById(R.id.editText1).setEnabled(false);
+        findViewById(R.id.button3).setEnabled(false);
+        findViewById(R.id.button31).setEnabled(false);
+        findViewById(R.id.button4).setEnabled(false);
+        //findViewById(R.id.button5).setEnabled(false); // skip p2p JNI Sink disabled
+    }
+
+    /**
+     * notify on change IP addres textbox
+     */
+    private void initIPEditText() {
+        AutoCompleteTextView actv = (AutoCompleteTextView) findViewById(R.id.autoCompleteTextView1);
+        actv.setOnKeyListener(new OnKeyListener() {
+            @Override
+            public boolean onKey(View v, int keyCode, KeyEvent event) {
+                // pushed enter key
+                if (event.getAction() == KeyEvent.ACTION_DOWN && keyCode == KeyEvent.KEYCODE_ENTER) {
+                    // hide keyboard
+                    InputMethodManager inputMethodManager = (InputMethodManager) getSystemService(Context.INPUT_METHOD_SERVICE);
+                    inputMethodManager.hideSoftInputFromWindow(v.getWindowToken(), 0);
+                    return true;
+                }
+                return false;
+            }
+        });
+    }
+
+    /**
+     * execute any command
+     */
+    private BufferedReader exec(String cmd, boolean toast) {
+        Process p = null;
+        try {
+            p = Runtime.getRuntime().exec(cmd);
+        } catch (IOException e) {
+            e.printStackTrace();
+            Toast.makeText(this, e.getLocalizedMessage(), Toast.LENGTH_SHORT).show();
+            return null;
+        }
+
+        if (toast) {
+            Toast.makeText(this, cmd + " / " + p.toString(), Toast.LENGTH_SHORT).show();
+            return null;
+        }
+
+        int w = -1;
+        try {
+            w = p.waitFor();
+        } catch (InterruptedException e) {
+            e.printStackTrace();
+            Toast.makeText(this, e.getLocalizedMessage(), Toast.LENGTH_SHORT).show();
+            return null;
+        }
+
+        Log.d(TAG, "exec(" + cmd + ") " + p.toString() + " exit[" + w + "]");
+        InputStreamReader isr = new InputStreamReader(p.getInputStream());
+        BufferedReader br = new BufferedReader(isr);
+        return br;
+    }
+
+    /**
+     * execute command in su<br />
+     * Warning! This method not yet implemented!<br />
+     * TODO: FIXME
+     */
+    private BufferedReader exec_su(String cmd, boolean toast) {
+        // String[] su = {"su", "-c", cmd};
+
+        Process p = null;
+        //try {
+        //    p = Runtime.getRuntime().exec("su -c " + cmd);
+        //} catch (IOException e) {
+        //    e.printStackTrace();
+        //    Toast.makeText(this, e.getLocalizedMessage(), Toast.LENGTH_SHORT).show();
+        //    return null;
+        //}
+
+        DataOutputStream dos = null;
+        try {
+            p = Runtime.getRuntime().exec("su");
+        } catch (IOException e) {
+            e.printStackTrace();
+            return null;
+        }
+
+        dos = new DataOutputStream(p.getOutputStream());
+        try {
+            dos.writeBytes(cmd);
+            dos.writeBytes("\n");
+            dos.writeBytes("exit\n");
+        } catch (IOException e) {
+            e.printStackTrace();
+        }
+
+        if (toast) {
+            Toast.makeText(this, cmd + " / " + p.toString(), Toast.LENGTH_SHORT).show();
+            return null;
+        }
+
+        int w = -1;
+        try {
+            w = p.waitFor();
+        } catch (InterruptedException e) {
+            e.printStackTrace();
+            Toast.makeText(this, e.getLocalizedMessage(), Toast.LENGTH_SHORT).show();
+            return null;
+        }
+
+        Log.d(TAG, "exec(" + cmd + ") " + p.toString() + " exit[" + w + "]");
+        InputStreamReader isr = new InputStreamReader(p.getInputStream());
+        BufferedReader br = new BufferedReader(isr);
+        return br;
+    }
+
+    /**
+     * kill wfd command process
+     */
+    private void initFinishButton() {
+        Button b = (Button) findViewById(R.id.button2);
+        b.setOnClickListener(new OnClickListener() {
+            // @Override
+            public void onClick(View v) {
+                exec_pswfd_killwfd();
+            }
+
+            // 1) ps (find wfd pid)
+            // 2) kill wfd pid
+            private void exec_pswfd_killwfd() {
+                BufferedReader br = exec("ps wfd", false);
+                if (br == null) {
+                    Toast.makeText(MainActivity.this, "exec_lswfd_killwfd() failed-1.", Toast.LENGTH_SHORT).show();
+                    return;
+                }
+
+                try {
+                    int linec = 0;
+                    String line = null;
+                    while ((line = br.readLine()) != null) {
+                        Log.d(TAG, String.format("[%02d]%s", linec++, line));
+                        if (linec == 1) { // skip ps command output first line
+                            continue;
+                        }
+
+                        String pid = getpid(line);
+                        if (pid == null) {
+                            continue;
+                        }
+
+                        exec("kill " + pid, true);
+                    }
+                } catch (IOException e) {
+                    Toast.makeText(MainActivity.this, "exec_lswfd_killwfd() failed.", Toast.LENGTH_SHORT).show();
+                    e.printStackTrace();
+                }
+            }
+
+            // get wfd command PID in ps command output
+            private String getpid(String line) {
+                if (line == null) {
+                    return null;
+                }
+
+                // [00]USER PID PPID VSIZE RSS WCHAN PC NAME
+                // [01]root 17013 1 11444 3660 ffffffff 00000000 S wfd
+                String words[] = line.split("\\s+");
+                if (words == null || words.length < 2) {
+                    return null;
+                }
+
+                return words[1];
+            }
+        });
+
+    }
+
+    /**
+     * set IP address to TextEdit
+     */
+    private void setIPAddrToEdit(String ip) {
+        AutoCompleteTextView actv = (AutoCompleteTextView) findViewById(R.id.autoCompleteTextView1);
+        actv.setText(ip);
+    }
+
+    /**
+     * get IP address String from TextEdit
+     */
+    private String getIP() {
+        AutoCompleteTextView actv = (AutoCompleteTextView) findViewById(R.id.autoCompleteTextView1);
+        return actv.getText().toString();
+    }
+
+    /**
+     * get Port String from TextEdit
+     */
+    private String getPort() {
+        EditText et = (EditText) findViewById(R.id.editText1);
+        return et.getText().toString();
+    }
+
+    /**
+     * get Port int from TextEdit
+     */
+    private int getIntPort() {
+        String p = getPort();
+        int port = -1;
+
+        try {
+            port = Integer.parseInt(p);
+        } catch (NumberFormatException e) {
+            e.printStackTrace();
+            port = 19000;
+        }
+
+        Log.d(TAG, "getIntPort() return["+port+"]");
+        return port;
+    }
+
+    /**
+     * framework buttons
+     */
+    private void initFWButtons() {
+        // f/w - wi-fi - source
+        Button b = (Button) findViewById(R.id.button3);
+        b.setOnClickListener(new OnClickListener() {
+            @Override
+            public void onClick(View v) {
+                invokeSource();
+            }
+        });
+
+        // f/w - wi-fi - source
+        b = (Button) findViewById(R.id.button31);
+        b.setOnClickListener(new OnClickListener() {
+            @Override
+            public void onClick(View v) {
+                invokeSource_wfd(getIP(), getIntPort());
+            }
+        });
+
+        // f/w - wi-fi - sink
+        b = (Button) findViewById(R.id.button4);
+        b.setOnClickListener(new OnClickListener() {
+            @Override
+            public void onClick(View v) {
+                invokeSink(getIP(), getIntPort());
+            }
+        });
+
+        // f/w - p2p - sink
+        b = (Button) findViewById(R.id.button5);
+        b.setOnClickListener(new OnClickListener() {
+            @Override
+            public void onClick(View v) {
+                gotoP2pSink();
+            }
+        });
+    }
+
+    /** DisplayManager.connectWifiDisplay() */
+    private DisplayManager mDisplayManager;
+
+    /**
+     * invoke Source for listen Sink
+     */
+    private void invokeSource() {
+        if (mDisplayManager == null) {
+            mDisplayManager = (DisplayManager)getSystemService(Context.DISPLAY_SERVICE);
+        }
+
+        if (mDisplayManager == null) {
+            Log.e(TAG, "invokeSource() mDisplayManager is NULL!!");
+            return;
+        }
+
+        String iface = getIP() + ":" + getPort();
+        Log.d(TAG, "invokeSource() listen["+iface+"]");
+
+        final boolean FWBUILD = true;
+        if (FWBUILD) {
+            mDisplayManager.connectWifiDisplay(iface); // @hide method
+            Toast.makeText(this, "invokeSource() called connectWifiDisplay("+iface+")", Toast.LENGTH_SHORT).show();
+        } else {
+            setupSourceRef(iface);
+        }
+    }
+
+    /**
+     * invoke Source by Java Reflection
+     */
+    private boolean setupSourceRef(String iface) {
+        // get class
+        Class<?> clazz = mDisplayManager.getClass();
+
+        // get method
+        Method met;
+        try {
+            met = clazz.getMethod("connectWifiDisplay", String.class);
+        } catch (NoSuchMethodException e) {
+            e.printStackTrace();
+            return false;
+        }
+
+        // invoke method
+        Object ret;
+        try {
+            ret = met.invoke(mDisplayManager, iface);
+        } catch (IllegalArgumentException e) {
+            e.printStackTrace();
+            return false;
+        } catch (IllegalAccessException e) {
+            e.printStackTrace();
+            return false;
+        } catch (InvocationTargetException e) {
+            e.printStackTrace();
+            return false;
+        }
+
+        Toast.makeText(this, "setupSourceRef("+iface+") [" + ret + "]", Toast.LENGTH_SHORT).show();
+
+        Log.d(TAG, "setupSourceRef() ["+ret+"]");
+        return true;
+    }
+
+    /**
+     * invoke Source for listen Sink
+     */
+    private void invokeSource_wfd(String ip, int port) {
+        Log.d(TAG, "invokeSource_wfd() Source Addr["+ip+":"+port+"]");
+        new AvoidANRThread(true, ip, port).start();
+        showStaticToast("invokeSource_wfd() called nativeInvokeSource("+ip+":"+port+")");
+    }
+
+    /**
+     * invoke Sink wrapper
+     */
+    public static void invokeSink(String ip, int port) {
+        Log.d(TAG, "invokeSink() Source Addr["+ip+":"+port+"]");
+        new AvoidANRThread(false, ip, port).start();
+        showStaticToast("invokeSink() called nativeInvokeSink("+ip+":"+port+")");
+    }
+
+    /**
+     * static toast
+     */
+    private static void showStaticToast(final String msg) {
+        mSelf.runOnUiThread(new Runnable() {
+            @Override
+            public void run() {
+                Toast.makeText(mSelf, msg, Toast.LENGTH_SHORT).show();
+            }
+        });
+    }
+
+    /**
+     * Avoid ANR
+     */
+    private static class AvoidANRThread extends Thread {
+        private final boolean source;
+        private final String ip;
+        private final int port;
+
+        AvoidANRThread(boolean _source, String _ip, int _port) {
+            source = _source;
+            ip = _ip;
+            port = _port;
+        }
+
+        public void run() {
+            if (source) {
+                nativeInvokeSource(ip, port);
+            } else {
+                nativeInvokeSink(ip, port);
+            }
+        }
+    }
+
+    /**
+     * JNI:invoke Source
+     */
+    private static native void nativeInvokeSource(String ip, int port);
+
+    /**
+     * JNI:invoke Sink
+     */
+    private static native void nativeInvokeSink(String ip, int port);
+
+    /**
+     * invoke p2p Sink Activity
+     */
+    private void gotoP2pSink() {
+        String pac = "com.example.mira4u";
+
+        Intent i = new Intent();
+        i.setClassName(pac, pac + ".P2pSinkActivity");
+        startActivity(i);
+    }
+
+    /**
+     * invoke Settings Activity
+     */
+    private void gotoSettings() {
+        String pac = "com.example.mira4u";
+
+        Intent i = new Intent();
+        i.setClassName(pac, pac + ".SettingsActivity");
+        startActivity(i);
+    }
+
+    /**
+     * onCreateOptionsMenu
+     */
+    @Override
+    public boolean onCreateOptionsMenu(Menu menu){
+        menu.add(Menu.NONE, 0, Menu.NONE, getString(R.string.set_name));
+        return true;
+    }
+
+    /**
+     * onOptionsItemSelected
+     */
+    public boolean onOptionsItemSelected(MenuItem item) {
+        switch (item.getItemId()) {
+        case 0:
+            gotoSettings();
+            return true;
+
+        default:
+            Log.w(TAG, "onOptionsItemSelected() Unknown Menu Id Passed["+item.getItemId()+"]");
+            return true;
+        }
+    }
+ 
+    static {
+        System.loadLibrary("Mira4U");
+    }
+
+}
diff -Naur a/packages/apps/Mira4U/src/com/example/mira4u/P2pSinkActivity.java b/packages/apps/Mira4U/src/com/example/mira4u/P2pSinkActivity.java
--- a/packages/apps/Mira4U/src/com/example/mira4u/P2pSinkActivity.java	1969-12-31 19:00:00.000000000 -0500
+++ b/packages/apps/Mira4U/src/com/example/mira4u/P2pSinkActivity.java	2013-08-14 04:13:30.000000000 -0400
@@ -0,0 +1,921 @@
+package com.example.mira4u;
+
+import java.util.ArrayList;
+import java.util.Collection;
+import java.util.List;
+import java.util.Timer;
+import java.util.TimerTask;
+
+import android.app.Activity;
+import android.content.ActivityNotFoundException;
+import android.content.BroadcastReceiver;
+import android.content.Context;
+import android.content.Intent;
+import android.content.IntentFilter;
+import android.content.pm.PackageManager;
+import android.graphics.Color;
+import android.net.NetworkInfo;
+import android.net.wifi.WifiInfo;
+import android.net.wifi.WifiManager;
+import android.net.wifi.p2p.WifiP2pDevice;
+import android.net.wifi.p2p.WifiP2pDeviceList;
+import android.net.wifi.p2p.WifiP2pGroup;
+import android.net.wifi.p2p.WifiP2pInfo;
+import android.net.wifi.p2p.WifiP2pManager;
+import android.net.wifi.p2p.WifiP2pManager.Channel;
+import android.net.wifi.p2p.WifiP2pManager.ChannelListener;
+import android.net.wifi.p2p.WifiP2pManager.ConnectionInfoListener;
+import android.net.wifi.p2p.WifiP2pManager.GroupInfoListener;
+import android.net.wifi.p2p.WifiP2pManager.PeerListListener;
+import android.net.wifi.p2p.WifiP2pWfdInfo;
+import android.os.Build;
+import android.os.Bundle;
+import android.os.Handler;
+import android.provider.Settings;
+import android.text.Editable;
+import android.text.Html;
+import android.text.TextWatcher;
+import android.util.Log;
+import android.view.View;
+import android.widget.AdapterView;
+import android.widget.AdapterView.OnItemSelectedListener;
+import android.widget.ArrayAdapter;
+import android.widget.RadioGroup;
+import android.widget.RadioGroup.OnCheckedChangeListener;
+import android.widget.CompoundButton;
+import android.widget.ScrollView;
+import android.widget.Spinner;
+import android.widget.TextView;
+import android.widget.Toast;
+import android.widget.ToggleButton;
+
+/**
+ * P2p Sink daemon<br />
+ * base src: https://github.com/kensuke/WiFiDirectTestApp
+ */
+public class P2pSinkActivity extends Activity {
+
+    /** TAG */
+    private final String TAG = "P2pSinkActivity";
+
+    /**  */
+    private TextView mTextView_Log;
+    /**  */
+    private final String LINE_SEPARATOR = System.getProperty("line.separator");
+    private final String LINE_SEPARATOR_HTML = "<br />";
+    /** HTML
+     * TODO Pref/
+     */
+    private boolean HTML_OUT = true;
+
+    /** BroadcastReceiver */
+    private BroadcastReceiver mReceiver;
+
+    /** Wi-Fi Direct / */
+    private boolean mIsWiFiDirectEnabled;
+
+    /** WifiP2pManager */
+    private WifiP2pManager mWifiP2pManager;
+    /** Channel */
+    private Channel mChannel;
+    /** peers */
+    private List<WifiP2pDevice> mPeers = new ArrayList<WifiP2pDevice>();
+    /**  */
+    private ActionListenerAdapter mActionListenerAdapter;
+
+    /**  */
+    private Spinner mPeersSpinner;
+    /**  */
+    private String mSelectedDevice;
+
+    /** for delayed execute */
+    private Handler mHandler;
+
+    /* 
+     * Activity API
+     */
+
+    @Override
+    public void onCreate(Bundle savedInstanceState) {
+        super.onCreate(savedInstanceState);
+        setContentView(R.layout.activity_p2p);
+
+        String title = "ANDROID_ID[" + getAndroid_ID() + "]";
+        title += "   MAC[" + getMACAddress() + "]";
+        //setTitle(title);
+
+        initializeLog();
+        initBroadcastToggle();
+
+        addLog(title);
+        addLog("onCreate()");
+
+        if (!hasP2P()) {
+            toastAndLog("onCreate()", "This Device Has Not P2P Feature!!");
+        }
+    }
+
+    private boolean mIsAppBoot;
+
+    @Override
+    protected void onResume() {
+        super.onResume();
+        addLog("onResume()");
+
+        // WIFI_P2P_STATE_CHANGED_ACTIONWi-Fi Direct ON/OFF
+        mIsWiFiDirectEnabled = false;
+
+        mIsAppBoot = true;
+
+        // better
+        registerBroadcastReceiver();
+
+        mHandler = new Handler();
+    }
+
+    @Override
+    protected void onPause() {
+        super.onPause();
+        addLog("onPause()");
+
+        // 
+        unRegisterBroadcastReceiver();
+    }
+
+    /**
+     * 
+     */
+    private void registerBroadcastReceiver() {
+        IntentFilter filter = new IntentFilter();
+        filter.addAction(WifiP2pManager.WIFI_P2P_STATE_CHANGED_ACTION);
+        filter.addAction(WifiP2pManager.WIFI_P2P_PEERS_CHANGED_ACTION);
+        filter.addAction(WifiP2pManager.WIFI_P2P_CONNECTION_CHANGED_ACTION);
+        filter.addAction(WifiP2pManager.WIFI_P2P_THIS_DEVICE_CHANGED_ACTION);
+        mReceiver = new WiFiDirectBroadcastReceiver();
+        registerReceiver(mReceiver, filter);
+        addLog("registerBroadcastReceiver() BroadcastReceiver");
+    }
+
+    /**
+     * 
+     */
+    private void unRegisterBroadcastReceiver() {
+        if (mReceiver != null) {
+            unregisterReceiver(mReceiver);
+            mReceiver = null;
+            addLog("unRegisterBroadcastReceiver() BroadcastReceiver");
+        }
+    }
+
+    /**
+     *   
+     */
+    private void initBroadcastToggle() {
+        initBroadcastToggleInner(R.id.toggle_bc_all);
+    }
+
+    /**
+     *  
+     */
+    private void initBroadcastToggleInner(final int rId_Toggle) {
+        // ON/OFF
+        ToggleButton tb = (ToggleButton)findViewById(rId_Toggle);
+        tb.setOnCheckedChangeListener( new CompoundButton.OnCheckedChangeListener() {
+            @Override
+            public void onCheckedChanged(CompoundButton buttonView, boolean isChecked) {
+                if (isChecked) {
+                    registerBroadcastReceiver();
+                } else {
+                    unRegisterBroadcastReceiver();
+                }
+            }
+        });
+    }
+
+    /* 
+     * 
+     * TODO 
+     */
+
+    /**
+     * 
+     */
+    private void initializeLog() {
+        if (mTextView_Log != null) {
+            return;
+        }
+
+        mTextView_Log = (TextView)findViewById(R.id.textView_log);
+
+        // (=)
+        mTextView_Log.addTextChangedListener( new TextWatcher() {
+            public void onTextChanged(CharSequence s, int start, int before, int count) {
+                // 
+                ToggleButton tb = (ToggleButton)findViewById(R.id.toggle_autoscroll);
+                if (!tb.isChecked()) {
+                    return;
+                }
+
+                // 
+                final ScrollView sv = (ScrollView)findViewById(R.id.scrollview_log);
+                sv.post( new Runnable() {
+                    public void run() {
+                        sv.fullScroll(View.FOCUS_DOWN);
+                    }
+                });
+            }
+
+            public void beforeTextChanged(CharSequence s, int start, int count, int after) {}
+            public void afterTextChanged(Editable s) {}
+        });
+
+        // ((HTML))
+        RadioGroup rg = (RadioGroup)findViewById(R.id.radiogroup_logkind);
+        rg.setOnCheckedChangeListener( new OnCheckedChangeListener() {
+            @Override
+            public void onCheckedChanged(RadioGroup group, int checkedId) {
+                switch (checkedId) {
+                case R.id.radiobutton_html: // 
+                    HTML_OUT = true;
+                    break;
+                case R.id.radiobutton_mono: // 
+                    HTML_OUT = false;
+                    break;
+                default:
+                    addLog("initializeLog() Unknown Log Kind["+checkedId+"]");
+                    HTML_OUT = false;
+                    break;
+                }
+            }
+        });
+    }
+
+    /**
+     * 
+     */
+    private void addLog(String log) {
+        Log.d(TAG, log);
+
+        log = log + nl();
+        if (mTextView_Log == null) {
+            initializeLog();
+        }
+        mTextView_Log.append( HTML_OUT ? convHtmlStr2CS(log) : log );
+    }
+
+    /**
+     * HTMl
+     */
+    private CharSequence convHtmlStr2CS(String htmlStr) {
+        return Html.fromHtml(htmlStr);
+    }
+
+    /**
+     * 
+     */
+    private String nl() {
+        return HTML_OUT ? LINE_SEPARATOR_HTML : LINE_SEPARATOR;
+    }
+
+    /**
+     * P2P
+     */
+    private void addMethodLog(String method) {
+        if (HTML_OUT) method = "<font color=lime>"+method+"</font>";
+        addLog(nl() + method);
+    }
+
+    /**
+     * 
+     */
+    private void toastAndLog(String msg1, String msg2) {
+        String log = msg1 + LINE_SEPARATOR + msg2;
+        Toast.makeText(this, log, Toast.LENGTH_SHORT).show();
+
+        if (HTML_OUT) log = "<font color=red>" + msg1 + nl() + msg2 + "</font>";
+        addLog(log);
+    }
+
+    /**
+     * 
+     */
+    public void onClickResetLog(View view) {
+        mTextView_Log.setText("");
+    }
+
+    /**
+     * 
+     * TODO SD
+     */
+    public void onClickSaveLog(View view) {
+       String log = mTextView_Log.getText().toString();
+       Log.d(TAG, "onClickSaveLog() LOG["+log+"]");
+    }
+
+    /**
+     * ()
+     */
+    private String toStringDevice(WifiP2pDevice device) {
+        String log = separateCSV(device.toString()) + nl() + "" + getDeviceStatus(device.status);
+        return HTML_OUT ? "<font color=yellow>"+log+"</font>" : log;
+    }
+
+    // ":"
+    // " Device: Galaxy_Nexus"+
+    // " primary type: 12345-xyz"
+    // 
+    // " Device: Galaxy_Nexus<br />"+
+    // " primary type: 12345-xyz<br />"
+    private String separateCSV(String csvStr) {
+        //return csvStr;
+        return csvStr.replaceAll("[^:yWFD] ", nl()+""); // ": ""y " 
+        // "
+        //"deviceAddress: AB:CD""deviceAddress:<br />AB:CD"
+        //"primary type:""primary<br />type:"
+        //"WFD CtrlPort: 554"WFD<br />CtrlPort: 554 <= Android 4.2Miracast
+    }
+
+    // TODO FIXME WFD
+    //sbuf.append("Device: ").append(deviceName);
+    //sbuf.append("\n deviceAddress: ").append(deviceAddress);
+    //sbuf.append("\n primary type: ").append(primaryDeviceType);
+    //sbuf.append("\n secondary type: ").append(secondaryDeviceType);
+    //sbuf.append("\n wps: ").append(wpsConfigMethodsSupported);
+    //sbuf.append("\n grpcapab: ").append(groupCapability);
+    //sbuf.append("\n devcapab: ").append(deviceCapability);
+    //sbuf.append("\n status: ").append(status);
+    //sbuf.append("\n wfdInfo: ").append(wfdInfo);
+    // wfdInfo: WFD enabled: trueWFD DeviceInfo: 349
+    // WFD CtrlPort: 554
+    // WFD MaxThroughput: 50
+
+    // 
+    private String getDeviceStatus(int deviceStatus) {
+        String status = "";
+        switch (deviceStatus) {
+            case WifiP2pDevice.AVAILABLE:
+                status = "Available";
+                break;
+            case WifiP2pDevice.INVITED:
+                status = "Invited";
+                break;
+            case WifiP2pDevice.CONNECTED:
+                status = "Connected";
+                break;
+            case WifiP2pDevice.FAILED:
+                status = "Failed";
+                break;
+            case WifiP2pDevice.UNAVAILABLE:
+                status = "Unavailable";
+                break;
+            default:
+                status = "Unknown";
+                break;
+        }
+        return HTML_OUT ? "[<b><i><u>"+status+"</u></i></b>]" : "["+status+"]";
+    }
+
+    /* 
+     * P2P API
+     */
+
+    /**
+     * 
+     * WifiP2pManagerWifiP2pManager.ActionListener
+     * successfailure
+     */
+    class ActionListenerAdapter implements WifiP2pManager.ActionListener {
+
+        // 
+        public void onSuccess() {
+            String log = " onSuccess()";
+            if (HTML_OUT) log = "<font color=aqua>"+log+"</font>";
+            addLog(log);
+        }
+
+        // 
+        public void onFailure(int reason) {
+            String log = " onFailure("+getReason(reason)+")";
+            if (HTML_OUT) log = "<font color=red>"+log+"</font>";
+            addLog(log);
+        }
+
+        // int -> 
+        private String getReason(int reason) {
+            String[] strs = {"ERROR", "P2P_UNSUPPORTED", "BUSY"};
+            try {
+                return strs[reason] + "("+reason+")";
+            } catch (ArrayIndexOutOfBoundsException e) {
+                return "UNKNOWN REASON CODE("+reason+")";
+            }
+        }
+    }
+
+    /**
+     * P2PNULL
+     */
+    private boolean isNull(boolean both) {
+        if (mActionListenerAdapter == null) {
+            mActionListenerAdapter = new ActionListenerAdapter();
+        }
+
+        if (!mIsWiFiDirectEnabled) {
+            toastAndLog(" Wi-Fi Direct is OFF!", "try Setting Menu");
+            return true;
+        }
+
+        if (mWifiP2pManager == null) {
+            toastAndLog(" mWifiP2pManager is NULL!", " try getSystemService");
+            return true;
+        }
+        if (both && (mChannel == null) ) {
+            toastAndLog(" mChannel is NULL!", " try initialize");
+            return true;
+        }
+
+        return false;
+    }
+
+    /**
+     * 
+     */
+    public void onClickGetSystemService(View view) {
+        addMethodLog("getSystemService(Context.WIFI_P2P_SERVICE)");
+
+        mWifiP2pManager = (WifiP2pManager) getSystemService(Context.WIFI_P2P_SERVICE);
+
+        addLog("Result["+(mWifiP2pManager != null)+"]");
+    }
+
+    /**
+     * 
+     */
+    public void onClickInitialize(View view) {
+        addMethodLog("mWifiP2pManager.initialize()");
+        if (isNull(false)) { return; }
+
+        mChannel = mWifiP2pManager.initialize(this, getMainLooper(), new ChannelListener() {
+            public void onChannelDisconnected() {
+                addLog("mWifiP2pManager.initialize() -> onChannelDisconnected()");
+            }
+        });
+
+        addLog("Result["+(mChannel != null)+"]");
+    }
+
+    /**
+     * 
+     */
+    public void onClickDiscoverPeers(View view) {
+        addMethodLog("mWifiP2pManager.discoverPeers()");
+        if (isNull(true)) { return; }
+
+        mWifiP2pManager.discoverPeers(mChannel, mActionListenerAdapter);
+    }
+
+    /**
+     * 
+     */
+    public void onClickCancelConnect(View view) {
+        addMethodLog("mWifiP2pManager.cancelConnect()");
+        if (isNull(true)) { return; }
+
+        mWifiP2pManager.cancelConnect(mChannel, mActionListenerAdapter);
+    }
+
+    /**
+     * 
+     */
+    public void onClickCreateGroup(View view) {
+        addMethodLog("mWifiP2pManager.createGroup()");
+        if (isNull(true)) { return; }
+
+        mWifiP2pManager.createGroup(mChannel, mActionListenerAdapter);
+    }
+
+    /**
+     * 
+     */
+    public void onClickRemoveGroup(View view) {
+        addMethodLog("mWifiP2pManager.removeGroup()");
+        if (isNull(true)) { return; }
+
+        mWifiP2pManager.removeGroup(mChannel, mActionListenerAdapter);
+    }
+
+    /**
+     * 
+     */
+    public void onClickRequestConnectionInfo(View view) {
+        addMethodLog("mWifiP2pManager.requestConnectionInfo()");
+        if (isNull(true)) { return; }
+
+        mWifiP2pManager.requestConnectionInfo(mChannel, new ConnectionInfoListener() {
+            // requestConnectionInfo()
+            public void onConnectionInfoAvailable(WifiP2pInfo info) {
+                addLog("onConnectionInfoAvailable():");
+                if (info == null) {
+                    addLog("  info is NULL!");
+                    return;
+                }
+                addLog("  groupFormed:" + info.groupFormed);
+                addLog("  isGroupOwner:" + info.isGroupOwner);
+                addLog("  groupOwnerAddress:" + info.groupOwnerAddress);
+            }
+        });
+    }
+
+    /**
+     * 
+     */
+    public void onClickRequestGroupInfo(View view) {
+        addMethodLog("mWifiP2pManager.requestGroupInfo()");
+        if (isNull(true)) { return; }
+
+        mWifiP2pManager.requestGroupInfo(mChannel, new GroupInfoListener() {
+            // requestGroupInfo()
+            public void onGroupInfoAvailable(WifiP2pGroup group) {
+                addLog("onGroupInfoAvailable():");
+                if (group == null) {
+                    addLog("  group is NULL!");
+                    return;
+                }
+
+                String log = separateCSV(group.toString());
+
+                // G.O.
+                String pass = nl() + "password: ";
+                if (group.isGroupOwner()) {
+                    pass += group.getPassphrase();
+                } else {
+                    pass += "Client Couldn't Get Password";
+                }
+                if (HTML_OUT) pass = "<font color=red><b>"+pass+"</b></font>"; // font color()
+                log += pass;
+                if (HTML_OUT) log = "<font color=#fffacd>"+log+"</font>"; // color=lemonchiffon
+                addLog(log);
+            }
+        });
+    }
+
+    /**
+     * 
+     */
+    public void onClickRequestPeers(View view) {
+        addMethodLog("mWifiP2pManager.requestPeers()");
+        if (isNull(true)) { return; }
+
+        mWifiP2pManager.requestPeers(mChannel, new PeerListListener() {
+            // requestPeers()
+            public void onPeersAvailable(WifiP2pDeviceList peers) {
+                mPeers.clear();
+                mPeers.addAll(peers.getDeviceList());
+                int cnt = mPeers.size();
+                addLog("onPeersAvailable() : num of peers["+cnt+"]");
+                for (int i = 0; i < cnt; i++) {
+                    addLog(nl() + " ***********["+i+"]***********");
+                    addLog("  " + toStringDevice(mPeers.get(i)));
+                }
+
+                updatePeersSpinner();
+            }
+        });
+    }
+
+    /**
+     * UI
+     */
+    private void updatePeersSpinner() {
+        // 
+        if (mPeersSpinner == null) {
+            mPeersSpinner = (Spinner)findViewById(R.id.spinner_peers);
+            mPeersSpinner.setOnItemSelectedListener( new OnItemSelectedListener() {
+                public void onItemSelected(AdapterView<?> parent, View view, int position, long id) {
+                    mSelectedDevice = mPeers.get(position).deviceName;
+                    addLog(nl() + "Selected Peer["+mSelectedDevice+"]");
+                }
+
+                public void onNothingSelected(AdapterView<?> arg0) {}
+            });
+        }
+
+        // 
+        int cnt = mPeers.size();
+        String[] peers = new String[cnt];
+        for (int i = 0; i < cnt; i++) {
+            peers[i] = mPeers.get(i).deviceName;
+        }
+        ArrayAdapter<String> adapter = new ArrayAdapter<String>(this, android.R.layout.simple_spinner_item, peers);
+        mPeersSpinner.setAdapter(adapter);
+    }
+
+    /** 
+     * 
+     */
+    public class WiFiDirectBroadcastReceiver extends BroadcastReceiver {
+
+        @Override
+        public void onReceive(Context context, Intent intent) {
+            String action = intent.getAction();
+            String log = "onReceive() ["+action+"]";
+            if (HTML_OUT) log = "<font color=fuchsia>"+log+"</font>";
+            addLog(nl() + log);
+
+            if (WifiP2pManager.WIFI_P2P_STATE_CHANGED_ACTION.equals(action)) {
+                mIsWiFiDirectEnabled = false;
+                int state = intent.getIntExtra(WifiP2pManager.EXTRA_WIFI_STATE, -1);
+                String sttStr;
+                switch (state) {
+                case WifiP2pManager.WIFI_P2P_STATE_ENABLED:
+                    mIsWiFiDirectEnabled = true;
+                    sttStr = "ENABLED";
+                    break;
+                case WifiP2pManager.WIFI_P2P_STATE_DISABLED:
+                    sttStr = "DISABLED";
+                    break;
+                default:
+                    sttStr = "UNKNOWN";
+                    break;
+                }
+                addLog("state["+sttStr+"]("+state+")");
+                changeBackgroundColor();
+
+                // 
+                if (mIsWiFiDirectEnabled) {
+                    onClickGetSystemService(null);
+                    onClickInitialize(null);
+                }
+            } else if (WifiP2pManager.WIFI_P2P_PEERS_CHANGED_ACTION.equals(action)) {
+                // requestPeers()peer()
+                // requestPeers()
+                addLog("try requestPeers()");
+            } else if (WifiP2pManager.WIFI_P2P_CONNECTION_CHANGED_ACTION.equals(action)) {
+                NetworkInfo networkInfo = (NetworkInfo) intent.getParcelableExtra(WifiP2pManager.EXTRA_NETWORK_INFO);
+                // networkInfo.toString()CSV(1)
+                String nlog = networkInfo.toString().replaceAll(",", nl()+"");
+                if (HTML_OUT) nlog = "<font color=#f0e68c>"+nlog+"</font>"; // khaki
+                addLog(nlog);
+
+                // invoke Sink
+                if (networkInfo.isConnected()) {
+                    mIsAppBoot = false;
+                    invokeSink();
+                } else if (!mIsAppBoot) {
+                    //finish();
+                    System.exit(0); // force finish Sink Screen. TODO FIXME^^;;
+                }
+            } else if (WifiP2pManager.WIFI_P2P_THIS_DEVICE_CHANGED_ACTION.equals(action)) {
+                WifiP2pDevice device = (WifiP2pDevice) intent.getParcelableExtra(WifiP2pManager.EXTRA_WIFI_P2P_DEVICE);
+                addLog(toStringDevice(device));
+
+                // Search
+                if (mIsWiFiDirectEnabled) {
+                    onClickDiscoverPeers(null);
+                }
+            }
+        }
+    }
+
+    /**
+     * APIWi-Fi Direct/
+     *  
+     *  
+     */
+    private void changeBackgroundColor() {
+        ScrollView sc = (ScrollView)findViewById(R.id.layout_apibuttons);
+        sc.setBackgroundColor( mIsWiFiDirectEnabled ? Color.BLUE : Color.RED );
+    }
+
+    /* 
+     * 
+     */
+
+    /**
+     * ANDROID_ID
+     */
+    private String getAndroid_ID() {
+        return Settings.Secure.getString(getContentResolver(), Settings.Secure.ANDROID_ID);
+    }
+
+    /**
+     * Wi-Fi MAC
+     */
+    private String getMACAddress() {
+        WifiManager manager = (WifiManager) getSystemService(Context.WIFI_SERVICE);
+        WifiInfo wifiInfo = manager.getConnectionInfo();
+        String mac = wifiInfo.getMacAddress();
+        return mac;
+    }
+
+    /**
+     * p2p feature
+     */
+    private boolean hasP2P() {
+        return getPackageManager().hasSystemFeature(PackageManager.FEATURE_WIFI_DIRECT);
+    }
+
+    /**
+     * Wi-Fi Direct 
+     */
+    public void onClickGotoWiFiSetting(View view) {
+        String pac = "com.android.settings";
+        Intent i = new Intent();
+
+        // (Galaxy Nexus 4.0)
+        i.setClassName(pac, pac + ".wifi.p2p.WifiP2pSettings");
+        try {
+            startActivity(i);
+        } catch (ActivityNotFoundException e) {
+            Log.e(TAG, "onClickGotoWiFiSetting() " + e.getMessage());
+            // 17 4.2 JELLY_BEAN_MR1 
+            // 16 4.1, 4.1.1 JELLY_BEAN
+            // 15 4.0.3, 4.0.4 ICE_CREAM_SANDWICH_MR1
+            // 14 4.0, 4.0.1, 4.0.2 ICE_CREAM_SANDWICH
+            if (Build.VERSION.SDK_INT <= Build.VERSION_CODES.ICE_CREAM_SANDWICH+1) { // 14, 15 = ICS
+                startActivity(new Intent(Settings.ACTION_WIRELESS_SETTINGS)); // ICS"Wi-Fi"Wi-Fi DirectON/OFF
+            } else {
+                i.setClassName(pac, pac + ".wifi.WifiSettings"); // (JB)Wi-Fi^^;
+                // TODO 4.1startActivity()startPreferencePanel()
+                //if (getActivity() instanceof PreferenceActivity) {
+                //    ((PreferenceActivity) getActivity()).startPreferencePanel(
+                //         WifiP2pSettings.class.getCanonicalName(), null, R.string.wifi_p2p_settings_title, null, this, 0);
+                try {
+                    startActivity(i);
+                    Toast.makeText(this, "TRY menu -> Wi-Fi Direct", Toast.LENGTH_LONG).show();
+                } catch (ActivityNotFoundException e2) {
+                    Log.e(TAG, "onClickGotoWiFiSetting() " + e2.getMessage());
+                }
+            }
+        }
+    }
+
+    /* 
+     * Miracast Sink API
+     */
+ 
+   /**
+     * invoke Sink to Source IP Address
+     */
+    private void invokeSink() {
+        addMethodLog("invokeSink() call requestGroupInfo()");
+        if (isNull(true)) { return; }
+
+        mWifiP2pManager.requestGroupInfo(mChannel, new GroupInfoListener() {
+            // requestGroupInfo()
+            public void onGroupInfoAvailable(WifiP2pGroup group) {
+                addLog("onGroupInfoAvailable():");
+                if (group == null) {
+                    addLog("  group is NULL!");
+                    return;
+                }
+
+                String log = separateCSV(group.toString());
+
+                // G.O.
+                String pass = nl() + "password: ";
+                if (group.isGroupOwner()) {
+                    pass += group.getPassphrase();
+                } else {
+                    pass += "Client Couldn't Get Password";
+                }
+                if (HTML_OUT) pass = "<font color=red><b>"+pass+"</b></font>"; // font color()
+                log += pass;
+                if (HTML_OUT) log = "<font color=#fffacd>"+log+"</font>"; // color=lemonchiffon
+                addLog(log);
+
+                mP2pControlPort = -1;
+                // Miracast device filtering
+                Collection<WifiP2pDevice> p2pdevs = group.getClientList();
+                //AssertEqual(p2pdevs.size(), 1); // one device?
+                for (WifiP2pDevice dev : p2pdevs) {
+                    boolean b = isWifiDisplaySource(dev);
+                    addLog("invokeSink() isWifiDisplaySource("+dev.deviceName+")=["+b+"]");
+                    if (!b) {
+                        continue;
+                        // return; // because not Miracast Source device
+                    }
+                }
+                if (mP2pControlPort == -1) {
+                    //final class WifiDisplayController implements DumpUtils.Dump {
+                    //    private static final int DEFAULT_CONTROL_PORT = 7236;
+                    mP2pControlPort = 7236;
+                    addLog("invokeSink() port=-1?? p2pdevs.size()=["+p2pdevs.size()+"] port assigned=7236");
+                }
+
+                // connect
+                if (group.isGroupOwner()) { // G.O. don't know client IP, so check /proc/net/arp
+                    mP2pInterfaceName = group.getInterface();
+
+                    mArpTableObservationTimer = new Timer();
+                    ArpTableObservationTask task = new ArpTableObservationTask();
+                    mArpTableObservationTimer.scheduleAtFixedRate(task, 10, 1*1000); // 10ms1arp
+                } else { // this device is not G.O. get G.O. address
+                    invokeSink2nd();
+                }
+            }
+        });
+    }
+
+    /**
+     * Miracast device filtering
+     */
+    private boolean isWifiDisplaySource(WifiP2pDevice dev) {
+        if (dev == null || dev.wfdInfo == null) {
+            return false;
+        }
+        WifiP2pWfdInfo wfd = dev.wfdInfo;
+        if (!wfd.isWfdEnabled()) {
+            return false;
+        }
+
+        int type = wfd.getDeviceType();
+        mP2pControlPort = wfd.getControlPort();
+
+        boolean source = (type == WifiP2pWfdInfo.WFD_SOURCE) || (type == WifiP2pWfdInfo.SOURCE_OR_PRIMARY_SINK);
+        addLog("isWifiDisplaySource() type["+type+"] is-source["+source+"] port["+mP2pControlPort+"]");
+        return source;
+    }
+
+    /**
+     * invoke Sink
+     */
+    private void invokeSink2nd() {
+        addMethodLog("invokeSink2nd() requestConnectionInfo()");
+        if (isNull(true)) { return; }
+
+        mWifiP2pManager.requestConnectionInfo(mChannel, new ConnectionInfoListener() {
+            // requestConnectionInfo()
+            public void onConnectionInfoAvailable(WifiP2pInfo info) {
+                addLog("onConnectionInfoAvailable():");
+                if (info == null) {
+                    addLog("  info is NULL!");
+                    return;
+                }
+
+                addLog("  groupFormed:" + info.groupFormed);
+                addLog("  isGroupOwner:" + info.isGroupOwner);
+                addLog("  groupOwnerAddress:" + info.groupOwnerAddress);
+
+                if (!info.groupFormed) {
+                    addLog("  not yet groupFormed!");
+                    return;
+                }
+
+                if (info.isGroupOwner) {
+                    addLog("  I'm G.O.? Illegal State!!");
+                    return;
+                } else {
+                    String source_ip = info.groupOwnerAddress.getHostAddress();
+                    delayedInvokeSink(source_ip, mP2pControlPort, 3);
+                }
+            }
+        });
+    }
+
+    /** Wi-Fi Direct */
+    private Timer mArpTableObservationTimer;
+    /** arp */
+    private int mArpRetryCount = 0;
+    /** arp */
+    private final int MAX_ARP_RETRY_COUNT = 60;
+
+    /** p2p Control Port */
+    private int mP2pControlPort = -1;
+    /** p2p interface name */
+    private String mP2pInterfaceName;
+
+    /**
+     * /proc/net/arp 
+     */
+    class ArpTableObservationTask extends TimerTask {
+        @Override
+        public void run() {
+            // arp
+            RarpImpl rarp = new RarpImpl();
+            String source_ip = rarp.execRarp(mP2pInterfaceName);
+
+            // 
+            if (source_ip == null) {
+                Log.d(TAG, "retry:" + mArpRetryCount);
+                if (++mArpRetryCount > MAX_ARP_RETRY_COUNT) {
+                    mArpTableObservationTimer.cancel();
+                    return;
+                }
+                return;
+            }
+
+            mArpTableObservationTimer.cancel();
+            delayedInvokeSink(source_ip, mP2pControlPort, 3);
+        }
+    }
+
+    private void delayedInvokeSink(final String ip, final int port, int delaySec) {
+        mHandler.postDelayed(new Runnable() {
+            @Override
+            public void run() {
+                MainActivity.invokeSink(ip, port);
+            }
+        }, delaySec*1000);
+    }
+
+}
diff -Naur a/packages/apps/Mira4U/src/com/example/mira4u/RarpImpl.java b/packages/apps/Mira4U/src/com/example/mira4u/RarpImpl.java
--- a/packages/apps/Mira4U/src/com/example/mira4u/RarpImpl.java	1969-12-31 19:00:00.000000000 -0500
+++ b/packages/apps/Mira4U/src/com/example/mira4u/RarpImpl.java	2013-08-14 04:13:30.000000000 -0400
@@ -0,0 +1,231 @@
+package com.example.mira4u;
+
+import java.io.BufferedReader;
+import java.io.File;
+import java.io.FileInputStream;
+import java.io.FileNotFoundException;
+import java.io.IOException;
+import java.io.InputStreamReader;
+import java.io.UnsupportedEncodingException;
+import java.util.ArrayList;
+
+import android.util.Log;
+
+/**
+ * MACIP
+ * /proc/net/arp 
+ * arp
+ * IP address       HW type     Flags       HW address            Mask     Device
+ * 192.168.49.208   0x1         0x2         a2:0b:ba:ba:c4:d1     *        p2p-wlan0-8
+ */
+public class RarpImpl {
+
+    /** TAG */
+    private String TAG = "RarpImpl";
+
+    /** ARP */
+    public final String ARP_PATH = "/proc/net/arp";
+
+    /**
+     * rarp
+     * arpIP
+     * 
+     * @param netIf
+     * @return IP / null
+     */
+    public String execRarp(String netIf) {
+        ArrayList<String> lines = readFile(ARP_PATH);
+        if (lines == null || lines.size() == 0) {
+            Log.w(TAG, "execRarp() readFile("+ARP_PATH+") returns 0");
+            return null;
+        }
+
+        int i = 0;
+        for (String line : lines) {
+            Log.d(TAG, "execRarp() [" + (i++) + "]" + line);
+        }
+
+        ArrayList<ArpType> arps = parseArp(lines);
+        if (arps == null || arps.size() == 0) {
+            Log.w(TAG, "execRarp() parseArp("+lines+") returns 0");
+            return null;
+        }
+
+        ArpType arp = searchArp(arps, netIf);
+        if (arp == null) {
+            Log.w(TAG, "execRarp() searchArp() "+netIf+" Not Found!");
+            return null;
+        }
+
+        return arp.mIPaddress;
+    }
+
+    /**
+     * Arp
+     */
+    public ArrayList<ArpType> getArpTable() {
+        ArrayList<String> lines = readFile(ARP_PATH);
+        if (lines == null || lines.size() == 0) {
+            Log.w(TAG, "getArpTable() readFile("+ARP_PATH+") returns 0");
+            return null;
+        }
+
+        int i = 0;
+        for (String line : lines) {
+            Log.d(TAG, "getArpTable() [" + (i++) + "]" + line);
+        }
+
+        ArrayList<ArpType> arps = parseArp(lines);
+        if (arps == null || arps.size() == 0) {
+            Log.w(TAG, "getArpTable() parseArp("+lines+") returns 0");
+            return null;
+        }
+        return arps;
+    }
+
+    /**
+     * 
+     * 
+     * @param path
+     * @return null  / 
+     */
+    private ArrayList<String> readFile(String path) {
+        try {
+            BufferedReader br = new BufferedReader(new InputStreamReader(new FileInputStream(new File(path)), "UTF-8"), 128);
+            ArrayList<String> lines = new ArrayList<String>();
+            String line;
+            while ((line = br.readLine()) != null) {
+                lines.add(line);
+            }
+            br.close();
+            return lines;
+        } catch(FileNotFoundException e) {
+            Log.e(TAG, "readFile() " + e);
+        } catch(UnsupportedEncodingException e) {
+            Log.e(TAG, "readFile() " + e);
+        } catch (IOException e) {
+            Log.e(TAG, "readFile() " + e);
+        }
+        return null;
+    }
+
+    /**
+     * /proc/net/arp 
+     */
+    private ArrayList<ArpType> parseArp(ArrayList<String> arpLines) {
+        if (arpLines == null || arpLines.size() == 1) {
+            return null;
+        }
+
+        ArrayList<ArpType> arps = new ArrayList<ArpType>();
+        for (String line : arpLines) {
+            ArpType arp = parseArpLine(line);
+            if (arp == null) {
+                continue;
+            }
+            arps.add(arp);
+        }
+        return arps;
+    }
+
+    /**
+     * arp 1
+     */
+    private ArpType parseArpLine(String line) {
+        if (line == null) {
+            Log.e(TAG, "parseArpLine() line is null!");
+            return null;
+        }
+
+        String[] seps = line.split(" +"); // 
+        // 
+        if (seps == null || seps.length == 0) {
+            Log.e(TAG, "parseArpLine() split error!"+line+"]");
+            return null;
+        }
+
+        int len = seps.length;
+        // arp
+        if (len == 6) {
+            ArpType arp = new ArpType(seps[0], seps[1], seps[2], seps[3], seps[4], seps[5]);
+            Log.d(TAG, "parseArpLine() created arp["+arp.toString()+"]");
+            return arp;
+        } else {
+            // 
+            if (seps.length == 9 && seps[0].equals("IP") && seps[8].equals("Device")) {
+                Log.i(TAG, "parseArpLine() this is header line. don't create arp["+line+"]");
+            } else {
+                StringBuffer buf = new StringBuffer();
+                for (int i = 0; i < seps.length; i++) {
+                    buf.append(String.format("[%02d](%s)", i, seps[i]));
+                }
+                Log.e(TAG, "parseArpLine() Unknown Line! Seps["+buf.toString()+"]");
+            }
+            return null;
+        }
+    }
+
+    /**
+     * 
+     */
+    private ArpType searchArp(ArrayList<ArpType> arps, String netIf) {
+        if (arps == null || arps.size() == 0 || netIf == null) {
+            return null;
+        }
+
+        ArpType lastarp = null;
+        for (ArpType arp : arps) {
+            //if (arp.mHWaddress.equals(macAddress)) {
+            //    return arp;
+            //}
+            if (arp.mDevice.equals(netIf)) {
+                if (!arp.mHWaddress.equals("00:00:00:00:00:00")) {
+                    return arp;
+                }
+            }
+            lastarp = arp;
+        }
+
+        if (lastarp != null) {
+            //return lastarp;
+        }
+        return null;
+    }
+
+    /**
+     * arp
+     */
+    public class ArpType {
+
+        public String mIPaddress;
+        String mHWType;
+        String mFlags;
+        String mHWaddress;
+        String mMask;
+        String mDevice;
+
+        ArpType() {
+        }
+
+        ArpType(String ipaddress, String hwtype, String flags, String hwaddress, String mask, String device) {
+            mIPaddress = ipaddress;
+            mHWType = hwtype;
+            mFlags = flags;
+            mHWaddress = hwaddress;
+            mMask = mask;
+            mDevice = device;
+        }
+
+        public String toString() {
+            String ret = 
+                " IP address:" + mIPaddress + "n" +
+                " HW type:" + mHWType + "n" +
+                " Flags:" + mFlags + "n" +
+                " HW address:" + mHWaddress + "n" +
+                " Mask:" + mMask + "n" +
+                " Device:" + mDevice;
+            return ret;
+        }
+    }
+
+}
diff -Naur a/packages/apps/Mira4U/src/com/example/mira4u/SettingsActivity.java b/packages/apps/Mira4U/src/com/example/mira4u/SettingsActivity.java
--- a/packages/apps/Mira4U/src/com/example/mira4u/SettingsActivity.java	1969-12-31 19:00:00.000000000 -0500
+++ b/packages/apps/Mira4U/src/com/example/mira4u/SettingsActivity.java	2013-08-14 04:13:30.000000000 -0400
@@ -0,0 +1,35 @@
+package com.example.mira4u;
+
+import android.os.Bundle;
+import android.os.SystemProperties;
+import android.preference.CheckBoxPreference;
+import android.preference.Preference;
+import android.preference.PreferenceActivity;
+import android.preference.PreferenceScreen;
+import android.widget.Toast;
+import android.util.Log;
+
+public class SettingsActivity extends PreferenceActivity {
+
+    @Override
+    @Deprecated
+    public void onCreate(Bundle savedInstanceState) {
+        super.onCreate(savedInstanceState);
+        addPreferencesFromResource(R.xml.pref);
+    }
+
+    @Override
+    @Deprecated
+    public boolean onPreferenceTreeClick(PreferenceScreen preferenceScreen, Preference preference) {
+        String key = preference.getKey();
+
+        CheckBoxPreference cbp = (CheckBoxPreference)preference;
+        boolean chk = cbp.isChecked();
+
+        SystemProperties.set(key, chk ? "1" : "0");
+        Log.d("SettingsActivity", "onPreferenceTreeClick() key["+key+"]["+SystemProperties.get(key, "0")+"]");
+
+        return super.onPreferenceTreeClick(preferenceScreen, preference);
+    }
+
+}
diff -Naur a/packages/apps/Settings/src/com/android/settings/wfd/WifiDisplaySettings.java b/packages/apps/Settings/src/com/android/settings/wfd/WifiDisplaySettings.java
--- a/packages/apps/Settings/src/com/android/settings/wfd/WifiDisplaySettings.java	2014-03-23 23:21:18.111597000 -0400
+++ b/packages/apps/Settings/src/com/android/settings/wfd/WifiDisplaySettings.java	2013-08-14 04:13:30.000000000 -0400
@@ -19,7 +19,6 @@
 import android.app.ActionBar;
 import android.app.Activity;
 import android.app.AlertDialog;
-import android.app.Service;
 import android.content.BroadcastReceiver;
 import android.content.Context;
 import android.content.DialogInterface;
@@ -29,18 +28,9 @@
 import android.hardware.display.DisplayManager;
 import android.hardware.display.WifiDisplay;
 import android.hardware.display.WifiDisplayStatus;
-import android.media.MediaRouter;
-import android.media.MediaRouter.RouteInfo;
 import android.net.Uri;
-import android.net.wifi.p2p.WifiP2pManager;
-import android.net.wifi.p2p.WifiP2pManager.ActionListener;
-import android.net.wifi.p2p.WifiP2pManager.Channel;
-import android.net.wifi.WpsInfo;
 import android.os.Bundle;
 import android.os.Handler;
-import android.os.Looper;
-import android.preference.CheckBoxPreference;
-import android.preference.ListPreference;
 import android.preference.Preference;
 import android.preference.PreferenceActivity;
 import android.preference.PreferenceCategory;
@@ -48,522 +38,284 @@
 import android.preference.PreferenceScreen;
 import android.provider.Settings;
 import android.text.Html;
-import android.util.Slog;
 import android.util.TypedValue;
 import android.view.Gravity;
-import android.view.LayoutInflater;
 import android.view.Menu;
 import android.view.MenuInflater;
 import android.view.MenuItem;
 import android.view.View;
-import android.view.View.OnClickListener;
-import android.view.ViewGroup;
-import android.widget.Button;
 import android.widget.CompoundButton;
 import android.widget.EditText;
 import android.widget.ImageView;
 import android.widget.Switch;
 import android.widget.TextView;
 
-import com.android.internal.app.MediaRouteDialogPresenter;
 import com.android.settings.ProgressCategory;
 import com.android.settings.R;
 import com.android.settings.SettingsPreferenceFragment;
 
 /**
  * The Settings screen for WifiDisplay configuration and connection management.
- *
- * The wifi display routes are integrated together with other remote display routes
- * from the media router.  It may happen that wifi display isn't actually available
- * on the system.  In that case, the enable option will not be shown but other
- * remote display routes will continue to be made available.
  */
 public final class WifiDisplaySettings extends SettingsPreferenceFragment {
     private static final String TAG = "WifiDisplaySettings";
-    private static final boolean DEBUG = false;
 
-    private static final int MENU_ID_ENABLE_WIFI_DISPLAY = Menu.FIRST;
+    private static final int MENU_ID_SCAN = Menu.FIRST;
 
-    private static final int CHANGE_SETTINGS = 1 << 0;
-    private static final int CHANGE_ROUTES = 1 << 1;
-    private static final int CHANGE_WIFI_DISPLAY_STATUS = 1 << 2;
-    private static final int CHANGE_ALL = -1;
-
-    private static final int ORDER_CERTIFICATION = 1;
-    private static final int ORDER_CONNECTED = 2;
-    private static final int ORDER_AVAILABLE = 3;
-    private static final int ORDER_UNAVAILABLE = 4;
-
-    private final Handler mHandler;
-
-    private MediaRouter mRouter;
     private DisplayManager mDisplayManager;
 
-    private boolean mStarted;
-    private int mPendingChanges;
-
     private boolean mWifiDisplayOnSetting;
     private WifiDisplayStatus mWifiDisplayStatus;
 
+    private PreferenceGroup mPairedDevicesCategory;
+    private ProgressCategory mAvailableDevicesCategory;
+
     private TextView mEmptyView;
 
-    /* certification */
-    private boolean mWifiDisplayCertificationOn;
-    private WifiP2pManager mWifiP2pManager;
-    private Channel mWifiP2pChannel;
-    private PreferenceGroup mCertCategory;
-    private boolean mListen;
-    private boolean mAutoGO;
-    private int mWpsConfig = WpsInfo.INVALID;
-    private int mListenChannel;
-    private int mOperatingChannel;
+    private Switch mActionBarSwitch;
 
     public WifiDisplaySettings() {
-        mHandler = new Handler();
     }
 
     @Override
     public void onCreate(Bundle icicle) {
         super.onCreate(icicle);
 
-        final Context context = getActivity();
-        mRouter = (MediaRouter)context.getSystemService(Context.MEDIA_ROUTER_SERVICE);
-        mDisplayManager = (DisplayManager)context.getSystemService(Context.DISPLAY_SERVICE);
-        mWifiP2pManager = (WifiP2pManager)context.getSystemService(Context.WIFI_P2P_SERVICE);
-        mWifiP2pChannel = mWifiP2pManager.initialize(context, Looper.getMainLooper(), null);
+        mDisplayManager = (DisplayManager)getActivity().getSystemService(Context.DISPLAY_SERVICE);
 
         addPreferencesFromResource(R.xml.wifi_display_settings);
         setHasOptionsMenu(true);
     }
 
     @Override
-    protected int getHelpResource() {
-        return R.string.help_url_remote_display;
-    }
-
-    @Override
     public void onActivityCreated(Bundle savedInstanceState) {
         super.onActivityCreated(savedInstanceState);
 
+        Activity activity = getActivity();
+        mActionBarSwitch = new Switch(activity);
+        if (activity instanceof PreferenceActivity) {
+            PreferenceActivity preferenceActivity = (PreferenceActivity) activity;
+//            if (preferenceActivity.onIsHidingHeaders() || !preferenceActivity.onIsMultiPane()) {
+                final int padding = activity.getResources().getDimensionPixelSize(
+                        R.dimen.action_bar_switch_padding);
+                mActionBarSwitch.setPadding(0, 0, padding, 0);
+                activity.getActionBar().setDisplayOptions(ActionBar.DISPLAY_SHOW_CUSTOM,
+                        ActionBar.DISPLAY_SHOW_CUSTOM);
+                activity.getActionBar().setCustomView(mActionBarSwitch,
+                        new ActionBar.LayoutParams(
+                                ActionBar.LayoutParams.WRAP_CONTENT,
+                                ActionBar.LayoutParams.WRAP_CONTENT,
+                                Gravity.CENTER_VERTICAL | Gravity.END));
+//            }
+        }
+
+        mActionBarSwitch.setOnCheckedChangeListener(mSwitchOnCheckedChangedListener);
+
         mEmptyView = (TextView) getView().findViewById(android.R.id.empty);
-        mEmptyView.setText(R.string.wifi_display_no_devices_found);
         getListView().setEmptyView(mEmptyView);
+
+        update();
+
+        if (mWifiDisplayStatus.getFeatureState() == WifiDisplayStatus.FEATURE_STATE_UNAVAILABLE) {
+            activity.finish();
+        }
     }
 
     @Override
-    public void onStart() {
-        super.onStart();
-        mStarted = true;
+    public void onResume() {
+        super.onResume();
 
-        final Context context = getActivity();
+        Context context = getActivity();
         IntentFilter filter = new IntentFilter();
         filter.addAction(DisplayManager.ACTION_WIFI_DISPLAY_STATUS_CHANGED);
         context.registerReceiver(mReceiver, filter);
 
-        getContentResolver().registerContentObserver(Settings.Global.getUriFor(
+        getContentResolver().registerContentObserver(Settings.Secure.getUriFor(
                 Settings.Global.WIFI_DISPLAY_ON), false, mSettingsObserver);
-        getContentResolver().registerContentObserver(Settings.Global.getUriFor(
-                Settings.Global.WIFI_DISPLAY_CERTIFICATION_ON), false, mSettingsObserver);
-        getContentResolver().registerContentObserver(Settings.Global.getUriFor(
-                Settings.Global.WIFI_DISPLAY_WPS_CONFIG), false, mSettingsObserver);
 
-        mRouter.addCallback(MediaRouter.ROUTE_TYPE_REMOTE_DISPLAY, mRouterCallback,
-                MediaRouter.CALLBACK_FLAG_PERFORM_ACTIVE_SCAN);
+        mDisplayManager.scanWifiDisplays();
 
-        update(CHANGE_ALL);
+        update();
     }
 
     @Override
-    public void onStop() {
-        super.onStop();
-        mStarted = false;
+    public void onPause() {
+        super.onPause();
 
-        final Context context = getActivity();
+        Context context = getActivity();
         context.unregisterReceiver(mReceiver);
 
         getContentResolver().unregisterContentObserver(mSettingsObserver);
+    }
 
-        mRouter.removeCallback(mRouterCallback);
-
-        unscheduleUpdate();
+    @Override
+    public void onDestroyView() {
+        Activity activity = getActivity();
+        if (activity instanceof PreferenceActivity) {
+            activity.getActionBar().setCustomView(null);
+        }
+        super.onDestroyView();
     }
 
     @Override
     public void onCreateOptionsMenu(Menu menu, MenuInflater inflater) {
-        if (mWifiDisplayStatus != null && mWifiDisplayStatus.getFeatureState()
-                != WifiDisplayStatus.FEATURE_STATE_UNAVAILABLE) {
-            MenuItem item = menu.add(Menu.NONE, MENU_ID_ENABLE_WIFI_DISPLAY, 0,
-                    R.string.wifi_display_enable_menu_item);
-            item.setCheckable(true);
-            item.setChecked(mWifiDisplayOnSetting);
-        }
+        MenuItem item = menu.add(Menu.NONE, MENU_ID_SCAN, 0,
+                mWifiDisplayStatus.getScanState() == WifiDisplayStatus.SCAN_STATE_SCANNING ?
+                        R.string.wifi_display_searching_for_devices :
+                                R.string.wifi_display_search_for_devices);
+        item.setEnabled(mWifiDisplayStatus.getFeatureState() == WifiDisplayStatus.FEATURE_STATE_ON
+                && mWifiDisplayStatus.getScanState() == WifiDisplayStatus.SCAN_STATE_NOT_SCANNING);
+        item.setShowAsAction(MenuItem.SHOW_AS_ACTION_IF_ROOM);
+
+        //String prod = android.os.Build.PRODUCT.toUpperCase();
+        //boolean manta = prod.indexOf("MANTA") != -1; // only Nexus 10
+        //if (manta) {
+        //    item = menu.add(Menu.NONE, MENU_ID_SCAN+1, 0, "On/Off ");
+        //    item.setEnabled(true);
+        //    item.setShowAsAction(MenuItem.SHOW_AS_ACTION_ALWAYS);
+        //}
+
         super.onCreateOptionsMenu(menu, inflater);
     }
 
     @Override
     public boolean onOptionsItemSelected(MenuItem item) {
         switch (item.getItemId()) {
-            case MENU_ID_ENABLE_WIFI_DISPLAY:
-                mWifiDisplayOnSetting = !item.isChecked();
-                item.setChecked(mWifiDisplayOnSetting);
-                Settings.Global.putInt(getContentResolver(),
-                        Settings.Global.WIFI_DISPLAY_ON, mWifiDisplayOnSetting ? 1 : 0);
+            case MENU_ID_SCAN:
+                if (mWifiDisplayStatus.getFeatureState() == WifiDisplayStatus.FEATURE_STATE_ON) {
+                    mDisplayManager.scanWifiDisplays();
+                }
                 return true;
+            //case MENU_ID_SCAN+1:
+            //    mSwitchOnCheckedChangedListener.onCheckedChanged(null, !mWifiDisplayOnSetting);
+            //    return true;
         }
         return super.onOptionsItemSelected(item);
     }
 
-    private void scheduleUpdate(int changes) {
-        if (mStarted) {
-            if (mPendingChanges == 0) {
-                mHandler.post(mUpdateRunnable);
+    @Override
+    public boolean onPreferenceTreeClick(PreferenceScreen preferenceScreen,
+            Preference preference) {
+        if (preference instanceof WifiDisplayPreference) {
+            WifiDisplayPreference p = (WifiDisplayPreference)preference;
+            WifiDisplay display = p.getDisplay();
+
+            if (display.equals(mWifiDisplayStatus.getActiveDisplay())) {
+                showDisconnectDialog(display);
+            } else {
+                mDisplayManager.connectWifiDisplay(display.getDeviceAddress());
             }
-            mPendingChanges |= changes;
         }
-    }
 
-    private void unscheduleUpdate() {
-        if (mPendingChanges != 0) {
-            mPendingChanges = 0;
-            mHandler.removeCallbacks(mUpdateRunnable);
-        }
+        return super.onPreferenceTreeClick(preferenceScreen, preference);
     }
 
-    private void update(int changes) {
-        boolean invalidateOptions = false;
-
-        // Update settings.
-        if ((changes & CHANGE_SETTINGS) != 0) {
-            mWifiDisplayOnSetting = Settings.Global.getInt(getContentResolver(),
-                    Settings.Global.WIFI_DISPLAY_ON, 0) != 0;
-            mWifiDisplayCertificationOn = Settings.Global.getInt(getContentResolver(),
-                    Settings.Global.WIFI_DISPLAY_CERTIFICATION_ON, 0) != 0;
-            mWpsConfig = Settings.Global.getInt(getContentResolver(),
-                Settings.Global.WIFI_DISPLAY_WPS_CONFIG, WpsInfo.INVALID);
+    private void update() {
+        mWifiDisplayOnSetting = Settings.Global.getInt(getContentResolver(),
+                Settings.Global.WIFI_DISPLAY_ON, 0) != 0;
+        mWifiDisplayStatus = mDisplayManager.getWifiDisplayStatus();
 
-            // The wifi display enabled setting may have changed.
-            invalidateOptions = true;
-        }
+        applyState();
+    }
 
-        // Update wifi display state.
-        if ((changes & CHANGE_WIFI_DISPLAY_STATUS) != 0) {
-            mWifiDisplayStatus = mDisplayManager.getWifiDisplayStatus();
+    private void applyState() {
+        final int featureState = mWifiDisplayStatus.getFeatureState();
+        mActionBarSwitch.setEnabled(featureState != WifiDisplayStatus.FEATURE_STATE_DISABLED);
+        mActionBarSwitch.setChecked(mWifiDisplayOnSetting);
 
-            // The wifi display feature state may have changed.
-            invalidateOptions = true;
-        }
-
-        // Rebuild the routes.
         final PreferenceScreen preferenceScreen = getPreferenceScreen();
         preferenceScreen.removeAll();
 
-        // Add all known remote display routes.
-        final int routeCount = mRouter.getRouteCount();
-        for (int i = 0; i < routeCount; i++) {
-            MediaRouter.RouteInfo route = mRouter.getRouteAt(i);
-            if (route.matchesTypes(MediaRouter.ROUTE_TYPE_REMOTE_DISPLAY)) {
-                preferenceScreen.addPreference(createRoutePreference(route));
-            }
-        }
-
-        // Additional features for wifi display routes.
-        if (mWifiDisplayStatus != null
-                && mWifiDisplayStatus.getFeatureState() == WifiDisplayStatus.FEATURE_STATE_ON) {
-            // Add all unpaired wifi displays.
-            for (WifiDisplay display : mWifiDisplayStatus.getDisplays()) {
-                if (!display.isRemembered() && display.isAvailable()
-                        && !display.equals(mWifiDisplayStatus.getActiveDisplay())) {
-                    preferenceScreen.addPreference(new UnpairedWifiDisplayPreference(
-                            getActivity(), display));
-                }
-            }
-
-            // Add the certification menu if enabled in developer options.
-            if (mWifiDisplayCertificationOn) {
-                buildCertificationMenu(preferenceScreen);
-            }
-        }
-
-        // Invalidate menu options if needed.
-        if (invalidateOptions) {
-            getActivity().invalidateOptionsMenu();
-        }
-    }
-
-    private RoutePreference createRoutePreference(MediaRouter.RouteInfo route) {
-        WifiDisplay display = findWifiDisplay(route.getDeviceAddress());
-        if (display != null) {
-            return new WifiDisplayRoutePreference(getActivity(), route, display);
-        } else {
-            return new RoutePreference(getActivity(), route);
-        }
-    }
-
-    private WifiDisplay findWifiDisplay(String deviceAddress) {
-        if (mWifiDisplayStatus != null && deviceAddress != null) {
-            for (WifiDisplay display : mWifiDisplayStatus.getDisplays()) {
-                if (display.getDeviceAddress().equals(deviceAddress)) {
-                    return display;
-                }
-            }
-        }
-        return null;
-    }
-
-    private void buildCertificationMenu(final PreferenceScreen preferenceScreen) {
-        if (mCertCategory == null) {
-            mCertCategory = new PreferenceCategory(getActivity());
-            mCertCategory.setTitle(R.string.wifi_display_certification_heading);
-            mCertCategory.setOrder(ORDER_CERTIFICATION);
-        } else {
-            mCertCategory.removeAll();
-        }
-        preferenceScreen.addPreference(mCertCategory);
-
-        // display session info if there is an active p2p session
-        if (!mWifiDisplayStatus.getSessionInfo().getGroupId().isEmpty()) {
-            Preference p = new Preference(getActivity());
-            p.setTitle(R.string.wifi_display_session_info);
-            p.setSummary(mWifiDisplayStatus.getSessionInfo().toString());
-            mCertCategory.addPreference(p);
-
-            // show buttons for Pause/Resume when a WFD session is established
-            if (mWifiDisplayStatus.getSessionInfo().getSessionId() != 0) {
-                mCertCategory.addPreference(new Preference(getActivity()) {
-                    @Override
-                    public View getView(View convertView, ViewGroup parent) {
-                        final View v;
-                        if (convertView == null) {
-                            LayoutInflater li = (LayoutInflater) getActivity().
-                                    getSystemService(Service.LAYOUT_INFLATER_SERVICE);
-                            v = li.inflate(R.layout.two_buttons_panel, null);
-                        } else {
-                            v = convertView;
-                        }
-
-                        Button b = (Button)v.findViewById(R.id.left_button);
-                        b.setText(R.string.wifi_display_pause);
-                        b.setOnClickListener(new OnClickListener() {
-                            @Override
-                            public void onClick(View v) {
-                                mDisplayManager.pauseWifiDisplay();
-                            }
-                        });
-
-                        b = (Button)v.findViewById(R.id.right_button);
-                        b.setText(R.string.wifi_display_resume);
-                        b.setOnClickListener(new OnClickListener() {
-                            @Override
-                            public void onClick(View v) {
-                                mDisplayManager.resumeWifiDisplay();
-                            }
-                        });
-
-                        return v;
-                    }
-                });
+        if (featureState == WifiDisplayStatus.FEATURE_STATE_ON) {
+            final WifiDisplay[] pairedDisplays = mWifiDisplayStatus.getRememberedDisplays();
+            final WifiDisplay[] availableDisplays = mWifiDisplayStatus.getAvailableDisplays();
+
+            if (mPairedDevicesCategory == null) {
+                mPairedDevicesCategory = new PreferenceCategory(getActivity());
+                mPairedDevicesCategory.setTitle(R.string.wifi_display_paired_devices);
+            } else {
+                mPairedDevicesCategory.removeAll();
             }
-        }
+            preferenceScreen.addPreference(mPairedDevicesCategory);
 
-        // switch for Listen Mode
-        CheckBoxPreference cbp = new CheckBoxPreference(getActivity()) {
-            @Override
-            protected void onClick() {
-                mListen = !mListen;
-                setListenMode(mListen);
-                setChecked(mListen);
+            for (WifiDisplay d : pairedDisplays) {
+                mPairedDevicesCategory.addPreference(createWifiDisplayPreference(d, true));
             }
-        };
-        cbp.setTitle(R.string.wifi_display_listen_mode);
-        cbp.setChecked(mListen);
-        mCertCategory.addPreference(cbp);
-
-        // switch for Autonomous GO
-        cbp = new CheckBoxPreference(getActivity()) {
-            @Override
-            protected void onClick() {
-                mAutoGO = !mAutoGO;
-                if (mAutoGO) {
-                    startAutoGO();
-                } else {
-                    stopAutoGO();
-                }
-                setChecked(mAutoGO);
+            if (mPairedDevicesCategory.getPreferenceCount() == 0) {
+                preferenceScreen.removePreference(mPairedDevicesCategory);
             }
-        };
-        cbp.setTitle(R.string.wifi_display_autonomous_go);
-        cbp.setChecked(mAutoGO);
-        mCertCategory.addPreference(cbp);
 
-        // Drop down list for choosing WPS method (PBC/KEYPAD/DISPLAY)
-        ListPreference lp = new ListPreference(getActivity()) {
-            @Override
-            protected void onDialogClosed(boolean positiveResult) {
-                super.onDialogClosed(positiveResult);
-                if (positiveResult) {
-                    mWpsConfig = Integer.parseInt(getValue());
-                    setSummary("%1$s");
-                    getActivity().invalidateOptionsMenu();
-                    Settings.Global.putInt(getActivity().getContentResolver(),
-                            Settings.Global.WIFI_DISPLAY_WPS_CONFIG, mWpsConfig);
-                }
+            if (mAvailableDevicesCategory == null) {
+                mAvailableDevicesCategory = new ProgressCategory(getActivity(), null,
+                        R.string.wifi_display_no_devices_found);
+                mAvailableDevicesCategory.setTitle(R.string.wifi_display_available_devices);
+            } else {
+                mAvailableDevicesCategory.removeAll();
             }
-        };
-        mWpsConfig = Settings.Global.getInt(getActivity().getContentResolver(),
-                Settings.Global.WIFI_DISPLAY_WPS_CONFIG, WpsInfo.INVALID);
-        String[] wpsEntries = { "Default", "PBC", "KEYPAD", "DISPLAY" };
-        String[] wpsValues = {
-            "" + WpsInfo.INVALID,
-            "" + WpsInfo.PBC,
-            "" + WpsInfo.KEYPAD,
-            "" + WpsInfo.DISPLAY };
-        lp.setTitle(R.string.wifi_display_wps_config);
-        lp.setEntries(wpsEntries);
-        lp.setEntryValues(wpsValues);
-        lp.setValue("" + mWpsConfig);
-        lp.setSummary("%1$s");
-        mCertCategory.addPreference(lp);
+            preferenceScreen.addPreference(mAvailableDevicesCategory);
 
-        // Drop down list for choosing listen channel
-        lp = new ListPreference(getActivity()) {
-            @Override
-            protected void onDialogClosed(boolean positiveResult) {
-                super.onDialogClosed(positiveResult);
-                if (positiveResult) {
-                    mListenChannel = Integer.parseInt(getValue());
-                    setSummary("%1$s");
-                    getActivity().invalidateOptionsMenu();
-                    setWifiP2pChannels(mListenChannel, mOperatingChannel);
+            for (WifiDisplay d : availableDisplays) {
+                if (!contains(pairedDisplays, d.getDeviceAddress())) {
+                    mAvailableDevicesCategory.addPreference(createWifiDisplayPreference(d, false));
                 }
             }
-        };
-        String[] lcEntries = { "Auto", "1", "6", "11" };
-        String[] lcValues = { "0", "1", "6", "11" };
-        lp.setTitle(R.string.wifi_display_listen_channel);
-        lp.setEntries(lcEntries);
-        lp.setEntryValues(lcValues);
-        lp.setValue("" + mListenChannel);
-        lp.setSummary("%1$s");
-        mCertCategory.addPreference(lp);
-
-        // Drop down list for choosing operating channel
-        lp = new ListPreference(getActivity()) {
-            @Override
-            protected void onDialogClosed(boolean positiveResult) {
-                super.onDialogClosed(positiveResult);
-                if (positiveResult) {
-                    mOperatingChannel = Integer.parseInt(getValue());
-                    setSummary("%1$s");
-                    getActivity().invalidateOptionsMenu();
-                    setWifiP2pChannels(mListenChannel, mOperatingChannel);
-                }
+            if (mWifiDisplayStatus.getScanState() == WifiDisplayStatus.SCAN_STATE_SCANNING) {
+                mAvailableDevicesCategory.setProgress(true);
+            } else {
+                mAvailableDevicesCategory.setProgress(false);
             }
-        };
-        String[] ocEntries = { "Auto", "1", "6", "11", "36" };
-        String[] ocValues = { "0", "1", "6", "11", "36" };
-        lp.setTitle(R.string.wifi_display_operating_channel);
-        lp.setEntries(ocEntries);
-        lp.setEntryValues(ocValues);
-        lp.setValue("" + mOperatingChannel);
-        lp.setSummary("%1$s");
-        mCertCategory.addPreference(lp);
-    }
-
-    private void startAutoGO() {
-        if (DEBUG) {
-            Slog.d(TAG, "Starting Autonomous GO...");
+        } else {
+            mEmptyView.setText(featureState == WifiDisplayStatus.FEATURE_STATE_OFF ?
+                    R.string.wifi_display_settings_empty_list_wifi_display_off :
+                            R.string.wifi_display_settings_empty_list_wifi_display_disabled);
         }
-        mWifiP2pManager.createGroup(mWifiP2pChannel, new ActionListener() {
-            @Override
-            public void onSuccess() {
-                if (DEBUG) {
-                    Slog.d(TAG, "Successfully started AutoGO.");
-                }
-            }
 
-            @Override
-            public void onFailure(int reason) {
-                Slog.e(TAG, "Failed to start AutoGO with reason " + reason + ".");
-            }
-        });
+        getActivity().invalidateOptionsMenu();
     }
 
-    private void stopAutoGO() {
-        if (DEBUG) {
-            Slog.d(TAG, "Stopping Autonomous GO...");
-        }
-        mWifiP2pManager.removeGroup(mWifiP2pChannel, new ActionListener() {
-            @Override
-            public void onSuccess() {
-                if (DEBUG) {
-                    Slog.d(TAG, "Successfully stopped AutoGO.");
-                }
-            }
-
-            @Override
-            public void onFailure(int reason) {
-                Slog.e(TAG, "Failed to stop AutoGO with reason " + reason + ".");
+    private Preference createWifiDisplayPreference(final WifiDisplay d, boolean paired) {
+        WifiDisplayPreference p = new WifiDisplayPreference(getActivity(), d);
+        if (d.equals(mWifiDisplayStatus.getActiveDisplay())) {
+            switch (mWifiDisplayStatus.getActiveDisplayState()) {
+                case WifiDisplayStatus.DISPLAY_STATE_CONNECTED:
+                    p.setSummary(R.string.wifi_display_status_connected);
+                    break;
+                case WifiDisplayStatus.DISPLAY_STATE_CONNECTING:
+                    p.setSummary(R.string.wifi_display_status_connecting);
+                    break;
             }
-        });
-    }
-
-    private void setListenMode(final boolean enable) {
-        if (DEBUG) {
-            Slog.d(TAG, "Setting listen mode to: " + enable);
+        } else if (paired && contains(mWifiDisplayStatus.getAvailableDisplays(),
+                d.getDeviceAddress())) {
+            p.setSummary(R.string.wifi_display_status_available);
         }
-        mWifiP2pManager.listen(mWifiP2pChannel, enable, new ActionListener() {
-            @Override
-            public void onSuccess() {
-                if (DEBUG) {
-                    Slog.d(TAG, "Successfully " + (enable ? "entered" : "exited")
-                            +" listen mode.");
-                }
-            }
-
-            @Override
-            public void onFailure(int reason) {
-                Slog.e(TAG, "Failed to " + (enable ? "entered" : "exited")
-                        +" listen mode with reason " + reason + ".");
-            }
-        });
+        if (paired) {
+            p.setWidgetLayoutResource(R.layout.wifi_display_preference);
+        }
+        return p;
     }
 
-    private void setWifiP2pChannels(final int lc, final int oc) {
-        if (DEBUG) {
-            Slog.d(TAG, "Setting wifi p2p channel: lc=" + lc + ", oc=" + oc);
-        }
-        mWifiP2pManager.setWifiP2pChannels(mWifiP2pChannel,
-                lc, oc, new ActionListener() {
+    private void showDisconnectDialog(final WifiDisplay display) {
+        DialogInterface.OnClickListener ok = new DialogInterface.OnClickListener() {
             @Override
-            public void onSuccess() {
-                if (DEBUG) {
-                    Slog.d(TAG, "Successfully set wifi p2p channels.");
+            public void onClick(DialogInterface dialog, int which) {
+                if (display.equals(mWifiDisplayStatus.getActiveDisplay())) {
+                    mDisplayManager.disconnectWifiDisplay();
                 }
             }
+        };
 
-            @Override
-            public void onFailure(int reason) {
-                Slog.e(TAG, "Failed to set wifi p2p channels with reason " + reason + ".");
-            }
-        });
-    }
-
-    private void toggleRoute(MediaRouter.RouteInfo route) {
-        if (route.isSelected()) {
-            MediaRouteDialogPresenter.showDialogFragment(getActivity(),
-                    MediaRouter.ROUTE_TYPE_REMOTE_DISPLAY, null);
-        } else {
-            route.select();
-        }
-    }
-
-    private void pairWifiDisplay(WifiDisplay display) {
-        if (display.canConnect()) {
-            mDisplayManager.connectWifiDisplay(display.getDeviceAddress());
-        }
+        AlertDialog dialog = new AlertDialog.Builder(getActivity())
+                .setCancelable(true)
+                .setTitle(R.string.wifi_display_disconnect_title)
+                .setMessage(Html.fromHtml(getResources().getString(
+                        R.string.wifi_display_disconnect_text, display.getFriendlyDisplayName())))
+                .setPositiveButton(android.R.string.ok, ok)
+                .setNegativeButton(android.R.string.cancel, null)
+                .create();
+        dialog.show();
     }
 
-    private void showWifiDisplayOptionsDialog(final WifiDisplay display) {
+    private void showOptionsDialog(final WifiDisplay display) {
         View view = getActivity().getLayoutInflater().inflate(R.layout.wifi_display_options, null);
         final EditText nameEditText = (EditText)view.findViewById(R.id.name);
         nameEditText.setText(display.getFriendlyDisplayName());
@@ -595,12 +347,22 @@
         dialog.show();
     }
 
-    private final Runnable mUpdateRunnable = new Runnable() {
+    private static boolean contains(WifiDisplay[] displays, String address) {
+        for (WifiDisplay d : displays) {
+            if (d.getDeviceAddress().equals(address)) {
+                return true;
+            }
+        }
+        return false;
+    }
+
+    private final CompoundButton.OnCheckedChangeListener mSwitchOnCheckedChangedListener =
+            new CompoundButton.OnCheckedChangeListener() {
         @Override
-        public void run() {
-            final int changes = mPendingChanges;
-            mPendingChanges = 0;
-            update(changes);
+        public void onCheckedChanged(CompoundButton buttonView, boolean isChecked) {
+            mWifiDisplayOnSetting = isChecked;
+            Settings.Global.putInt(getContentResolver(),
+                    Settings.Global.WIFI_DISPLAY_ON, isChecked ? 1 : 0);
         }
     };
 
@@ -609,7 +371,10 @@
         public void onReceive(Context context, Intent intent) {
             String action = intent.getAction();
             if (action.equals(DisplayManager.ACTION_WIFI_DISPLAY_STATUS_CHANGED)) {
-                scheduleUpdate(CHANGE_WIFI_DISPLAY_STATUS);
+                WifiDisplayStatus status = (WifiDisplayStatus)intent.getParcelableExtra(
+                        DisplayManager.EXTRA_WIFI_DISPLAY_STATUS);
+                mWifiDisplayStatus = status;
+                applyState();
             }
         }
     };
@@ -617,87 +382,23 @@
     private final ContentObserver mSettingsObserver = new ContentObserver(new Handler()) {
         @Override
         public void onChange(boolean selfChange, Uri uri) {
-            scheduleUpdate(CHANGE_SETTINGS);
+            update();
         }
     };
 
-    private final MediaRouter.Callback mRouterCallback = new MediaRouter.SimpleCallback() {
-        @Override
-        public void onRouteAdded(MediaRouter router, RouteInfo info) {
-            scheduleUpdate(CHANGE_ROUTES);
-        }
-
-        @Override
-        public void onRouteChanged(MediaRouter router, RouteInfo info) {
-            scheduleUpdate(CHANGE_ROUTES);
-        }
-
-        @Override
-        public void onRouteRemoved(MediaRouter router, RouteInfo info) {
-            scheduleUpdate(CHANGE_ROUTES);
-        }
-
-        @Override
-        public void onRouteSelected(MediaRouter router, int type, RouteInfo info) {
-            scheduleUpdate(CHANGE_ROUTES);
-        }
-
-        @Override
-        public void onRouteUnselected(MediaRouter router, int type, RouteInfo info) {
-            scheduleUpdate(CHANGE_ROUTES);
-        }
-    };
-
-    private class RoutePreference extends Preference
-            implements Preference.OnPreferenceClickListener {
-        private final MediaRouter.RouteInfo mRoute;
-
-        public RoutePreference(Context context, MediaRouter.RouteInfo route) {
-            super(context);
-
-            mRoute = route;
-            setTitle(route.getName());
-            setSummary(route.getDescription());
-            setEnabled(route.isEnabled());
-            if (route.isSelected()) {
-                setOrder(ORDER_CONNECTED);
-                if (route.isConnecting()) {
-                    setSummary(R.string.wifi_display_status_connecting);
-                } else {
-                    setSummary(R.string.wifi_display_status_connected);
-                }
-            } else {
-                if (isEnabled()) {
-                    setOrder(ORDER_AVAILABLE);
-                } else {
-                    setOrder(ORDER_UNAVAILABLE);
-                    if (route.getStatusCode() == MediaRouter.RouteInfo.STATUS_IN_USE) {
-                        setSummary(R.string.wifi_display_status_in_use);
-                    } else {
-                        setSummary(R.string.wifi_display_status_not_available);
-                    }
-                }
-            }
-            setOnPreferenceClickListener(this);
-        }
-
-        @Override
-        public boolean onPreferenceClick(Preference preference) {
-            toggleRoute(mRoute);
-            return true;
-        }
-    }
-
-    private class WifiDisplayRoutePreference extends RoutePreference
+    private final class WifiDisplayPreference extends Preference
             implements View.OnClickListener {
         private final WifiDisplay mDisplay;
 
-        public WifiDisplayRoutePreference(Context context, MediaRouter.RouteInfo route,
-                WifiDisplay display) {
-            super(context, route);
+        public WifiDisplayPreference(Context context, WifiDisplay display) {
+            super(context);
 
             mDisplay = display;
-            setWidgetLayoutResource(R.layout.wifi_display_preference);
+            setTitle(display.getFriendlyDisplayName());
+        }
+
+        public WifiDisplay getDisplay() {
+            return mDisplay;
         }
 
         @Override
@@ -707,46 +408,19 @@
             ImageView deviceDetails = (ImageView) view.findViewById(R.id.deviceDetails);
             if (deviceDetails != null) {
                 deviceDetails.setOnClickListener(this);
+
                 if (!isEnabled()) {
                     TypedValue value = new TypedValue();
                     getContext().getTheme().resolveAttribute(android.R.attr.disabledAlpha,
                             value, true);
                     deviceDetails.setImageAlpha((int)(value.getFloat() * 255));
-                    deviceDetails.setEnabled(true); // always allow button to be pressed
                 }
             }
         }
 
         @Override
         public void onClick(View v) {
-            showWifiDisplayOptionsDialog(mDisplay);
-        }
-    }
-
-    private class UnpairedWifiDisplayPreference extends Preference
-            implements Preference.OnPreferenceClickListener {
-        private final WifiDisplay mDisplay;
-
-        public UnpairedWifiDisplayPreference(Context context, WifiDisplay display) {
-            super(context);
-
-            mDisplay = display;
-            setTitle(display.getFriendlyDisplayName());
-            setSummary(com.android.internal.R.string.wireless_display_route_description);
-            setEnabled(display.canConnect());
-            if (isEnabled()) {
-                setOrder(ORDER_AVAILABLE);
-            } else {
-                setOrder(ORDER_UNAVAILABLE);
-                setSummary(R.string.wifi_display_status_in_use);
-            }
-            setOnPreferenceClickListener(this);
-        }
-
-        @Override
-        public boolean onPreferenceClick(Preference preference) {
-            pairWifiDisplay(mDisplay);
-            return true;
+            showOptionsDialog(mDisplay);
         }
     }
 }
diff -Naur a/packages/apps/WFD/AndroidManifest.xml b/packages/apps/WFD/AndroidManifest.xml
--- a/packages/apps/WFD/AndroidManifest.xml	1969-12-31 19:00:00.000000000 -0500
+++ b/packages/apps/WFD/AndroidManifest.xml	2013-08-14 04:13:30.000000000 -0400
@@ -0,0 +1,35 @@
+<?xml version="1.0" encoding="utf-8"?>
+<manifest xmlns:android="http://schemas.android.com/apk/res/android"
+    package="com.example.wfd"
+    android:versionCode="1"
+    android:versionName="1.0" >
+
+    <uses-sdk
+        android:minSdkVersion="17"
+        android:targetSdkVersion="17" />
+
+    <uses-permission android:name="android.permission.ACCESS_NETWORK_STATE"/>
+    <uses-permission android:name="android.permission.ACCESS_WIFI_STATE"/>
+    <uses-permission android:name="android.permission.INTERNET"/>
+
+    <uses-permission android:name="android.permission.MODIFY_AUDIO_SETTINGS"/>
+    <uses-permission android:name="android.permission.ACCESS_SURFACE_FLINGER"/>
+    <uses-permission android:name="android.permission.CONFIGURE_WIFI_DISPLAY"/>
+    <uses-permission android:name="android.permission.CONTROL_WIFI_DISPLAY"/>
+
+    <application
+        android:allowBackup="true"
+        android:icon="@drawable/ic_launcher"
+        android:label="@string/app_name"
+        android:theme="@style/AppTheme" >
+        <activity
+            android:name="com.example.wfd.MainActivity"
+            android:label="@string/app_name" >
+            <intent-filter>
+                <action android:name="android.intent.action.MAIN" />
+                <category android:name="android.intent.category.LAUNCHER" />
+            </intent-filter>
+        </activity>
+    </application>
+
+</manifest>
diff -Naur a/packages/apps/WFD/Android.mk b/packages/apps/WFD/Android.mk
--- a/packages/apps/WFD/Android.mk	1969-12-31 19:00:00.000000000 -0500
+++ b/packages/apps/WFD/Android.mk	2013-08-14 04:13:30.000000000 -0400
@@ -0,0 +1,11 @@
+LOCAL_PATH:= $(call my-dir)
+include $(CLEAR_VARS)
+
+LOCAL_MODULE_TAGS := optional
+
+LOCAL_SRC_FILES := $(call all-subdir-java-files)
+
+LOCAL_PACKAGE_NAME := WFD
+LOCAL_CERTIFICATE := platform
+
+include $(BUILD_PACKAGE)
diff -Naur a/packages/apps/WFD/.classpath b/packages/apps/WFD/.classpath
--- a/packages/apps/WFD/.classpath	1969-12-31 19:00:00.000000000 -0500
+++ b/packages/apps/WFD/.classpath	2013-08-14 04:13:30.000000000 -0400
@@ -0,0 +1,9 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<classpath>
+	<classpathentry kind="src" path="src"/>
+	<classpathentry kind="src" path="gen"/>
+	<classpathentry kind="con" path="com.android.ide.eclipse.adt.ANDROID_FRAMEWORK"/>
+	<classpathentry kind="con" path="com.android.ide.eclipse.adt.LIBRARIES"/>
+	<classpathentry exported="true" kind="con" path="com.android.ide.eclipse.adt.DEPENDENCIES"/>
+	<classpathentry kind="output" path="bin/classes"/>
+</classpath>
diff -Naur a/packages/apps/WFD/ic_launcher-web.png b/packages/apps/WFD/ic_launcher-web.png
--- a/packages/apps/WFD/ic_launcher-web.png	1969-12-31 19:00:00.000000000 -0500
+++ b/packages/apps/WFD/ic_launcher-web.png	2013-08-14 04:13:30.000000000 -0400
@@ -0,0 +1,518 @@
+PNG
+
+   IHDR         x   IDATxXg6pM&d7EcED(M;bvVD,("HAA H?g33=fw98s;4jDP(
+BP(
+BP(
+BP(
+BP(
+BP(
+BP(
+BP(
+BP(
+BP(
+BP(
+BP(
+BP(
+BP(
+BP(
+BP(
+BP(
+BP(
+BP(
+BP(
+BP(
+B+RSEP(tPP(:IS(tlQ(
+):(
+uU7y>L|w>:ISL|J9f&/UAMxN'JPD'P`'Mt1,1,5/r/sb-my^1J9<?BPv85e2f<qfNy]6b6<#[}B*B@BU
+B
+ 
+ 
+
+  
+ 
+B>6R( jT^1cGFGDD#ycl[s6xM~Rc'=NU&wa_yV&Mry"fxA97ngo=JP$'Y.PoM,.kO7\4zG8*|>x\]k&!&t=RT?qdpWZ-n#ObC_r1:sP(* T  PP(* T  PP(* T  PP(zUB6[=eOEwx q^ () S ) 	/z[U;]_~.[ slCBi"-PyJwQEFx;.Vd*<+L8yx'g)]LF A
+^xt_ 06B EW8U1"l_MxxBW=%n7'k;y. 
+B
+  * 
+B
+  * 
+B
+  * 
+;d+.t(%Fm5z4~GblAhLX{L[<}1(\(}-b EHBC~_a!*W7Z?f-Zsy4-'<u2ovNi7tZO]Bz\RP(pSR5G2'Xmr33[[c7o'
+#O^bC9^)ArMnY=jdl5K9}\xSNU]Xb.WBP@
+ BP@
+ BP@
+ BGbC_B|iL=df%<@]w$6Ip?5x[iby)u.Q_G^=xZW`HmBj`l^-#{.k,1<JyaOrpU+n"^)<_PQ#{N1Lh-pPDB#1Y k^<~7rvv"b:Q(?/+_\ t
+X=Ih9m7MA~o{lyDCxLc%`5f(v]`C
+v2<7<"$nGD +xUJp_Txe6[n,~.w7Cj'=p~`@-o~xp\5k
+B
+  * 
+B
+  * 
+B
+  * 
+?_Xl|or:o]fjNGbEDX1T^5v4a@cx=m<
+\ThcX_x2Vb
+2%G)UI)9`~BX{ 
+a-LZ K`+j}yy9uyu.
+f.;@6a9K:7aYqcVnsrjXP(infkv:V7g\`f {_X'?ztm&<x,aC?W;U
+x@%D,I1y0Q&&HL0Ub{$f3X) W+
+aUf';y.=]oN{`)oJ/^2(~^0Y=}X?nP(* T  PP(* T  P(
+
+  * 
+t,LhwFm6m:eqt=f3Lf15zW+BV
+F<uj^YTj>3"LI~RTNHb/$`H-UOMJKP=4/f"JFZtOL*[`'SYm\y'yxJXe`S(
+E
+/Hr\N\h<?}ugO4<6Wy T_+e-eW2X"b	>xz^JGJ
+ 3"H:gIfG=/'[q AwCo/r[3$O\\7+T7; zBj]/pFqgo9JoMLP(* T  PP(* T  P(
+
+  * 
+ByA9U-z>{_}UT^~RXX)_l
+6i0B2VJ!WX?}> f09 F#Y#3@$@"8!>pK"Vpb4XTZF:g=6lccn:bUe~U/FmweoD[R( x{;>ztn_&=`Sw.AS\+^-#X"%0Wbs~*GzH.Aa4& XX	%Bg{YHd}7TxVUV^6Q><AYs1xs-5jutSP(* T  PP(* T  P(
+?V ~~^]3}\+Y
+f A^ 	R
+k _KyR5 9:)(VP3OkXD\) /W (
+|+ %x\S( zQP({5MaM/1)[?XS0Y(*6y5*Vvp?Sw2R?e-]  O sPL=#uE)#t$f -?	Xu)s^y!Y#Wv<k5X+xk]~i8okRJ!
+B
+  
+BP@BP(T  PP(
+?c&y0m^L{1,0e22hu^R^pics
+X$ D\/}Tov6<sRT "i( CV`rm	x~$VW z}C;R/\}hO7_'5Gg\[7<qTMxT (
+_|v0JpUq`W(LJ%fWaacW@}+y!1	n	qH{_iRa$$p$Vx3+XuDT	{(;HPq7|`'
+][\dWw<kPTA#dG+< {5mLP(T  PP(
+ * T (
+
+  * T (
+9$H iy_?ex`J{.%Z=BL@P	q?H>LEiL`y+xR^D5xCjVFXIldTVaJ@</bCwbC?QG&qOBp 6y]Ky=/I?w8+'VoM'~PAWe
+O6o\12{ LUjVS	.+aW00U({;|90Ja9Ht(\{x-+{nTV~]w{exHgE
+c$Rp^0ni !n QO&HpIwvo\yK[Dg2p2r4bB{^N<7q
+
+  * T (
+
+  * T (
+
+  * T (
+ IWr`z^	t+O<U`K-1/dvVCXL6'!y0]q^=Po?aL@j{Y`=R
+k{c{Lx$?IQlDlEbDT	"+EH`a7g( 8)g|S-9zOv
+}+o3hx P(?h^gQw*ZA^2!kxP
++W^L6xwce)%@*`4jAcv ij"fJk =hb{w$&?Ic%  ^gn	# N3 $I&Lp#ra|kls6pv*M,Vow0WxWvl|1-0*
+
+  * T (
+
+  * T (
+
+  * T (
+19L}&L+a%cRW	l
+alx\mvGL@:
+r]
+lhRD31%)_\V~CT 
+@*LD)+ 1uC v0Q5@&/VP !	9eg3mSiV + ;k'vREkxQu{MS!;v^4@PWOacL+6YK |-/t6xmnlr`lXj*b ?}+129[o
+reEF*|LdILB?!XHF#!HD@~}!aOD[ 
+#r!+cg2lSib@X	uu!&sl#_E 
+B
+  * T (
+ * T  PP(T  P@P(ap)-KqLy
+=MU385)0\A.2+En<q[TnwSlcC_V,#E$(warOkoFyeId8$xh$~$DjcgQ1V^HPQO6{ 
+]L-j>)8;!GnZh5jux/^t8Q#qs;<*
+wU >OpaT?^>,.l6$F!?IQ`WEg@& lI`lpi/Hdk<OZ0DY?qr0d`66U;yg&l5chfHDUHx33^	az!W(p,; `)6l(Xp75qx.fo<q;r 8wHK 
+B
+  * T (
+ * T  P(
+ * T  P(o9_$^k^&Xs
+amC(bM,@g%x*^pm:;lVAJp4(1A&][>i(SeMST /gMERYaIa#/Dqc[1W?
+	xVD=+p~wbwIHb1xKpSa_5
+4Rv\2|L<^kw;;WTJQ	P( ]/?>7?px0W'B-wl63Ig.F %`P#i[f iZK@^&ioeCW
++1qcJmqsXWjv_5x<nTAB^H`~O
+l{NW8Id9howB
+"|)6V +Fv ?A{-q+@g&
+B
+  * 
+B
+  * 
+B
+  * 
+axy&,7x	}o'e	Rsa[!s[3ZS^z rS=H3@ Zrsn4$MEBL0GH#s[-ce#Yaa2Th
+ I;If<!qc?O^LM?^c6+"a3'$A_/\	@&9j'$89ohc84g,PSduSpb,v^6\uD6h,=OeWG	B@4J	#jr=Xbc77IoS7j 5c v[3V{5d0F&	~Ia([}s%kWcI
+/t}6yquc v4S#D<7"b-\+v>RW;yrX9emk8q9$9!'nuc7mQ? y`$l=tCxk[M{
+OBP@
+ BP@
+ BP@
+ B(x7jY9xv>i<5,H0KHbYz!Q $f ]3nW-B2jvB6RjM>RVEuHJ:	!7G0#8V-rGIb4rA.W?N&vSt($G|<eGC\+vHPaR]G^lG8p HD
+[?N|2*U25Oa^7G<B-h(lXrzOX^NfQcYl+P(u<jT^b3i|a(L^Du?6{"J 	aKl# .I +  A r7. 15u* 7t_W ];P]WUL$zJx\>W [mKo~}[* 
+
+  * T  P(* T  P@Pv2j^b "nT "2HD $z8$UBjcu&R~)R8$z3VNAU;-EY77- a mX8"GUl?Bs-j{p:o> R6lc	 
+Q^y'zy#GTO/O/I+$jf#15c!j8r7<rD=paH\\`<?&pB{ QU0'Qblg=tM6bT%Q1+7#}Pzy8VHP\\+snOw0q$3|D[{x4r<9;Gx;?^  ;ad_Ga)C5owaW{-lyy3PV%,GP P@BP P@BP@
+  
+* J
+w[+~S=_7q~z&".$<Jp\"J"NS:?pWKO5! r|$\+D9r8V=LbXjX	%gbkF(VZ'G>/P6y_<	~W )S\&v6'!) A?Z]-7oNF$` %.j"oI)=6r
+E1c}	,Up
+G|c/f_7S,DW<yJ W{@PqwbcKHxIP^'*>@?WmnH%>&WGHTO7e#dA.Z2!lB:|{?_f3inp,92f"QkjD$$o
+_
+[.@\/ Sd%cp=|A[w!`WX::ZS)x:Q(* T  PP(* T  PP(T  P@B1]H)w>~;{n
+<V?yQRr1.?u)n>\$?K!HOV:$G[bd(&W!>Q>\DPScA|~ $~r^_xr>Nb;3SF#^P]WYIc	p6|S)"+ :  Q* KTMdvP(Rd<nCBFEOxe?ixY. p9+o/czrp- @:uT 6aXA_RV<B!ei6W[;	~ 'A@pwB.gr.w Y/Tnnp<9vX 2&OVQ)M=sz{l>
+|dct 6G
+fmi`vvj,EgC
+
+  * T  P(* T  P@P P@
+ Bc ?YHtz\~{)^XX6xW\K\oZCHh,xXWkWyPU[V?$ltG>8I>8#`\]+VaK])\'$|E6/dEz;e`gS/s2+rvWCmOY;EXDkKe9)C`~g>l7B7!OG7do;Y.-6+ 
+".%:q4/ a.)\/]{0B#(s{{]{][.2s9vp*HvQ(u((?!w rz	+\B'yqP.WD
+n~L@.s)`scWJFe{|d|..p,;k^QXa\M^
+	#qu=`7D+~Sl4DyW<vn--A| 'FlHP@
+  
+B
+  * T (
+ * T  PP(Qx. ?w!Caj^` l[s62wFevXp){N;\Z?/2we',O>hwd=a} ?`>'r6Q6OtS)oee9
+@dg`Dg8f~7'!AWAHd>K7'1 M4kyK<[o\&V)o:CR(?Ks<cWasj{}5w.eYKD\9D,'-vp:6d+IDwc^re.QWGK9nW8`eWg9#Tt_w7^dBW[]dm^ag>]x;Xu"^Kl:k)l1G{
+lkxKYXx37(y}+[)O\R5zU
+ * T  PP(T  P@BP@
+  
+5^s(<-N:f5V_\fL-`6p:
+9a#3NHorW	;MbN!gt/;I^:,[_YlhKQWaWt%|R1$q5=r;~K\i_\d3?\, G"n+ s=g2N!Yp9=f<q=m5j^OSc):cR(} 	Z9LJJ;w>S\1SI&J9Z'!N]Xb`}="~LlX0i!rT ^2@aWRQaNi=mORO>x|W|"^x/!|_}ab`	3S, f37G66ybXuQ70uwj6mV8l@P@
+  
+B
+  * T (
+ * T  PP(TWuYdjOlZow:Q.$02>
+|Std##.i?VB\h's*+r:k@{m1x2s/g%wDdIT9%+v}ao]SGbmeG[#wFa/n<'\v_iXyv\\H+.|t\|'G`!
+^=oFV }Y4S,. 
+OX N&ct8IY1IK<X($L+<BpZ,gu T
+IuS({_4O$tgwT;c##'%|vv|8=#{{\ Ln_J l:m<7F+zn69 h`Gw)6@
+
+  * T  PP P@
+ B@
+  * 
+)
+lSzxGW7m]y6xK:1XB'Y	%VrLI"#] SR0d{PxOR7L]VW6+6}lj~kDt7?_joli&&q_\e6(m`zwG^`~d`70ew9gsrrj/IPhtVuqw-zZ}Vg:1T:Z /u.%ONK@nrA/"B:Up6=ozW;e-s0JFk
+N@:u. p 
+`{;yM&'- ":CR(T  P@BP@
+  
+B
+  * T (Vt;w,ot5Wy+xprGov&N-KV"kx2'OPE|8OGi>c
+C\;cm0`<-eI_s=w6w/|lE#6e( qa7`[} Vj,KCj#
+y0yu3d*Ly=}sN( ,:S(t
+- ^T 
+ _ |~l'T (* T  P@B@
+  * T (?\hx,0?', , q/_ t/a HJ STpSZ) ?@ZRZPzt7ToEt;n/T-n
+S84Rb
+%XE+$9RJwZD>k#J$)]?RJ]i+8%[=RWM|l;.a/6\GMg:l`9)Zl#+e%{B`U!g|vx}Vo|..TM0C
+yA`D}M
+hC
+ * T  P@P@
+  * 
+ * T  P@`?Q t/yoz'(q<N	ag/TJ  ^C0CJHsR`C1aG,ZVR)PJHO|JG*vaOv) n~
+U
+t_eiyXX u, m`;+ -kl#0HwJ MjC	_8/\krX:|
+E2PhM c)'}z/xG#yGn/K`S5ffH1nxiC8840Q,20/:xEu93KFi+_[C[J[t%`"'"wpld?g;$.U~aYl2;a k>0y nZIz/n_AU 895jx7j[^evcaoCWjhQ P@
+  
+
+  * T  PP@
+  * T (Hu9"qqH.qzw8lp&Ply C_#! (50LZ LN(!w ;(IKQ |`:K_5+;L8v\2fy2y3.l? [}T, XCxFM[J=umdo4f~tqrT5j|$^fbX0
+bXxtG^z}Lc^z9Nz,!!}oa&}Pn .g4Y?gWu9=.Ml_\vBZk$T;L_rY03
+srnX&nC@N2:vmy\F^V>97q~)~%6/#m-~-~7AfY}=H{X-?}}dG;X6IaZ# 6G:B`qnp+!lO*/6/
+`M&Sa
+grrfM^ztDL!_vd@
+  * T  P P@
+  * * T  P@
+ uqUG`Xe~u7^1,Q
+aBX:3s4iNKV,#|N%sK.zM{4qiaKv]_0*hXrnA`#s`ttd'3"396T1)h>u0r_q%0d>{"-_Hm
+ 6IH */lka"^d]cvUiUoaSZ(S>er5K6_^!,.)<4W0f\^l}x!%]uetYt8umY6rWa}rp+Y_Y+UXEC^fN/K=';vV/fyeC
+}*UTtJ{u90N lr-6+t@<P#d_t[a-N=0{yX(PxWV<(*})wj-PNibE#D;[JWo=\:m>+z>X;X=mz02m])+[&jymyY,>FaukyU	la{0x6bXa=(O% 	}lWb][TCx"-Fn	;-]T^	J
+  * T  PP@
+  * T (T  P@
+  qul&90-^!,+Ce.@PEKx`W 'aEqy	c"Zs6w2`^mxB/UP=0
+/UKT%:RNo9:h9lk!Ot'-gYt&;T6iUB00+u/Lb:] ]K&`M11l>c[s#9-?` x`{{dne{GdVC4xKM}+xciI<vz|EJzNT1V#vBF\Q];2U3M+,
+<a _7VU7QRG/n=;wB<@Nu.xTx' H_`{|X9Vy
+WwA.,D
+a<`W|X5Tl\)tK9=;=+N'{gp..PZ>>o&\lBystM`0cfh6!0;#vgVzIcd1z3E@qX t++zy_L|/MCy9Hy-
+R
+*o,q`;fx<	lyo,oK=Xyz{0e12y)L\?
+"FM"F?=cco}!6Q%10w9OX,aU4U?=S9NXKwk=tz;#c5{#yf%>xOvTY6=yF  * T  P@
+ 
+  * T  P@@
+  * T  P~+Gxs[%K}8n]^rjl&n&^P],BRk
+eB@^obNOnjo}[U}6i[7>s?Tno+?plW^PO}^<.lkOxw~CMNOWb,{|-=8{;9<%2dj+152jnk LXMZWCma7v6u:@l#d.cXfA[bwh?`\WCdfQGd)>2~q;-2j~152lz+<%2`B75986;Y:3ck0N{01n6m.F%o^-x}Z&u.=[5oSl:i;v@exMj^`^MH0$dQ:>&?<g/r6p<9zJ8p1lv(__[`jWPWhnjI:LyT?Sr</^bk/f:z\fUsyHB$rZ2	).\>dW;`>k=W;o9k\[s`1)Z)!c'r',c!S`a/ka^Pk7@,Z^fHKo6_#~6iSVDZ|	&Dco3;dCX>Z 'f6M>]F32} LR"SVtWILJ%F/4eLZj_lol >]"#[!Fn:9|7'}Z?Xo~6WUSXY#W.HAv0`(ws]z<3pmoIX~Y3n;iMg ^`@R91X!#;5S-Xa=oFy[oy8J&NK@
+  * T  P P@
+  * * T  P@
+ mANO7hF`BNj$Qs[ 5@\F/CE<[w62T<N[0go?7Om/(o^pe}HHRxmI-~B =?!> =g+_fo!}&7/?{7O$>fo?>m?grx_/we]{H)|3}(&M{'oc}wA~CD#hvtu'2`BSas8<rNkQ:xjNNYa-n5<Gxljy-C6;!n/	!p7Av\2nx|3g:o5oG;mOK?:`yC|RT5j;785|_R{Y3.d;y~=6S)]4+JNuKJ'c1?aWm&u']zlto)?.YBu}7lDFiSAl>C,;~o#_|
+{wj8._>__^{xm|:d~Aoow`j!?B	fW5g2rNs>SY"n<'y'.br-eWx".'Gy47xc|y}'}g"T  P@
+  * * T  P@
+ 
+  * T  P@7.l  O^?jW=A~T;~H~xG^<uaCD`;1p{OYZM[-n^ydx"2b z/ #WA|ge:txxpdv[uGa~cdn#Xb 3#[##g7A!L"}|=>Kmd%MO'H^L:|b?3,N>>!V.?<?:0+mxW~k[LB$%N8	n-RjR9s&>7omv?,as;2{b-,%#+R, eSB,'I\jIkr`Y,	7;F$Z0vzhEGg9y$e@]@PD+2Z@Ew2HY'WGx+"nnrf1cnL"{c@o?[
+4v wj i<<+#j+\:y2:8,!H~w'}CXAH,+hjq$8[sW0jxvYK{Cux}	?u=/a|B#to03&"GdG/.@^0|;Tv/=g[lyw,[*VspRom#5n,.tby-$
+YcZ s4^l3d<#cvccfcf>fh#jH/ec#g>F{(2aQ7>{>l~>li9\{eBp"lYtIXy8$B[Y~?pi:6,#PmoHC~iddfi=I_/5Px{U6Jm7mv6@vgj%`{V*ltf< JF]VE$`                 wi T(@SK 
+_< ly |7I] W zP$;i1]+S"4)qa\G}{)z"	{ Fkxx5^pnLLsA1DIK#|{pf^lA>o'dX!A,4PA@}.P~CB1By7w@691dMr;VL68 IuZ*;Ydcd>_4l`!-OECE[A[xAY3F7@Ael<mxdg'3?b9BK..cB]/v_Kg!GN/yBg+[3c<9p2O}5Mfev}2Afq2>l}kw'k>:i<25jmwE
+~HFs5:3]XVVbQd$t!$JD<
+\"}\_ls
+}/~ Q_3]P< Xk< t*nrA78Jip4&8 v2-\#vP P P P P P P P P P P P P P P P P P P P P P P u@k|za0T{B, 6M. Y! jUs{M]k@^jnno*l:m8WAO9]a1HD@1<WM 9m'EbGcc<>@f<?A^Cr|vQ>|bg)X /{y$?,B~|>a}6rY|OG'/}KM]O#qA;m~g4m>=YvM/{@>>;>8(UXjhAZ,a#kmC"0lY9.(Dm l 6>xh"b!nr6?V$&N|^qrXZ-Tco3@ XoBSCPuCA|eP a,A{#\YAllX3rJu~a,LKCPj~S/l#dZ^QkQ^83.#;yOC=,94Dj '"\ie.Wxgj{`7l:uRHO5: )<uuR-XX`6+dv5a62lO'y(8rk%s6:-bP;d o.HvB  7-H( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( (  (jy D(.? 6O	8wnf-e	# GL 9U3
+  v.F4yV@9!`!^Ce_/&LO v\>.T>5!sv8|4`;]\FL^i
+zRZ! Jnm j}^
+;0 Mp~EP0(wu|Y6q[rVl;]WngYZYM[k>5ut^(ke79I_0j_XAE.)ap0rOT Nn%T? 
+1kUOLs)RN()zJH#hM;|H|P~3Ji9?<1j5%N,[B C'*}\wIe~Sf< 6`kjk WZ/%>)(B	e >kCay	6<nn;4 v pgMzuT@< }d0iQU56v(vFqSPd ],X# *Q*#BTTk!7d: tXD'Uo SJc%Xm,3-q@n.3(* x ;"1< \0 Xy
+@* +R 0;o9=R!
+r jh2iA #]QEV -3@]Cx h\jQui6sAYAGyNP1wcOPQe
+?OLw7)NH[	xA.=)=t\iWEiKEgmr<;x~<|HWZ ^"\G), 3O>! X`y
+*AIuJbn1_J|~x1 0v@:f[3R ?J       .
+ 
+ 
+ 
+ 
+ 
+ 
+ ~ X5Y! D VP/i* Q @Zq(}eG0'[n LXiakb- QWAWUT@='~VJxn)Hb.]y#RI1Vrvr@qK~fL:  mMxa6 heR 8 L?]! U.vH (S) q2@6s*  iQ  8vY4af wY `3@nMjo2 $	mV
+ ?d) lK sH@oCJZymZ-[A1[il)rJ1j#AqMr" wPN>;"YYz9Rm+1
+i9Rhmz!Z{AH7WJW{|H:PhKktYhX/C,S
+ A/M{>q Mm 3 n#<B+tER# =>4;b1su]                        t=>$@q\F\zV 7|.}Hm 8R3F5k-F-Wm|iN,I@iJv?@;7Dh"-X$z;Rk}yjvu_`|yw9kXYH`(?9] -6 1-*``*r+Z'_'~z3f8?AzX_E,*v`HH#p@+,A|!|C iyP@W%|KNyFhLs
+Js0T`9}
+= 9
+ 
+& X v
+>4_! .>F AiM>(;!bgS P*ZRai zWMloQ#I>f.Fs``lHdVs${FlE
+ pC
+(_:6/b*
+ lR u Z$,`jh ,r^g.[y d(@< B`V1sF(                        ]wb L,h`PWC) {S/IN,`i	5fY2hAT3{MXkD :I^ymr5Rm} E  D HuqbRa[!VKpK${V-lWc8x`q$9n={}?)rM]zp;q=/CVC*wMn"9X&G$m/,jCb*n+@z8O""-OD Y"3{2o?3sByR ,vZgjejk% >09n@q9 }%`%PHqy-D =1c  ]lD mb: R#aAYVg>	MXs1=@Mo :>! p ? [ 
+Q2 N]n2Jrm>/;' E#4"x=\Jap[a{^B-`6B2ZXJ9f7hv1 -tu
+ j@+B P 
+iQ
+  g~ O ~`V`z
+ 
+ 
+ 
+ 
+ 
+ 
+ 
+ 
+ 
+ 
+ 
+ 
+ 
+ 
+ 
+ 
+ 
+ 
+ 
+ 
+ 
+ 
+ 
+ 
+;0 .iP)E<l[UEm HR-k4H|= G# >g:M\h>9g[t#U&~$zGQzw@x`vH/UVcl!95,{Anr`{",A^p;;g?c.Dt\dCfs{@eo?>7e
+*vLf=[VH:;	{LNSlJpvN%%Tw .LPgiLj(<H [,K8A5vVgA! S\/
+ S<xvUhPp,A3(  80*9P  * @M<T=/ vl l`  HzkD]d3A|oBr"_Uc KDs>ZTG"MV,/" JoALN6 W 0 T@B  X`cb TD l .
+ 
+ 
+ 
+ 
+ 
+ 
+ ( ( ( ( ( ( (  h~fUSySlPz< 496he U$@)  :uC8	P b	':"h  $g
+b lwQ- ;-PwC\:cUZvoXE\Z,Cd'ON!.5B;Vnd%]j%w?A})2Yy,KZk)Wo$7;R\?$t$_1 jdd x UP>,ZVZ 3x 0C<yN;?SZVX,dPB]n<qg`WZ: dG4;7&Hbr>l +.1|CM;( =059v:  *@dYu}PSKd~!c^@{g S\t [ %YbZs$Fm k~ 6tkxi C ` tQ P P P P P P E@@@@@@@ Jo (oUZ`2[!tU#` |  |Zvne/16h85
+V*@F& <'( (  h{>CAeldR 5eE.YA, XR=CPX-BG@41KmWC/ >?C*JbPR7H390HD8$?xm
+@JCG$kKjdg!|#:}nB/_B2.H,|n7"7Mf+m*s]09S$d]+I5<X |C~7ok6Z?IvDs^{N H) 6u G, 46~@;3 *vN he@W 7 !t>*|qk7 [bAQ?tHV{:H";F	7'?D	 0MP](]<yyg>D`yG M"v T 
+e@w7V] 5}( ] 16l,TsZNar
+&{ZSG*@\-cP*  o{t5k+h+%q0H3Z$"@rnMy[C\(]*"3^c(@{>ragX{Rsp2fo#t*G6[: :ZOP3_*liI6Gy LC4lZ}ZPm'vU!q)N (*>, CN$cHtsGR
+ )       tQ P P P P P P E@@@@@@@ Ml $D x 1Pb{HW>6 6t Rj`Rmq@LD?keukMaJ'Q 	 pL5/c;H,PIy $T UX*,  kn eV K4;Q3( ] m*vO-l)z(l7+$GB5b1@ AD=~a)hfM'_9%{J,w(A	61p0 FV-<nX&r[
+jb@$gxGj-a#>_e|z].
+ O]sL$l.-OR:(Rj (p`yNHhv?K5 t :s< x tl  o??Aq"	
+1.f>?2                        t>EvM*?sX]2 6?_}5OCPW>T>T +U m*` -lwfE`[#:i\<yW_|\tLa?l4uco!/}!	,,a&?%VDRg$N>hT $2,D};E"w?}kD) :?A~:-V$[u*`@ pT VN}6lTkZFH@jJ D) RHND Hw(> @x tx_kN]Mb_QCJ*-rd
+ NYH` * vH#%7jUYH'XHb6j!bO,rD+ul|Hyw ON#;w'XMc!(@'+oArF7$ICtu2 v0|(_(z5_Abwp$-;oL #< vghyQ@:Y l29vFnSf'D ( (AE L                        #pwld> CJJmW	 t^=xM}Xe X1[R R6+D,|h!H,{]lU1-R#mlza}1fv;\zUw_C^{V Y&-, ~Yj?ag1{He"Y?'t\cj%P Z (:*$`89zi>=i x*V >: RVuJM lT j2h9 O*vLK,<BeR [D} 3{B?_ u`# NSBD	 eW>X3@.KDNmpBBj7$TOdYNlI'BKO
+h^_S5.\d_@6!ky>d,$iR.~.]F~"u @|HlD9 b#y,*w5&[!+=cG@c-u 	Gg~:} M|N J/>$v(tJP`2eZ(>D@@@@@@@@@@@@@@@@@@@@@@@@p rz({! S)IO3[bm EZ# "g4@S^6wH"@b+,_eZ  H0PBzP D>~=6nT.Ehg$4y4O}GRP-r~Q:^KHMs6+KFEAFfBq,< kb/3gOs cXrHt[nCR(+A@$@$R <`
+88!Ab.6I8Q?_+PFB lp1- %!]MJS 8,gOB?
+)6~c= O
+, ]2 6CaP?t#k.yZUMo`W;.#ivFDt52b_YDB'#+3_yyT]v9'j:/gwG`s nCzH$<yyG/+|"I=%kX@|)Y .`3Twhy'!d `2Z@R 4O]" PHv?D                         C`A 4#)v,YjN.FN|H)EW[ AG<noL\hsr. ]@REW`oE	 N2uF $IwC]xXw9f 3%_#o{HVYA|`$:smAv>*[,x?{`BC~~-)/ko4mX"l^YeKbd8 }t:-riU3gO!"yy!Q%,&V;"S'RL$|#0O7$Y"O(g=hQuhJD%+my;@,Vl S 49!" ' @\"@dNMI3{ H@ |9 , jf-5 Hr`9r[;~HVKO"{+g["W!bQ2#o8--j? Av@">z?I`KCs`C,`l]Gpr7R3 N#k"Y*O$r-,@na DD ` `7TW8`W  7 [  |2'&s<&P P P P P P P P P P P P P P P P P P P P P P P P u [FP18S7 UX]SjDkXD
+5[!j@$@e>V
+	t8Yzk;d 3`&	g h|j	r" d(w)v#U"u3^hs6?DD?V!>3BAzToWQ 9^{edzY&.6Cfa#%zc{{p
+ptQ U#YT0$#+d-(C*?) a|{!kf>>`qe7Y q< RPz#}'$[,W ] I]C[gfZ~{)wt L_6 rx[=)X8tb67!;_lF`I}G}\p^G9GFj
+}Gx6?
+ccUnRTC* p `(!x;7i *! 2n" B 2e( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( Op*wzG>es>4<% } e#U N\}IBO'wab+ vbJ+%@9"%AEJp3U<Ej+_V{!">F}Nr7
+O? o*r,(f2+2|lz@$p}kK*JwlKM TFaHX5++
+{2,td
+B,E"s,O/$Y OOY?iI/X(pb+G#$ 	Q$MN,2ZMy HwR%f
+p6,sAf[?    7 j+W//y96v{r{"1Mo$,a:@^e#JGe  YzIDAT"baSK2C<;$Of;td9">R 7 ^< n (                 U" *~ m_! x |HKEw#C&1fG"!+ #=wp:qgA;e!2C{-F*{=?%r7ZJp 7.^J5{y l=dUV>$nEZ%+XZhL?HP\.|;#mkHAvLXd3ee1|CqF]^  Nm"b'H @J9" tjNO~t!+m]gdnl	'duK3'!F' '"H{n] ZU}q_|Wn/#>-V"8Y"9,L|"4lY2m~ X~  ,{= >lv48"7Qy-g2\Kc< ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( 3 R 0qQ#?6g) ^vCIFGQd2K6y-nP91dlI(C^zsgU.3(rkn  n8 ~ p Hw1J`u
+ :>%@qPW _$%VTu|(@ E 3ly}D 0h^xX/}@@\EP? X8hQ  M}uZo	r& n'j?d}yb?\7r_Xz|9}{T?v5%gz V,("8& v) 
+Hd >= ! q|C> WaPZ|` 5>k\F";"uJ':.H`qI&y!g
+ 
+ 
+ 
+ 
+ 
+ 
+ 
+ 
+ 
+ 
+ 
+ 
+ 
+ 
+ 
+ 
+ 
+ 
+ 
+ 
+ 
+ 
+ 
+  $N: m G@j @Vv` N
+CAe vo_L Uo`!}gcIj6$ >t.nu^xe hU.T+ [V>Q'ioB h 6BE \@?$0E*qA&>_ w./&h5{fow
+pIW?\Q
+JP% m 	fD LiK#'*}KJv!@z<OV< 2E <@Op{l3Uni#E>UwWCaxK3Hekl@@>!qoLQ
+ c#0qo 9CYhCc2d=$ $nh	\|kPZ#yuB9" ]*s\ n@\#) ;Y~Q^C#= rr4=3A }F aB T*@-C,eay$(fIwz (E@R HCil2dalN[0{aG@C<W:` 08TeX p )@&vl`B d aCTHA wY l?W3l 8d3 
+ RJYlUX`aE8}Hyc!o7 |c1 )S  mNL_o	;? 1 }O7;yb3#nA7?8|;nt /gN5tw$(@vD;UP(@XPlLei{, Hmt?O J VCbl@P,h>4hL?~d9Oo                        t|_3wq_BYl$@W1@I|KuO"VFb"@>kdX|S! EDNi>R
+ ]Pb-Pcj4@Hz2Rr iG\ t J jbm9dv["~0; ]\s?  D@P9b
+ >3x;1"
+5HdE:a< =lw>IaK" XbMZm7iAT+B>r CQ
+EH@j?(tB wU Y=sIq@9NV FY 9& B@5naM Sx CR
+1G!]p 2P   P cYdO?:	3gN'@,g>N\E/%r 8ce2 }h@X7 iA $)r DP P P P P P P P P P P P P P P P P P P P P P P P P P={->[LaXo@x $V2L$R[a[nG
+gX*@o  rQHW1@t R-rx 4EvP 4u|C3#`Bze C 		blk$D#"
+4B yHg F'%+"< !c5aIS, xYQd S iFGluV rbK)|'< SD8w@+#]<@ `y X7 H@/ a< L# b+ -6j @] X` hT@DB +U0EE l|c]o|,  t_(A#) ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( `k=s HCR klJ	FJ|(D9 d w`< F)b%|e@vz{U5esB2>Hz=} '@a  _>
+ ] |C?	!
+ =4h%4rUt$;/17Y9 t|C$fGDiidg8 k,BcDJy !< :F8]9yw_()Nu[ +o4 @8 / pNj@/  H HQ 7 (~Wy7;bCU-,:#(u|3L 	?YY%Oz]bCFw2z1Hm $uLP>fTh`A`<  j= JGMus"do}x9 HtF-Yp9"pq
+"{$k,}1(m L9 yZt'iz'M|\/2C>IB>E <  PRjIEcbKP=
+'
+( nA{,(:_= EpcL@@o !Y \|o
+ 3eVzD@@@@@@@@@@@@@@@@@@@@@@@@o{1vd ?KLynu?<MCHX`M>FF) "
+<kd(&.29B *F?{Ub 
+|cI @"Pz>; T|Z( a	. _>52_kyHx#A,<Jw3@&X}L^2<Qs[h$;Hhs=p;`&VUR< _(@@) 1/yNg!o=Q P P P P P P P P P P P P P P P P P P P P P P P Ek@] vE {ngN@, "IVd ;	hLuC 7H}B D ,.:M(uB 5@" ++md*Y)Y v|H(FBWY^ 4s,z  HuBTb	|K9%@ JQ EhP_Wo	 0({( "x {+ s>;HA.H`(`> 	cay$/DbHdpcxh@.52iQ4 <wK_}G! 7;)fgzG$y_h{[fgbV;
+1?yEf:-txAQ P P P P P P P P P P P P P P P P P P P P P P P u g@#k Xw+b]4 _.9{3  ,y)`'W4BrG#G"I|["ST"@Y $+@ vnQ7lyv<<#] GO>fie[e:.| 1}\lX/=7@X#< 2-|CC{7B\>T6)CB1( e>_ERy {9W@@@:Q:
+X) f=wG HN|WkFk3D$(Z"ny ((p=,addec|TdfW&,~rd:Mp(\ bi P2iM"#N*	1@YYeZ#1p(<0y{; X8~h=qi< 4i W29 (LGc!*E * RGL o Hovp`+D,\yv0};w?|._\ L:d~2 f<K{`? " 27 |EF	H\$clddE$ i,A" f>04^`2[#HZcJ# ]M 4*@-{Rj)2BCO,64?h$[[?A wT I)=Y U5tPvjfb2@-WZU,?7@Bc2, e3cE" CJZ5\1+ZWVuH c;ZhT3 E4HNH-9&w_#.SI^_?
+n& >Y< ><	 W(WN}{H"Y!!g	[J) M$L*[D@L;VbG#Q9lY2qq]aXee:.}Z`E; ]\k@M.2|K%uBtu=WaoZmw.rcPpcK<zqD.
+ 
+ 
+ 
+ 
+ 
+ 
+ ( ( ( ( ( ( ( M@^EAC?P*lq(@ 3,Or_>zhfPBw(4fL?K/H,S;$dxB WZ:)^m)F=+'eW^ANS xgoPFRtp<r/+o<*Yl@d~5[8"@:m|u yJ0\ ?f	E/?0wO[[[Q.u3Q5&V7@nHz#446I$79Rg}T&(dH0d#2t9NGY=8Po$Ti*BV2
+'J+cleT*/ -/{yi{hi9/waA({T WV:t UZ + iT@T9?X`76IY ~;,UR um@^Ps8~XAE=yM/6uE ~ [0Y53		JbICI\7E}eoOp-$2(4K@Rk3F]2:2=Pz0TjP]`=X5#p`GQ
+}ZY>}D>?tDS.
+ 
+ 
+ 
+ 
+ 
+ 
+ ( ( ( ( ( ( ( m/1!J&yPBWMGx,B[aaFUVX10 dZlaqnnMY1szA` SXRx?4JW7&T9u`@H^Nu (Hk"+0^lNh0f-/eo""]zQ0PrHbA>Z"F YvSgGG<V"I9Kvl}DBrlXh95?OU) 
+" tD$$e4D&.{y  Y xu~Xhqe+Z,+^Z; 6yVL7"2YS)HBHCD`=;rxPh= !3giz@"W8IN?^J5%V>?VxeUyNW\>8	4HdX oI/K<$$$EJ{zjWJw[Bp$.G.;qpw#v~91^'gy^=H~3F2bR6qY5NJ-{&Ai3%[qxRhD3hL7p;fUtY#MXB:gVGN?4>Yw-{og7[F+wO Kccvidj Jy;X4"GVwEX06-|7	9 ?aY K}$! &5Fo*e4lT/!zNWGjW5`%2@A2YT{m$'v(z<HAz1:A) ( ( ( ( ( ( h       4
+ 
+ 
+ 
+ 
+ 
+ 
+ 7K{ PhR)`zP@)Gr(?kD}Z/WmC*~\+n97xj$:<%VGeRJ_)qlj~a<M=n@vNy1Jo,@8pW'2!1gV?Tkb=V;[9^BAoc{Ep d\<	R>|g_9d|k`H5:"J+#ezGVmtAj{]Y}qg1L@ ]@ l!Ca> LiHz'/(0FqLq>("
+*^;y<0Z;Tu/%N>QEf,C?& OPj7&4s-CjtZ<^Ykw
+*{7odz &!H^RD*/`ZV)Xv}3nuv$pHjm={DCw'$oi X3,aC%U|:}77( 3g!+~:@{x/+8 v[gg|f)Gj}XtHb=Hcw8Ol5y`<7D=Z'< D ?BV*V^7Ox8O);fBOeS?Sht[+)B=I4PiE=Z^3D       F@@@@@@@P\)h% <nLHJ5^ZYR*}+.UA_Ai:O_rk3+r\;(Fy!?oILCrs<D	$~G+ &"4z6H'X@3nuud"?;m3W-?C/\D!i ]%2wg _gm#U_6+XDRc
+	)mwbu}pjinRf\Oy"z0 $f0\ bB  rNcZS*^c98}L[7Wot@})N}n<l?3xbdOrVMZ+MV@_Hv9 bHvZb_Vq*T954;C+m:T	yB:T&Ty9ekyA9^)NqPjm-b{C, A> @N)}@z6(FkkaUGCL,4o|ko|gwC"7 +{S> p<+_g|/B,.Tof[B;$:!!<4v=@xoQ  (uw|'Qai (n
+hjy? F@@@@@@@       }pS5nr*72+y_f`9d48_!.DCT	dc)#o={|JJ?ZN`]"@[  =jt1pFjAb=G:nUC*Xi4Fm7]i^D:O yg(@~O%dQW"~,)h<O*_5h$Wu~L;%T] ^ LcB t>d\8G@*5#p"HZm~zwM=FKCAtV1+S qqVPrPJ>H}C9 > c 0 K|9vf5R)D|-N ?f_FmK@2*Y.$Ou"169/	q \t_ 	 'mn  0} G( ( ( ( ( ( h4
+ 
+ 
+ 
+ 
+ 
+ 2#B\"@jv @[||#H0=is 9{_@7y]{k
+ ;;o#?|)dv qw#| l
+ N?C`5  bBwkZUOp,s,`IM?DUP]hTY|pUJ{q\/f !>g<2X|G>$#	S}#>H="CH1O gWs_XDB=^}+k^? I~G>Bg};P;$Kg;Dd~~=O8d`>;Kf2]?k>8|3Qi<$B( ( ( ( ( ( h4
+ 
+ 
+ 
+ 
+ 
+ F)/)D l#O,=VAsY 8 e@&z6Hl oCi\XEP{eEQk`!==rvWD^x3_<^6HFaVA]vW Q|v KWp#	]/kJ@K_( h($o{_@b^3M^}	3W^&+|{`+osW
+("g,[
+, Yg w[m"]++aOAk*gBy7_tl`u%C-6rW*c_SlY(
+O.gC?MbdnDTZVTxT	R*>A_i4
+ 
+ 
+ 
+ 
+ F@@@@@( ( ( ( ( h4!k<k \|z 'lsNL4q1H'yb)t(;Xex@xE ^ G XR &{Vf8XA3RbUzD#M,I-R{f~wXT|*ZL.V 0:R (DCi	~:gRtc<tao,slN):Z}|4:K+`7Y>xAH~m`PBzu;w@rQ#lspe=pDiwx"y~zgUt#+y]!44;.?}nUsYx5uIT~Mw	|>&nIb>)wN!SMe;'rw `*9NGxB@Q P P P P h4
+ 
+ 
+ 
+ 
+ F@@@@@>0ujV0P\fBsfsZc kXPL!}VY$ 6 EtuiveC.HpwD8Mpvi5pw, *j_z;W_(L	FB|H?:390ifBq\]g8rr[RZ,{ Fha|M BABl_G:cLy<Ogn^I%!{g,dA \ -L {]
+Z8X8&z}j_|/UL^'Cck||V?D7+:%	D7N|3>iM1rZ3Tf(juI:W-4     F     h     41'@x5BG|1hAQT#z}N!AA]+t@D8j~!>e^^&w`>&]OQ t	3uKlHmy'nt?e)?3,b9?	/e->"u44\h$[8HmnCj:^.ms*')nnRqULjEh+~W@+| @3fnv4i/cgXbPJq{1vI-MuM[8>{;x7M n[g=[`	
+:1BgWz_yO$E!)by rj1v3{6TVQwKi4     F     h    4'wQ$
+)o^':5z$dqi@7345aqu81sHJ[bk"a{kAHz96 )oK+TwSdC&.#8yQW-'zEjHb$G L?M2T 3k /om/sU]#j0BV_^&	 }W`fvB=U>5{A.<gq"6>.t$[IAWS6X0DWyaHZ+J!$z7-'g+*.%s`[QW5p*NJN1xS	R2st1R,~:sh#fST[>?V%n!=DHe
+<,+i4F( ( ( ( h4FDO_,GM([pp jRC^/+^C4|.>8UH"=,ldp5sDz'#}$Pj,/YEGoPFDFfx	wI	$tNNRmAvZm3V2(6DVY
+S#gk>If$D?(6MDK;GBM_|iQojML*rOFw1`GcBt1P>oA5=nqaP+d{6.+B6Qo
+dw%Ag5Vj%ZjM}1oIz`"!9C|x;;!)u:Kbh+[$cp#Kb`_b}XRYD2qt!^2+t^5<<gv3*j_>:i4    FQ P P P h4    F]s!1;fNnS/C6/Tq
+[%Ej5|2taHt4KBzC``)1PI 5>>VDrZ \i#[jS>+#94nrES,R`gx
+2$;]*e#[{yHJ:OT4U;K4ajA:pH5>5L%Fx?vc%R> @?Hm%J-t.'N&@0#11~	2^FK$L"BZgZ3CCyfa.U("%v).D^zOW-FF5vyGWHD3K_MWCmSmG |>K&D D>F    h4
+ 
+ 
+ 
+ F    h>
+O&b&/o[odTrK,]v\Rae9\NVz>%5lb\H`Hj2Cg[EV18]*\Jdr?@`Sgj}u6s?6@Cld15[}B*rNkAhbKc"lh+X`$D?ZGVB'e]HYW2(.AnzIIqp8C'oWN G2J*:%dPL=G!%aYH~+:!7V4?m2O!]q|#chT	#xW!B LAzdFVGl{RFbI b"8[$}Pxpcp~pRc<JuHI%h
+r+BqXFPKD]j_E@h    4F@@@@h 	C@Yc6rD4{f/bm!a6u""ilp-G$dd?KDJ] ^%2qj dLyL2splBj2/>G[PK=!kfK"K>\<}Ev	xD;NVubU.W*
+ Fj / flo!dh*sPJ!.. brX~z H;EH(HJ1ZeK79#*WVFYGH7ulW \Ks1/cq>;B=K?K:0EY]O Ree6/VMH~vD2*;,eHlQz?\X$IiN/@rJYnY$lx(C0bn4F( ( ( ( h4F>0^
+8]l2pPZa. _ QXdA{y ?G5TbKJ;$e8"9uPZ<VpCGC9X|By[N_I}2'C?yz(Zc j:YUV~\;
+VD
+%rj]l^zVn!' A >DfD<%HNY8HD%$ yF}t2~cp5?
+#WcP
+Zlze#Hj<L8#3HDK>,p	I$,wh
+>t?H yccuBiu`uq12zAH(KO1//f?N. N&ARJDFbsWyHB-KT*E\\$:W_q
+Mro@??PBh4
+ 
+ 
+ 
+ F    h4
+ 
+ 
+ 
+ F__3gTmt*%pq $-G QuaIG ?rQiG#,40|E;");PPa?Xy&c2)oyG@-@)J_Osqw BpEd!$&Qga@P* sdps	
+ F`A |7}nt!sATe;T~"*[]odT
+,%`'xXV".F":(NHl=zt
+O"42i+r7SR*QE\h3vHn]=p5XrDJ;	?wKPA2#U"3
+ F    h     4F>?'3y_?CH5jnvfP]9N{VCmeT
+,Ex_	&w@@gw@ 1P*YEHp_K9`"p/
+~l&'-9Yj2RJbdQ$@/P h4uv/L}jp3]4AN\#p@*:X+ngX^2!={jU<	"@Yd2}\L. ^x{ ^ 
+e)~|7Rq~ 2 '<=#@O+wcr%HN7Sb5!
+ F    h4
+ 
+ 
+ 
+ F    h4I M=^f+{+SOpP3'P^'>GV:,aR-}z]R3kEeX@9 p "Dz;KrOSaH~](* -\wY<'( IEEyHjDFDfejc\ZW
+ 8K hk<:01H;A| krFY]V*;2=:@*,e`);:#\t KkwNt&%(0(2c?.}/s/J)x%Va'U:z':HV1.Q6 >Ba]y(,F( ( ( ( h4F( ( ( ( h4O?|/(qP](kte-|@Q4Z>*308!%:'V*j{$nB@( '\Lag}@plH}R(:kBqr	Tt#,V(skrBgf'$ETY:)nPTu h K
+~An2Gn{ '\j"aPcE!\bR]G.6f@ ?5Rkb_rogPtsLC\b,c5X^DADQ)3TsyM/+#%C 4F@@@@h    4F@@@@hWg/|\Q;<_pywN7 nekrCqC +kwe.ordvXK/sER(6* E:70(>9>](0RvA6,kr`XQDI+Rs??)8rj;U"eCQq!'_xF5 (|!!  Or 
+\;tgjb@}n|`|'D*Q;q;Pl rwz3";^^o><*2(?s!m-XEBppr^AZG}R@q 4F@@@@h    4F@@@@h: >dqKXL.
+tHXk<X	6.L|Y6:`N,(wv >n | 4u&7T|A)Gw	{R)msb:gTRm`5"Fwc\6`H:B?
+ FbI ^{ /F TP"@itbHF f7K1(ep*hcj{D8YVvIXmR@B ;"5B tE  4F@@@@h    4F@@@@h~ }
+_5/ vi&1'k=$Vv#&<uvJ$g$E> Ux#AYu]H
+[1THez%<%$H}'@.\	3HJ}BG(..."u% 4	 N!  u6 h	vi *  4F@@@@h    4`gC5/. k PBrkP;h m0EZkeFs9 FWi tS h4 ?rvV*{g 7Ky0hme,x"s|`m3
+	N`#y@W%mNiTmN+s9%:FtKa%1KwRay{#AJ13Bmv\i=Xu3R&4)-<4xqHCokD/TFS\?F( ( ( ( h4F( ( ( h4@ z n
+ $ <XCr?
+}vC%w:Cw v( 9_a?Tbg.PB%:;L/\/V?c<`-^QoL.  Dj{$T +5oAI.H+@cN@h 4| <TKPo2,'C<2AN@9^@i/1@.^~J*:*}JYx.9X
+;5 ,9;z
+C&_z#X!ZNw|WdZ$Z%>(" w@-P|\tB+;h4
+ 
+ 
+ 
+ F    h4
+ 
+ 
+ 
+ F? W?Sw]> <aQ -6 P[ gp*tH|fb)`C O}`Pgo\9qT`L81Wbq/	HWb ZLQG{e[/'/	LQ"F
+ :-y%XcA}~on3(~AX@lPM
+or2Pg L17A)?!9yIHUf`6ThsbP,hL$
+%6]w j0Bm(c]8Xy5nh4F( ( ( ( h4FnJ& f~8W`\gXVxAK - /fm3>fp94ys7W*;=vO2n!|HIuJk/!z8_5xL
+D5	OQmW<8!\L;Z8H5hA}Tt(Ii&Kcn?TA?FNx~wya:m~y Y_	j5z.@]>o0HrV1f&XZ}\|{:XhLKcPBL> f<mui~.Pc>DvUPN7l46*T<Xq&-h4    F    h4
+ 
+ 
+ 
+ F(LykZZ,[}:QS>\bq	Z1O  sA\(/3fk{v*T=TYc{OB^n6-	iCP-/tDw$zV9fTi+J7dOE3JMr{R*[E4vs>&U2p@z$@{I_jZGYLWRPRa.r p^b#])T}"Amc;
+VSPQ{^A~YrfTn&0NLd\cJ:N3<\dLE"!S'r5A@Qc^1W4F@@@h4
+ 
+ 
+ FQ P P h4E31sx%M&Aiz8'$N$?s&ter,kFJ;zf$`L|CK)SCPOfxq! FoMWh<[AsWI,>V/(6pyh+iCqN4{{C:mKh45{Upses&T^_
+4#X"'R,LgKgrxH\>OtMJ'
+jAu2*/  n}W@?z}7g4m?hbnR-= VH,?,<RDVz_:b[s!ta\R h4    FQ P P h4Fh9
+VUk;=ER}varRG~u$9m4'=iG4#P@d<b
+j	8Xw^>)n6L@L4 r7,(:[0	-D3Rz}!l]x~uFRi.INU5=aaJ)Ae$aH#XbH4\X )u66 =ju.d#4pdAd;{TJ=4C-yKoOh4   F( ( ( h4F@@@h'
+~d+Ts{CW]P`-b:_)Hq? 9[MW?o"}iA)wMn%|-h2)nEkF8p~q >,K@h    4F@@@h4
+ 
+ 
+ Fh4Fh4Fh4Fh4Fh4Fh4Fh4Fh4Fh4Fh4Fh4Fh4Fh4Fh4Fh4Fh4Fh4Fh4Fh4Fh4Fh4Fh4 A    IENDB`
\ No newline at end of file
diff -Naur a/packages/apps/WFD/proguard-project.txt b/packages/apps/WFD/proguard-project.txt
--- a/packages/apps/WFD/proguard-project.txt	1969-12-31 19:00:00.000000000 -0500
+++ b/packages/apps/WFD/proguard-project.txt	2013-08-14 04:13:30.000000000 -0400
@@ -0,0 +1,20 @@
+# To enable ProGuard in your project, edit project.properties
+# to define the proguard.config property as described in that file.
+#
+# Add project specific ProGuard rules here.
+# By default, the flags in this file are appended to flags specified
+# in ${sdk.dir}/tools/proguard/proguard-android.txt
+# You can edit the include path and order by changing the ProGuard
+# include property in project.properties.
+#
+# For more details, see
+#   http://developer.android.com/guide/developing/tools/proguard.html
+
+# Add any project specific keep options here:
+
+# If your project uses WebView with JS, uncomment the following
+# and specify the fully qualified class name to the JavaScript interface
+# class:
+#-keepclassmembers class fqcn.of.javascript.interface.for.webview {
+#   public *;
+#}
diff -Naur a/packages/apps/WFD/.project b/packages/apps/WFD/.project
--- a/packages/apps/WFD/.project	1969-12-31 19:00:00.000000000 -0500
+++ b/packages/apps/WFD/.project	2013-08-14 04:13:30.000000000 -0400
@@ -0,0 +1,33 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<projectDescription>
+	<name>WFD</name>
+	<comment></comment>
+	<projects>
+	</projects>
+	<buildSpec>
+		<buildCommand>
+			<name>com.android.ide.eclipse.adt.ResourceManagerBuilder</name>
+			<arguments>
+			</arguments>
+		</buildCommand>
+		<buildCommand>
+			<name>com.android.ide.eclipse.adt.PreCompilerBuilder</name>
+			<arguments>
+			</arguments>
+		</buildCommand>
+		<buildCommand>
+			<name>org.eclipse.jdt.core.javabuilder</name>
+			<arguments>
+			</arguments>
+		</buildCommand>
+		<buildCommand>
+			<name>com.android.ide.eclipse.adt.ApkBuilder</name>
+			<arguments>
+			</arguments>
+		</buildCommand>
+	</buildSpec>
+	<natures>
+		<nature>com.android.ide.eclipse.adt.AndroidNature</nature>
+		<nature>org.eclipse.jdt.core.javanature</nature>
+	</natures>
+</projectDescription>
diff -Naur a/packages/apps/WFD/project.properties b/packages/apps/WFD/project.properties
--- a/packages/apps/WFD/project.properties	1969-12-31 19:00:00.000000000 -0500
+++ b/packages/apps/WFD/project.properties	2013-08-14 04:13:30.000000000 -0400
@@ -0,0 +1,14 @@
+# This file is automatically generated by Android Tools.
+# Do not modify this file -- YOUR CHANGES WILL BE ERASED!
+#
+# This file must be checked in Version Control Systems.
+#
+# To customize properties used by the Ant build system edit
+# "ant.properties", and override values to adapt the script to your
+# project structure.
+#
+# To enable ProGuard to shrink and obfuscate your code, uncomment this (available properties: sdk.dir, user.home):
+#proguard.config=${sdk.dir}/tools/proguard/proguard-android.txt:proguard-project.txt
+
+# Project target.
+target=android-17
diff -Naur a/packages/apps/WFD/res/drawable-hdpi/ic_launcher.png b/packages/apps/WFD/res/drawable-hdpi/ic_launcher.png
--- a/packages/apps/WFD/res/drawable-hdpi/ic_launcher.png	1969-12-31 19:00:00.000000000 -0500
+++ b/packages/apps/WFD/res/drawable-hdpi/ic_launcher.png	2013-08-14 04:13:30.000000000 -0400
@@ -0,0 +1,42 @@
+PNG
+
+   IHDR   H   H   UG  IDATxTUM&L2M^*MDD@TTH;Hol 5DFcI4{)rfEc2"os=>ammmCu'g7!b^
+6?6s9#Y:EoyC6d-C$Zlfa{u MMs>63|4kg}>oIHUF{-{,0|w  CHQ^,F#]A?rS.48 {sH FK\=&^U&}Ew	=AADuw_Gc1w#e.$<WVo1}^-i}w|o{/{	!{1$*3#x'z|]wg/jkSY!}#UK=>t&'\H)Q	]H9)x0}]]-eoCU=/j}>A,B
+h<F8P9j$HK /M=.d|=7^;Z_hzr!	FwO]$:"H%Li Ub<x@
+tY8=$l>.ZcIsn![u;o:Jz.!o pixB*nRz]'W)D<bs#<trW!@h;b52WY/za|iGn!;{2bi6R#gyqaB\@8Y@zq/>=l1_\<fq!WIFvk,h?el_>Q7	JS|0p?{p>])ttn^N>Xrvj[!Z{"gsNp1OJaWEv`~_8{q?7]4-W$x}_ pQ{hp}}	}?M;s </?TOba6?'s|h){~b`<4lJq"8XuA{ID-*jr/nSk	-'}_~lf~;f`=zA?[.NXwOLDQq.~?*6kl4eu6q~t`^J-g`Gl@m`u
+Wz>UW\I5g&cIXy+~,xZX~$GF,\oN#>Y_P~^^Iz1O8p_s9cg@mP/PW@Kc9GXsrVg6Xv1G^3,e/PeQ+A)IzTlS^ 8jc,y+[RXQ;a''2XP>5`hXK0neou][Q>eeHizEq{f4?:pZv`%{6E3
+s`AbIaE >,PF+ja Nv0mE*mR2Z5Pqwa*+ @_q#y!Z5B~cZ$AXbwf,,Tbi!0kC
+:C:BN&qI]fo/K3v1&=E9NXBbo%>@].I<gQL=,qjrmzu;hT>#cgBga:fg&2 i%SL9H9[0oBROZH]U.xF*]Amd|uiWNr?u;]TA?7A2}o/.jp=X\^z}rr+d4!g.=Tm1EM,H]S~),O^Vwwz(pu_BC$^8!~{Yy%Hpi3%T#Tnkt!gt%w;pl~\^KI2MUuhKf~FpH%O3BsMGYL	n0Sg0i?y}Vf#)pSc?XO$p 
+iz
+~h;l%xgXLK*[4}I-]~1jVhk$o].BfPNs]ln)[-Z2`8{(M6@P7 a4s5awX~C`4>d>_sbb^p<$"H6j^vBu/MP<rkj#dP{VkIF6UM$Ab3BL9%TmgzG-KKvu*9q;Y_WW<l\DnBg]q)u3,"M-WGp 'AY?TzJm@&zzt:X9e_2P;4GI5>0UrveNa4+6RESBk LS}ZD5eZ{ fu#sZ6Zh#{R`t,,D`<+; XN~_
+;Abc$K@; 3 bs([ASO+lsY\x6_^Hr]Wh+a/@8af6'?a*"Q(D@O}g`}KQYcBsz<e\PYJ&r	PuuW
+d'.v^X|	RqH&XlEz]4mwKxj{RHVL 9m%tH=)@x&SyG)Bm|:0i^{VPLPiS'h5c_){\N	3Kiy+YMg]e /t\pt3p*t=&\pqy|s@9R``t>[`n;S20AP#4;RhA 3c*4^&s\AERg7MB/3
+,tk4Pq&t><^l9-8[f#-|VsKk[!S ?Yw/NlAc2<S_Z
+YA-SE
+}4"@X+Y
+$7=9(uz(s"%kTc`Jjt!{'1M
+M=}XCPO:_PR-Z(\u%^-Cse/Yj2@L?PzJj|RPS R/z\gpTE"aAH#F
+my?'7!gAv_ /r34 Q tjWJ:R1ppFfDw=$@KD$k!Y $(WfV~'I))gpTERzCpARLn7xNRslaHCF (e%)R1@se z^.4W<glW|Q%iI .c}NxJ
+jU~SR&}2'#Dw-0rZ,HrD`
+7nPHsVWlE
+R/
+Q&*;3 #_i$c*FQWCR*5HG"?h*H^nubg!8Z^{ .Fp1;nr}ZH(	R@PJIA3jh{??Sb/^xVDpjjHUG  DgQbu(Y~7LnA"ywym4d)'NF__{qn!( _Bu
+uO| i K /yzS$U#@
+;oJGuZcL=Mj 	MX#zL8r ~]WwoQx#T.JG^Y4<CMxx-YC`qeT'{%8(I2ZYGXK@X?`N-YJZd2 R[&X\kJ
+9CyuT/Gh!brq	ub~Y|2t
+5D"q{?IYPPjGydG
+ixdqf> -"@tTYBP5jq:7p]@K-wm teiSPanR
+	8R'N9$[AL]7SOL`;7U#p%V'TBVAxx:aH!' [4T+x%w|4B2YQSFTyf+*$9 -gPPcuwG3E .RXK*TV4 H6,% VgH?pa7g.]=UDROB y;z$x(lfd0xaD`#m>TftXaIJ/> 1$S 4i>,~KbZB<K3@v D
+hPTJk qsd@
+TD&eBha[g>^EPO|22+p		"?$p(_C
+z~k*"!@,QEB3Dd/W1sZRa$}ws{%v):eLZL	 QVdi ov_X?$u\~
+!YDPb-K9
+,($bil&@Xf
+]>(;$Vn_J*XL]YH6{FJ1Z>[	3Tf,bC+ @mb/gOvD!(]A TYL]qEyhunLWhnzm.k>hI&Zu
+p0H	7XgY&,*!9%%@1z3~Ji 31iI9
+*:_7eFH Y! pvdcHV/Ud_l:ZgZ56M0;Z%/0rP(Yv9}Yf}
+	3 C*b?(8u4gSfH(&}}8Jc1#D!(M	2,DQ Y#p2k7M&xXV/LkhJs*0OTg[?Lf9_#=H8va}UEMqI_HDFU[>RDYX_@DpnErk/T U,A=rzlFCz nvB<aT2LTs2^c+V)$Yw.'M6"nZS5h[]HcxFQ#PT 2ib" ';H_b^Rn~g]bP,t,y]SJ!HE*)a\*0_%b=- ~|d#7}hQafr-Sg6 `9DB4k:0p"q5ovC@$TIY"u\sJW?qMuTVb]s\h+5Fb	hbpiFr!j)j>ORRgSzS$TXafz\P/:2SBA|+\l ;/M?YtuDX"	jgV#IH2E!)5HFZ-vHoGF29"^[jG$O<s!w;k
+XFQKPCX)xR] rCz4dPGf|~7_(Z < {l*	N3:*o4-t#xm8f,+3R@HJ)|&jUq+n$qET_l0?@)~]y;WQ8n}J0}WYnUr#9&z|s8|00K3a>X{Eh:Vvq8,]F}4&Li	jU$VKC.X2p3G}\Fq$#"OpsxGOhWf
+a?s4k wWN/,)`n|0+r,&L]V8'3c;I;fqBL=Jfq-l( E+"@VE(C9n2]F7smd43B1+B0}8+X4UU_E/TIf(vd<R0;RSa1 
+Kr4qP=ci9;RqJKToxDJxq@gf)Q#XY3iJUOV#G7MfvC`1dn*7)dI54.Re#Th UA`2<TxW_-a/fFHXAVa^*_YC[hhnzSE	nijgd_-Iy*|hZ(AXV$>9=HE}ls|oAFST^oBs.@Ud$)%1zlM<)jg.KqsMQ-17e[NF;)p: ;J[w]06Tk|REnn>KIs*23/.#($T+4h{Gg
+*o'l(QbS8mmm7\'    IENDB`
\ No newline at end of file
diff -Naur a/packages/apps/WFD/res/drawable-ldpi/ic_launcher.png b/packages/apps/WFD/res/drawable-ldpi/ic_launcher.png
--- a/packages/apps/WFD/res/drawable-ldpi/ic_launcher.png	1969-12-31 19:00:00.000000000 -0500
+++ b/packages/apps/WFD/res/drawable-ldpi/ic_launcher.png	2013-08-14 04:13:30.000000000 -0400
@@ -0,0 +1,12 @@
+PNG
+
+   IHDR   $   $      	IDATxyPTW12,SfI\)}ieqCEQ i}kiQYZEcLY'jf$!lvXL&5Tuss{oNT~`0E@mE  TpF\jJf?`o7n-h	<cR(_)=fxd9d'78?3Wu7$1oF]6wGL:` 0Jygw_Q`C#:#(RC<
+	_tN8xk8*;0]y_HH Bqa6#>8vcN29:+s0;	c~4[=fQ.HfoVuu;|?g!Bu8`N}{8~g=}h3(nE~	iR~;}4`6ha/o$~8=j/byK(;Vpa}.yO^>s.Y5hlGF;-kY@yj)J"iDK!}r^?w<L iWw(n~'M(9&DemADMUTg-P'iS"HX|qp{7~~KsZ>|k#6P\{UKUXXeNO;{p~:ClhDp+l@r&u\5Zy5:5}hM;u+Z.hV`6 4CN	\gE*+ek]} [-d4p,qqWf#O['Pve'[;(:,$27En	H"4:0,529lbo@gBe5
+4:6RhtK?H`rulOtxmVkd6-#"`ZXP?h:i"q\)x/AIeS 0d{\8=7C"D
+60=P8+a#( 2&U,5QLL	>+kf0.4E-f?lWptv'*Kquj5Be-!b L$(['q>Kc~,~vFx&>dQ!>o06>ZIU>Agw=#Jb1H[Be0AF=P>O|;S{]pr5<#q%kLF>A}2H|v
+#?DILqGb.{~"syfZ%*vI0~HHu7zM@,1
+&yr`2jy9
+'ULYB8~IJX^HI=B@tlQ "7r0xmJKTI! "Y75"$;cjzB %1S DHdJL!:O=T%J1tdi7p$LjZRa2},qxF~@#CkQ  1B$,ves$J+]Du#YV1-VW3r-o
+_Y<\-e/1bsmp(jlh||G;k&5'gD<H<3KnLDRIN6"+%PLr*@zkBtI\I@)1	eI\s4DqZ'`<K8IJ2V<	P# |r- g@ GXy=*D*lc	qJHV"|%\K*O$8$D@wV_H]tyb"Fd9DKJC@!Vyu4oWdvnd1<?Y~n/cw(gXu):w&^J,E!4[Ke/@;Us73$6*2&$m6f9
+"RR=n{'0M G8G}aA;s$&#qEVT
+NzD-/Hi;NX=Ph{_D[fs2    IENDB`
\ No newline at end of file
diff -Naur a/packages/apps/WFD/res/drawable-mdpi/ic_launcher.png b/packages/apps/WFD/res/drawable-mdpi/ic_launcher.png
--- a/packages/apps/WFD/res/drawable-mdpi/ic_launcher.png	1969-12-31 19:00:00.000000000 -0500
+++ b/packages/apps/WFD/res/drawable-mdpi/ic_launcher.png	2013-08-14 04:13:30.000000000 -0400
@@ -0,0 +1,16 @@
+PNG
+
+   IHDR   0   0   W  IDATxZTTw&ulI6QL104jHDADDHa CPbC1bhDCJo{&'1H'ro=73wwW[ynT:='>oO
+k|^_  }Qc|av}j{&Z2YX@9F5-.T=Tu9iH^W gzv*j3,<2i1|1waGI!d6#{HQA_9d>p}EtnIO{~2!w9,owG6zI*bmV^'}UbBA$.82\]W9SpI"+0XxQda
+]Z| !f3{3`2"n'X,>QCYzN
+"
+GMQWj./+x)j8vF=p7*|4{a;>8s+!|pN^=dmf?(_[[+6wWGUgn2:_}.se	v|-3;r(.AV.S"h}"u{pLEt_a5l]sSZ@@aSl7T~mY.~x	SG[NS1#ZAT]YY`kznO,J?14oTY(zHmEdi>T;`C#&h:aF |'>,9yQe{QC"VmjDVg<s+!=g Wk5}+1QObYU#M LP	'Sz+~>"Sfm$Vi]Pc|A<XYwW&Ku_rj?k@Y[$g$/lTQ1y[d]FPth@"HkE^k .i0L0A[gGA'v,&r6Z>~l#lA~i}}*CVeM8aw`dthM*4$7_u}&vom,|%xFb(;rDdN9Nc~%hVd6wM6];bLZ7C:o3G2'\pF9GtcsQ;`Nr2FnC}* V{=A	HS&PZLz>D>9=&)sp.wW{HY+5DNC;U'[&U^IJT>4^-UCrN@GpZIkN{NyMPjHn	
+ztQCmhn2Gj#.STub.cTs5jDVn	t?Q4h!"!#v$Y'bt od,.=4'_nT14zK'Fm$I>Z!PNUF3>qyv[$7zYD^`yK2EL	FQ )h?=8^`8}i;jv$iP
+mbB{w5eI{x#fo<*}N^$
+QH^0&XyKik!{6Gk7t[[ %G9D-'U*nA[^zl}/(6%0!$jd6+"2hN,gD;wnrGh7#BRS`4#V:T]dHO@OOswT&Y\><d"	qVZ[8Yrx+Dj1{wdtwBa}	K@d	Pvf*D/^k/3v|Fpqg_(Y.mzs[!Bl;q#Q-DT+Lx }6)}b{<U'J`~O#:;K"i2J}_r9sJ:]@Q$myN!z?S;;<*4&n3lyRgB}7=7J+A&0JI	lfAQds
+}H`1=?qfZ	i_Pc)	,Q@ $>]hO		0v^cR"L	tme	<&G&fdU=Na9Xy=G7\8K ,GH0D$/{HN/On3M@*>yO*fMnQu j*<_F7pf2Ky+z=FI+WDF,od AvD7Uj(
+uBJrMJuP7rDkOo$+f[8D 4tQG;n5YcMLx"3bE8oG^IJ/VtQksNlewj/JA&
+#t.|_td&G ,#Tnx,%R/cS*RdOVnjavo*EHH"R!=:y=QQX<M'*1,rffrzhvT
+T4)*<Icg1Zl RP_'4/e:k6@l)bDq Pn2sc}"6Pc'Z/j+FT|!d%yRIvCT!*P|&Pj|((Y64Ix@ob[XbW-eTYSyt50	pC6nB8.&ke5/
+)tE;cYjg._g,IL*l;7Im^f+aM4tkEa*-:6k>*sW?lwf8aq,}	n0Y_CX:MPK,W{?g:<&b{M.bK#yT.vC^fbocC.k2+c?)0Pb`D&5!& /y_B@~W)R4SBI%^,
+4eJ2,XEd> /wPflrede2l70<$e!sWIVui&B/eMb'7?xN#    IENDB`
\ No newline at end of file
diff -Naur a/packages/apps/WFD/res/drawable-xhdpi/ic_launcher.png b/packages/apps/WFD/res/drawable-xhdpi/ic_launcher.png
--- a/packages/apps/WFD/res/drawable-xhdpi/ic_launcher.png	1969-12-31 19:00:00.000000000 -0500
+++ b/packages/apps/WFD/res/drawable-xhdpi/ic_launcher.png	2013-08-14 04:13:30.000000000 -0400
@@ -0,0 +1,78 @@
+PNG
+
+   IHDR   `   `   w8  4IDATx|TgvW !M\ $!M @-C =3$ot-~N'$3s#&?n7 x
+~pG{bO'y~{VWqmVFJ0?,Xrr@>={8s_j515kJ|m^(za-_~(|vetl3~0sjY(xUt` !F7~=s{P:s.3+yOoQ{Q+[`a6u0QoE@2&l]CShv{f@1AXs=tiZ<T]I|>}:k5}[EKV-AJ PgPJ?hCGPt>B;6	y72HI=(l[l<8SIIz{oTT2_'e]&7k{>~\aD>OzhERIELxPg:>|z=wZSw[k/s}'URGS]s7=]|Cr)@B<,>d 	'>Nph{8,pp<q}w{[zbKu+"z"aOy<i]i#51$YS0 30^{MwRv<p|HJ]c/[,>[d/CPx
+K'~BO	p9NAO@[?p4  OvG`;7]0?d=ctet)7!a(iCOAQw ~^}bD P9hia><x@<p! /n=ailn	/Y.=pwwsfm :z~ ^/y5AoO^ E{P0z90U|<BL?pa /!g=leZ! sXv
+R;~hlh?"	.B=TW!;zb^sMecDL+v	Gp48N=Oal9^U,`Y3X|R={:jWkL;'KTu5HN^$>E5N@IQ(nsEEc<<v8>*{z!wylg:l+[SgT
+TVQ82B 5~q1p
+@FSt8gI cC"bg1(>p.z4Xy7:TjMdz{R',j7w?tJ8}?EE`\>_#(?Q`Hc'ap?J |_v	`:K|8x
+6fKZ@ZMl>YYg4i*:4E;~Vag-8>uIAC s _?Cp?=`OzX^t3r<~~qt2:wC@RM*EI&^R[.]>&H?0?fgGFl0OI1D|Sb$~(} <ao+&pj-;qu)toZPF*5CiMK-~GG<v4i77(B}ne31xOvOqwzLraqPai0x5uBKi XNk	F/\^}NgYvl=^jk.Yx*itQr[obNwCzvE'
+gQxGz{X~z,=aY-`!sz*n._?	c|+4kM` 4)	ekhjn)Xsq:h&4sO]&emcl
+3[#ua-,9n CAS]C"^+~.T.~m*Yq8TfN _s1mEYu^v@D3C3MA5c+b590ZhPp+3vN$,:jG,'\c];}4mCCufT-3Z R2hWwDE9tj	B`Nd]rDh,9vaDA`Y-%2L1Na?ADTc[B`{vacYbe:PDJ@^&5*	^O%5l-mwg*1`c
+'T2D(fb<?0x"<I9&P|}FN#@S%PPi@N+yR'q?wo9b^p5v~}}aA{Fb\#fF0#,#B3g:1a5C7z<:^_k	Uz: HCQ<?]9zghG[g-z,;g]]w}`rD;Dq14SF&Nxj=w|o_t>zBn2*B|<-Im=&K'	}k0~#z 9@;7];:Rus'1=g>& 
+K#B
+n)"') 
+=:kc2BN
+p JxDOZk$!'* -;gW 9 mY:;.M7 %Pj|roANe*-t*^moX{aYk3 vpz>c={XmC#b3^.tR`1mz=
+|"ZUg/ @v
+41JJO[:I#rQ?
+A[w&d:I>lww,;kHnsJ{(	} -(|zr$3ol}&!ov5[^=(J2]5@}F"#&|Qiktwa35 ]R4 Rbg(|qf?^1{{=9
+K]CwS.ZPmQT]_`c)R^$|{XiYGN#nW-N,U@y/HaaM"(gO=tTS{i)`*>2"^
+|%(P25Hzl YhmM:RI5ZP	EZxp'Y9%j2I,q`vq:,1w"]Ps&{x~+unK-x-lxB_}v }u7^xk/8k/<wQkFr{T%p[Z7[WYj+m5k|>?q?/ _||1|#xO)>	E70~Oz?} >
+_k=>_80-8Nh9?I[LWRUb
+{XgbAe)SAS;fK{wVbP$]t{;	47AQIuCr[vji<-l?l7P2_xp7A$)`2Lx0q
+mec_g}	\q`=*17EB]*5
+.eSew*CjP@$O`4Q1@96QN"5M`J[Kh-P	U#Zj7\;?5;uCsRm|
+EZ8b-nb:N*HK?t]7|r:#];ui9`dgj<o/;<fmO}gl@s7v@]7`@z6]gK?hNv;!/AvHXHd{Nd2]Px4vq'%-YFUb&hb+ U*X ~# v||6U<L,TIQ4m74(Ry2OfFNH}[|pJ<6mmta;]U!o1rL+2?`s[@^sc)t42Z73B7a&/8WU+CR2Dp 8{*2q[,j{TeZPCy
+z qRJh7k*E`PEhTBZ9eHSBSML*q_6dAuj:yfav(Z*jCfaGE+JZLwQYal={]j mgmf
+f#K$bUz842)X &N2#Akca" 0z SDGH[1 LT/+#*G@ 3fKT&e/i,6\X*_LBSXdRY#sz'o&#J= if%:BeE	O#b-E
+1u6BBD) E 0 4we` .E QS)f QYP P|`T a,"^E v[5PPuEa0 Xfm63DoZm{aFm6.7"N2M(r-^/t:2
+1iVT*D(C`,d:T"W_r`pj" (C h_WPV^@b"9txF$	691L(TTBj$DTw]y,mk`t8za<~v(]a_n)mXbR3[x(q*8p   Reb\1 .ye*Dvj97`ZW(A tA?!(/Wf',[2 V~:=>Y"=daQ^/fj:83$C*Uc3;T .oGOnf ^sK`Da4*P|W/&L?lP|" '4?Lv(O[L!VT#J
+D i^T5t\%_ &*N5#8)k0>eFD	+Y$0ow@ 	]c=|h9JKEB  @@:d	L/)yL'O^V2Y } fZ2 
+ *3-hz`
+NmjS~H(]FAe(XABSBy(NGL&A@>	?^T@;R.9V>a` $	50j46AH7#Q8& zt eb%9D?b|NEqf+qT05  :|_"p9x>9ME' h>\}vve@P<EKW:)K0 d
+M'Ex?9d Q@OM"D e-19V^;;"ca1QSiiI+0ANm1ztC1VX_rz!Y~ {a E;" 7e4RJe4vt8=+
+Wm	ukr S8=,Y%D/rb^6j!PDH}Z;B2'RV '59O?5`5C\r @Ab)~	?E<Tf8G&x>;Sh
+_T ay7w]G-\cK (> dQ
+`>#\O"mZ IYE=4F:,`{CY[0Xy~	`tb##KWG6Xp4>
+ru"Rm%,SE tE-f
+ @
+YBJa kc1^EzF$ ilye0jzDX5pAF,r%yx@a&rn"r l%!	?%!^Wv@, |UFG   E%tUdHoV5iro TnQB')5 
+%:(SQ|!Q %ye8#LI	"aFH44w>ACu:lJ}+F*lax( |CT	XL PmqF,EKpU
+LoG   C#@6UO~`AmkGr ,V3bS<Dha S1Y,P~)>-,z,X)feYpe*H*e(6BXX### $k0B&Py	 7q,@'&F" \?~#;bc?h[\INc +bL]9KNiA>[Ji|o8we?[M5|uU0mepQLEc@/_ q`JT0p!k$WCL8b " eNj"~v
+&OZ
+ABe,1@6"c( Zj<Ybm}|L?
+~FW6^1=~'Ei`y79epa~D(<{,ul;'0(8Tr!P|? P%B \5viR\7cFO]BhSdf Udc"(C2y$4 sHD6T8Zd>x'X<33=
+ jyHEIIUP$jR2L. / 4"<fHu [ew)w`'A  k!LxaVMY?
++=4DE7 0BS~Gd/c:b})VCc'wT Q`
+ Mn,F J4Y!'~r.i5fHmP/D:?wrG   h zz3*$)l 
+GP tBd&S1Y*G K] rAnnI\JW ?BDI9(~ X|ND ~ 8tFc>f%A_C$f-D @~  	fi)B Sbhc=X  rSx| M  m<zjS0h403H_/U~nT4Q xjX |M`.wU ClVU6r-Ba /P
+U 1  !p 	 @R&0\-J@ >Ra/@p.ANWl3B,k_  8xNeoGhc''^j Y@X N0C Xb d>WbR,UbW e+l*  d_H zT]:u)@.{\&y<")s*3)9-mE  z8/PB  <%&YDRfX B l 1 Y 9 !ZO]]0 & [nb4R"
+is * HG  H;)@b8wm6/{~tO$D iu\HB. ELd#@^r  j5,u_ ICL]KNk^I<UAx4:z)	HDW@Tva}ud<I|5 x& Dsq
+,.<y#
+tj#Hk+^6kb[,V_O}sI&iNzFp Szh5;F
+*OSP-1r/M$MqXl,'Qq7Y MC%VK]T x*Yj,YK^gCspT4&O\VQ !lhxe,niJ$(_NkTu>]XnvFTJ Di7BWVM} (,9X@OVRd(^6,-9sd3 0D@7*)'CtYTgc^_Zx->~hh pq({	hJ[H,N$	lfNrU?B|P0JAH\t3]mGg4Q	eg1{R]?{|'/!J[BlM:8]OV=cT(`6&5YLJRW~Vh
+a(
+J \V4_fanc"?@rO)!S!$[@B R*l!L4rhw`gBTN`Vc}
+;.X)4k[|NG>
+1J.hy[&m${UBmK#CnwFQbj9v;8!<dI++6t5 Ev0oIdhy2lz<6$! f\H $[N3VJ6:vf8ZTiFd,^fsgY+9Y}NuYB+/CB#@v%fm)|b)9e2,$0aV<LQ`9<1IaR yLr5P ZN,SWWEG
+GUa9F=X}F^EyaChQb(_ Ev;+BnU|t,_3[a
+8Ka'&xjV.1'L?1 1k:!~g;5=r,iMwg8C:XdE_ ^I#\	e lgIKALd3#\$>JgK$:@R)$N\{0c3[^1	W&k*#IuLhM@,Klg`' 1_f!mveBt	;P"8%d#0sj	8R	b5H,GA`c ZQ*o 49@k(HnPx($KH`jE;r9$TG>E6CT*	*KsOT1*(
++c7Q_lIS#1r[$@^mLiWHAT"Pc@ZRz9ZdkAk%XzZ:J51y(>O-e4AF\$Bb.iAf3u}7?JWaa)
+e<QiYoV`zC?kCaY#bf4@fdCv	,!
+bYVg)Xnq&]hDGS5e(	HSlP\E1Fw*mfQc.o YvfK8&:ifO9yCs67ksV7mq~+3H*bz#5s5]q?$n	:sD;U : , z:d9"&kI<o.{/*0V1'a'~+3ix!Yjv	eq|.?o&!zlq`V4oqpT<.Fg/d78_m]ku~!d:b:C%c!zn
+'	>:tw&C+o^
+D9^qG!B
+Lc813g	M{I[gXab\e2-|ZRy3O@p'23&xuuFqodw Be^wR'g8FLo[t~<M"%*V\hO0r\Z``a*\zXML
+u'_E27Bp)aV$! $CX88HPTGudE=Q/iIi($L;(y:{
+-Oxk5.v*"%gG1{
+N$H`DN`Emh1mwlM^`7JC$p
+J
+=r 7d!\J!PBr_xI[8Ob72P} D[@\/Qh`'.!S5\
+OB,&C{	|5v 7j @2Y*\OA^,	6S(Wuzum31p"M/>QV3F6 VYHjY)#9Kt$3Be b*Q'y'O|dC@&_h__<jr<X#KM}r^QlD3krX0}DKQMTE 
+x*z''pq3~2!!!0
+AS 
+[iYcL*&{k,VT&kLW`#2C3FL<b%(TId+)IAJ6z13XTR b4,P).AJe 0QPfE3X(YOzK2Hed"v(TPT#')b:0^!@grTa	K?Imv3=#HU*y>F
+Wq(KiS_}#N)Y$_?'(]i_AHGkBlk2T_Yz5R\xIy
+m|Etr-:N5}AB 5MMxZ,,RW^_4l`VMV;*nv*~I1[y#i\c38[rvBI6tR-\6NpKG"rLKV%ga|M^+V/ej
+:y9t`?.xZm)2_g3qC"$5! U1$K4"hqL\LM^Z=U?)}XYm^R=%=6\<RCW!&9"'?'B2K(usu\"vYG._?nq {    IENDB`
\ No newline at end of file
diff -Naur a/packages/apps/WFD/res/layout/activity_main.xml b/packages/apps/WFD/res/layout/activity_main.xml
--- a/packages/apps/WFD/res/layout/activity_main.xml	1969-12-31 19:00:00.000000000 -0500
+++ b/packages/apps/WFD/res/layout/activity_main.xml	2013-08-14 04:13:30.000000000 -0400
@@ -0,0 +1,82 @@
+<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
+    xmlns:tools="http://schemas.android.com/tools"
+    android:layout_width="match_parent"
+    android:layout_height="match_parent"
+    android:orientation="vertical"
+    android:gravity="center_horizontal"
+    tools:context=".MainActivity" >
+
+    <LinearLayout
+        android:orientation="horizontal"
+        android:layout_width="match_parent"
+        android:layout_height="wrap_content"
+        android:layout_margin="10dip"
+        >
+
+        <RadioGroup
+            android:id="@+id/radioGroup"
+            android:layout_width="fill_parent"
+            android:layout_height="wrap_content"
+            android:orientation="horizontal"
+            android:gravity="center_horizontal"
+            >
+
+        <RadioButton
+            android:id="@+id/radioButton1"
+            android:layout_width="wrap_content"
+            android:layout_height="wrap_content"
+            android:checked="true"
+            android:text="@string/lbl_Source" />
+
+        <RadioButton
+            android:id="@+id/radioButton2"
+            android:layout_width="wrap_content"
+            android:layout_height="wrap_content"
+            android:text="@string/lbl_Sink" />
+
+        </RadioGroup>
+
+    </LinearLayout>
+
+    <RatingBar
+        android:id="@+id/ratingBar1"
+        android:layout_width="wrap_content"
+        android:layout_height="wrap_content"
+        android:layout_margin="10dip"
+        android:stepSize="1" />
+
+    <AutoCompleteTextView
+        android:id="@+id/autoCompleteTextView1"
+        android:layout_width="wrap_content"
+        android:layout_height="wrap_content"
+        android:layout_margin="10dip"
+        android:ems="10"
+        android:inputType="number"
+        android:text="@string/lbl_IP" />
+
+    <EditText
+        android:id="@+id/editText1"
+        android:layout_width="wrap_content"
+        android:layout_height="wrap_content"
+        android:layout_above="@+id/button1"
+        android:layout_margin="10dip"
+        android:ems="10"
+        android:text="@string/lbl_Port"
+        android:inputType="number"
+        />
+
+    <Button
+        android:id="@+id/button1"
+        android:layout_width="wrap_content"
+        android:layout_height="wrap_content"
+        android:layout_margin="10dip"
+        android:text="@string/lbl_connect" />
+
+    <Button
+        android:id="@+id/button2"
+        android:layout_width="wrap_content"
+        android:layout_height="wrap_content"
+        android:layout_margin="10dip"
+        android:text="@string/lbl_killwfd" />
+
+</LinearLayout>
\ No newline at end of file
diff -Naur a/packages/apps/WFD/res/values/strings.xml b/packages/apps/WFD/res/values/strings.xml
--- a/packages/apps/WFD/res/values/strings.xml	1969-12-31 19:00:00.000000000 -0500
+++ b/packages/apps/WFD/res/values/strings.xml	2013-08-14 04:13:30.000000000 -0400
@@ -0,0 +1,14 @@
+<?xml version="1.0" encoding="utf-8"?>
+<resources>
+    <string name="app_name">WFD</string>
+
+    <string name="lbl_Source">Source</string>
+    <string name="lbl_Sink">Sink</string>
+    <string name="lbl_IP">(IP Address)</string>
+    <!-- 19000 = default port -->
+    <string name="lbl_Port">19000</string>
+    <string name="lbl_connect">connect</string>
+    <string name="lbl_killwfd">kill wfd</string>
+
+    <string name="err_no_ip">No Valid Networks. Try Connect a Network.</string>
+</resources>
\ No newline at end of file
diff -Naur a/packages/apps/WFD/res/values/styles.xml b/packages/apps/WFD/res/values/styles.xml
--- a/packages/apps/WFD/res/values/styles.xml	1969-12-31 19:00:00.000000000 -0500
+++ b/packages/apps/WFD/res/values/styles.xml	2013-08-14 04:13:30.000000000 -0400
@@ -0,0 +1,20 @@
+<resources>
+
+    <!--
+        Base application theme, dependent on API level. This theme is replaced
+        by AppBaseTheme from res/values-vXX/styles.xml on newer devices.
+    -->
+    <style name="AppBaseTheme" parent="android:Theme.Light">
+        <!--
+            Theme customizations available in newer API levels can go in
+            res/values-vXX/styles.xml, while customizations related to
+            backward-compatibility can go here.
+        -->
+    </style>
+
+    <!-- Application theme. -->
+    <style name="AppTheme" parent="AppBaseTheme">
+        <!-- All customizations that are NOT specific to a particular API-level can go here. -->
+    </style>
+
+</resources>
\ No newline at end of file
diff -Naur a/packages/apps/WFD/res/values-ja/strings.xml b/packages/apps/WFD/res/values-ja/strings.xml
--- a/packages/apps/WFD/res/values-ja/strings.xml	1969-12-31 19:00:00.000000000 -0500
+++ b/packages/apps/WFD/res/values-ja/strings.xml	2013-08-14 04:13:30.000000000 -0400
@@ -0,0 +1,4 @@
+<?xml version="1.0" encoding="utf-8"?>
+<resources>
+    <string name="err_no_ip"></string>
+</resources>
\ No newline at end of file
diff -Naur a/packages/apps/WFD/res/values-v11/styles.xml b/packages/apps/WFD/res/values-v11/styles.xml
--- a/packages/apps/WFD/res/values-v11/styles.xml	1969-12-31 19:00:00.000000000 -0500
+++ b/packages/apps/WFD/res/values-v11/styles.xml	2013-08-14 04:13:30.000000000 -0400
@@ -0,0 +1,11 @@
+<resources>
+
+    <!--
+        Base application theme for API 11+. This theme completely replaces
+        AppBaseTheme from res/values/styles.xml on API 11+ devices.
+    -->
+    <style name="AppBaseTheme" parent="android:Theme.Holo.Light">
+        <!-- API 11 theme customizations can go here. -->
+    </style>
+
+</resources>
\ No newline at end of file
diff -Naur a/packages/apps/WFD/res/values-v14/styles.xml b/packages/apps/WFD/res/values-v14/styles.xml
--- a/packages/apps/WFD/res/values-v14/styles.xml	1969-12-31 19:00:00.000000000 -0500
+++ b/packages/apps/WFD/res/values-v14/styles.xml	2013-08-14 04:13:30.000000000 -0400
@@ -0,0 +1,12 @@
+<resources>
+
+    <!--
+        Base application theme for API 14+. This theme completely replaces
+        AppBaseTheme from BOTH res/values/styles.xml and
+        res/values-v11/styles.xml on API 14+ devices.
+    -->
+    <style name="AppBaseTheme" parent="android:Theme.Holo.Light.DarkActionBar">
+        <!-- API 14 theme customizations can go here. -->
+    </style>
+
+</resources>
\ No newline at end of file
diff -Naur a/packages/apps/WFD/.settings/org.eclipse.core.resources.prefs b/packages/apps/WFD/.settings/org.eclipse.core.resources.prefs
--- a/packages/apps/WFD/.settings/org.eclipse.core.resources.prefs	1969-12-31 19:00:00.000000000 -0500
+++ b/packages/apps/WFD/.settings/org.eclipse.core.resources.prefs	2013-08-14 04:13:30.000000000 -0400
@@ -0,0 +1,2 @@
+eclipse.preferences.version=1
+encoding/<project>=UTF-8
diff -Naur a/packages/apps/WFD/src/com/example/wfd/MainActivity.java b/packages/apps/WFD/src/com/example/wfd/MainActivity.java
--- a/packages/apps/WFD/src/com/example/wfd/MainActivity.java	1969-12-31 19:00:00.000000000 -0500
+++ b/packages/apps/WFD/src/com/example/wfd/MainActivity.java	2013-08-14 04:13:30.000000000 -0400
@@ -0,0 +1,475 @@
+package com.example.wfd;
+
+import java.io.BufferedReader;
+import java.io.DataOutputStream;
+import java.io.IOException;
+import java.io.InputStreamReader;
+import java.net.Inet4Address;
+import java.net.InetAddress;
+import java.net.NetworkInterface;
+import java.net.SocketException;
+import java.util.ArrayList;
+import java.util.Enumeration;
+
+import android.os.Bundle;
+import android.app.Activity;
+import android.content.Context;
+import android.util.Log;
+import android.view.KeyEvent;
+import android.view.MotionEvent;
+import android.view.View;
+import android.view.View.OnClickListener;
+import android.view.View.OnKeyListener;
+import android.view.View.OnTouchListener;
+import android.view.inputmethod.InputMethodManager;
+import android.widget.AutoCompleteTextView;
+import android.widget.Button;
+import android.widget.EditText;
+import android.widget.RadioGroup;
+import android.widget.RatingBar;
+import android.widget.RatingBar.OnRatingBarChangeListener;
+import android.widget.Toast;
+
+public class MainActivity extends Activity {
+
+    /** log tag */
+    private static final String TAG = "WFD_App";
+
+    /**
+     * App exit on back key pressed
+     */
+    @Override
+    public void onBackPressed() {
+        super.onBackPressed();
+        System.exit(0);
+    }
+
+    @Override
+    protected void onCreate(Bundle savedInstanceState) {
+        super.onCreate(savedInstanceState);
+        setContentView(R.layout.activity_main);
+    }
+
+    @Override
+    protected void onResume() {
+        super.onResume();
+        init();
+    }
+
+    /**
+     * initialize app screen
+     */
+    private void init() {
+        initRadio();
+        setIPAddressToRatingBar();
+        initEditTexts();
+        initCmdButton();
+        initFinishButton();
+    }
+
+    /**
+     * Source or Sink
+     */
+    private enum MiraKind {
+        Source, Sink
+    }
+
+    /**
+     * Source or Sink
+     */
+    private MiraKind mMiraKind = MiraKind.Source;
+
+    /**
+     * Select Source or Sink by radio button
+     */
+    private void initRadio() {
+        RadioGroup radioGroup = (RadioGroup) findViewById(R.id.radioGroup);
+        radioGroup.setOnCheckedChangeListener(new RadioGroup.OnCheckedChangeListener() {
+            public void onCheckedChanged(RadioGroup group, int checkedId) {
+                switch (checkedId) {
+                case R.id.radioButton1:
+                    mMiraKind = MiraKind.Source;
+                    break;
+                case R.id.radioButton2:
+                    mMiraKind = MiraKind.Sink;
+                    break;
+                }
+
+                changeCmdButton();
+            }
+        });
+    }
+
+    /**
+     * android device has some IP addresses, Wi-Fi, Wi-Fi Direct created group, 3G, Eth,,,
+     */
+    private ArrayList<String> mIPAddress = null;
+
+    /**
+     * Select IP address by rating bar
+     */
+    private void setIPAddressToRatingBar() {
+        final RatingBar rb = (RatingBar) findViewById(R.id.ratingBar1);
+
+        // get ip address
+        mIPAddress = getLocalIPAddress();
+        if (mIPAddress == null || mIPAddress.size() == 0) {
+            Toast.makeText(this, R.string.err_no_ip, Toast.LENGTH_SHORT).show();
+            disableAll();
+            return;
+        }
+
+        // set stars as number of ip address
+        final int ips = mIPAddress.size();
+        rb.setNumStars(ips);
+        rb.setStepSize(1);
+
+        // select ip address
+        rb.setOnRatingBarChangeListener(new OnRatingBarChangeListener() {
+            @Override
+            public void onRatingChanged(RatingBar ratingBar, float rating, boolean fromUser) {
+                int r = (int) rating;
+                Log.d(TAG, "onRatingChanged() rating[" + r + "]");
+                if (r <= 0 || r > ips) {
+                    return;
+                }
+
+                // set ip to textbox
+                try {
+                    String ipaddr = mIPAddress.get(r - 1);
+                    setIPAddrToEdit(ipaddr);
+                } catch (ArrayIndexOutOfBoundsException e) {
+                    e.printStackTrace();
+                }
+            }
+        });
+
+        // reload when on touch star
+        rb.setOnTouchListener(new OnTouchListener() {
+            @Override
+            public boolean onTouch(View v, MotionEvent event) {
+                // select first ip
+                rb.setRating(0);
+                rb.setRating(1);
+                return false;
+            }
+        });
+
+        // select first ip
+        rb.setRating(1);
+    }
+
+    /**
+     * get ip address<br />
+     * interface up && !loopback && IPv4
+     */
+    private ArrayList<String> getLocalIPAddress() {
+        ArrayList<String> addrs = null;
+        try {
+            // device has some network interfaces
+            for (Enumeration<NetworkInterface> en = NetworkInterface.getNetworkInterfaces(); en.hasMoreElements();) {
+                NetworkInterface intf = en.nextElement();
+                if (!intf.isUp()) { // skip !up interface
+                    Log.d(TAG, "getLocalIPAddress() [" + intf.getDisplayName() + "] is not up");
+                    continue;
+                }
+
+                // a network interface has some addresses
+                for (Enumeration<InetAddress> enumIpAddr = intf.getInetAddresses(); enumIpAddr.hasMoreElements();) {
+                    InetAddress inetAddress = enumIpAddr.nextElement();
+                    if (inetAddress.isLoopbackAddress()) { // skip loopback address
+                        continue;
+                    }
+                    if (!(inetAddress instanceof Inet4Address)) { // skip !IPv4 address
+                        continue;
+                    }
+
+                    // interface up && !loopback && IPv4
+                    Log.d(TAG, "getLocalIPaddress() IPAddress Found[" + inetAddress.getHostAddress() + "] Interface[" + intf.getName() + "]");
+                    if (addrs == null) {
+                        addrs = new ArrayList<String>();
+                    }
+                    addrs.add(inetAddress.getHostAddress());
+                }
+            }
+        } catch (SocketException e) {
+            e.printStackTrace();
+        }
+
+        return addrs;
+    }
+
+    /**
+     * screen gui disabled
+     */
+    private void disableAll() {
+        findViewById(R.id.radioButton1).setEnabled(false);
+        findViewById(R.id.radioButton2).setEnabled(false);
+        findViewById(R.id.ratingBar1).setEnabled(false);
+        findViewById(R.id.autoCompleteTextView1).setEnabled(false);
+        findViewById(R.id.editText1).setEnabled(false);
+        findViewById(R.id.button1).setEnabled(false);
+        findViewById(R.id.button2).setEnabled(false);
+    }
+
+    /**
+     * notify on change IP addres textbox
+     */
+    private void initEditTexts() {
+        AutoCompleteTextView actv = (AutoCompleteTextView) findViewById(R.id.autoCompleteTextView1);
+        actv.setOnKeyListener(new OnKeyListener() {
+            @Override
+            public boolean onKey(View v, int keyCode, KeyEvent event) {
+                // pushed enter key
+                if (event.getAction() == KeyEvent.ACTION_DOWN && keyCode == KeyEvent.KEYCODE_ENTER) {
+                    // hide keyboard
+                    InputMethodManager inputMethodManager = (InputMethodManager) getSystemService(Context.INPUT_METHOD_SERVICE);
+                    inputMethodManager.hideSoftInputFromWindow(v.getWindowToken(), 0);
+
+                    changeCmdButton();
+                    return true;
+                }
+                return false;
+            }
+        });
+
+        EditText et = (EditText)findViewById(R.id.editText1);
+        et.setOnKeyListener(new OnKeyListener() {
+            @Override
+            public boolean onKey(View v, int keyCode, KeyEvent event) {
+                // pushed enter key
+                if (event.getAction() == KeyEvent.ACTION_DOWN && keyCode == KeyEvent.KEYCODE_ENTER) {
+                    // hide keyboard
+                    InputMethodManager inputMethodManager = (InputMethodManager) getSystemService(Context.INPUT_METHOD_SERVICE);
+                    inputMethodManager.hideSoftInputFromWindow(v.getWindowToken(), 0);
+
+                    changeCmdButton();
+                    return true;
+                }
+                return false;
+            }
+        });
+    }
+
+    /**
+     * command button
+     */
+    private void initCmdButton() {
+        Button b = (Button) findViewById(R.id.button1);
+        b.setOnClickListener(new OnClickListener() {
+            @Override
+            public void onClick(View v) {
+                execWfd();
+            }
+        });
+    }
+
+    /**
+     * execute wfd command
+     */
+    private void execWfd() {
+        exec(getCmd(), true);
+    }
+
+    /**
+     * execute any command
+     */
+    private BufferedReader exec(String cmd, boolean toast) {
+        Process p = null;
+        try {
+            p = Runtime.getRuntime().exec(cmd);
+        } catch (IOException e) {
+            e.printStackTrace();
+            Toast.makeText(this, e.getLocalizedMessage(), Toast.LENGTH_SHORT).show();
+            return null;
+        }
+
+        if (toast) {
+            Toast.makeText(this, cmd + " / " + p.toString(), Toast.LENGTH_SHORT).show();
+            return null;
+        }
+
+        int w = -1;
+        try {
+            w = p.waitFor();
+        } catch (InterruptedException e) {
+            e.printStackTrace();
+            Toast.makeText(this, e.getLocalizedMessage(), Toast.LENGTH_SHORT).show();
+            return null;
+        }
+
+        Log.d(TAG, "exec(" + cmd + ") " + p.toString() + " exit[" + w + "]");
+        InputStreamReader isr = new InputStreamReader(p.getInputStream());
+        BufferedReader br = new BufferedReader(isr);
+        return br;
+    }
+
+    /**
+     * execute command in su<br />
+     * Warning! This method not yet implemented!<br />
+     * TODO: FIXME
+     */
+    @SuppressWarnings("unused")
+    private BufferedReader exec_su(String cmd, boolean toast) {
+        // String[] su = {"su", "-c", cmd};
+
+        Process p = null;
+        //try {
+        //    p = Runtime.getRuntime().exec("su -c " + cmd);
+        //} catch (IOException e) {
+        //    e.printStackTrace();
+        //    Toast.makeText(this, e.getLocalizedMessage(), Toast.LENGTH_SHORT).show();
+        //    return null;
+        //}
+
+        DataOutputStream dos = null;
+        try {
+            p = Runtime.getRuntime().exec("su");
+        } catch (IOException e) {
+            e.printStackTrace();
+            return null;
+        }
+
+        dos = new DataOutputStream(p.getOutputStream());
+        try {
+            dos.writeBytes(cmd);
+            dos.writeBytes("\n");
+            dos.writeBytes("exit\n");
+        } catch (IOException e) {
+            e.printStackTrace();
+        }
+
+        if (toast) {
+            Toast.makeText(this, cmd + " / " + p.toString(), Toast.LENGTH_SHORT).show();
+            return null;
+        }
+
+        int w = -1;
+        try {
+            w = p.waitFor();
+        } catch (InterruptedException e) {
+            e.printStackTrace();
+            Toast.makeText(this, e.getLocalizedMessage(), Toast.LENGTH_SHORT).show();
+            return null;
+        }
+
+        Log.d(TAG, "exec(" + cmd + ") " + p.toString() + " exit[" + w + "]");
+        InputStreamReader isr = new InputStreamReader(p.getInputStream());
+        BufferedReader br = new BufferedReader(isr);
+        return br;
+    }
+
+    /**
+     * kill wfd command process
+     */
+    private void initFinishButton() {
+        Button b = (Button) findViewById(R.id.button2);
+        b.setOnClickListener(new OnClickListener() {
+            // @Override
+            public void onClick(View v) {
+                exec_pswfd_killwfd();
+            }
+
+            // 1) ps (find wfd pid)
+            // 2) kill wfd pid
+            private void exec_pswfd_killwfd() {
+                BufferedReader br = exec("ps wfd", false);
+                if (br == null) {
+                    Toast.makeText(MainActivity.this, "exec_lswfd_killwfd() failed-1.", Toast.LENGTH_SHORT).show();
+                    return;
+                }
+
+                try {
+                    int linec = 0;
+                    String line = null;
+                    while ((line = br.readLine()) != null) {
+                        Log.d(TAG, String.format("[%02d]%s", linec++, line));
+                        if (linec == 1) { // skip ps command output first line
+                            continue;
+                        }
+
+                        String pid = getpid(line);
+                        if (pid == null) {
+                            continue;
+                        }
+
+                        exec("kill " + pid, true);
+                    }
+                } catch (IOException e) {
+                    Toast.makeText(MainActivity.this, "exec_lswfd_killwfd() failed.", Toast.LENGTH_SHORT).show();
+                    e.printStackTrace();
+                }
+            }
+
+            // get wfd command PID in ps command output
+            private String getpid(String line) {
+                if (line == null) {
+                    return null;
+                }
+
+                // [00]USER PID PPID VSIZE RSS WCHAN PC NAME
+                // [01]root 17013 1 11444 3660 ffffffff 00000000 S wfd
+                String words[] = line.split("\\s+");
+                if (words == null || words.length < 2) {
+                    return null;
+                }
+
+                return words[1];
+            }
+        });
+
+    }
+
+    /**
+     * set IP address to TextEdit
+     */
+    private void setIPAddrToEdit(String ip) {
+        AutoCompleteTextView actv = (AutoCompleteTextView) findViewById(R.id.autoCompleteTextView1);
+        actv.setText(ip);
+        changeCmdButton();
+    }
+
+    /**
+     * get IP address String from TextEdit
+     */
+    private String getIP() {
+        AutoCompleteTextView actv = (AutoCompleteTextView) findViewById(R.id.autoCompleteTextView1);
+        return actv.getText().toString();
+    }
+
+    /**
+     * get Port String from TextEdit
+     */
+    private String getPort() {
+        EditText et = (EditText) findViewById(R.id.editText1);
+        return et.getText().toString();
+    }
+
+    /**
+     * change command button label<br />
+     */
+    private void changeCmdButton() {
+        String cmd = "wfd";
+
+        // Source : listen
+        // Sink : connect
+        String para = mMiraKind == MiraKind.Source ? "-l" : "-c";
+
+        String ip = getIP();
+        String port = getPort();
+
+        cmd = cmd + " " + para + " " + ip + ":" + port;
+
+        Button b = (Button) findViewById(R.id.button1);
+        b.setText(cmd);
+    }
+
+    /**
+     * get command String from TextEdit
+     */
+    private String getCmd() {
+        Button b = (Button) findViewById(R.id.button1);
+        return b.getText().toString();
+    }
+
+}
\ No newline at end of file
diff -Naur a/packages/apps/WFD/WFD.apk b/packages/apps/WFD/WFD.apk
--- a/packages/apps/WFD/WFD.apk	1969-12-31 19:00:00.000000000 -0500
+++ b/packages/apps/WFD/WFD.apk	2013-08-14 04:13:30.000000000 -0400
@@ -0,0 +1,112 @@
+PK   E8d#d'n  
+    AndroidManifest.xml  KOSARZJ$0MDCAtUQ^M{5&'pK..~cNm+7gs~3sQa &Pa"DQw3Ne-5CS*zCS?T*,Pbvi>/1%Z
+/ <iKbmqEYJl"B(>#6	51~f?X[e[%_d=J/[+2beUi7r!(2GpG,-Oee|}z)l]F)JKmeyY"5F+QW1eb;rT#W1kT#k'k#RKzdI79.aEZ2EZ,[#@96y9~hVQpg]ke?bky*r{(,;Y(hKsUrsM1;VS/1z>4S3:zIkXa9s7z=04:``iQP/Z237HD[m{5?q=[5^n:?0Im=6[R}\}S'u>cK<oh^|z5>x}gmx	~7x6d^oP^vC4x
+8,?([@l-J}8AkDRn:+Ylm13rsyc}/ys9'O}f<vPKd#d'n  
+  PK   E8T  l0     classes.dex[xTW^{93yL$!d: Ig+@P(I&1Cafqkk"}Uyjo~jZ*iTw[/_g$rS^kkas|}Co	,Us(NDI=";ru|,h%Md}PN*@>P
+Pz 4mzj`#p-lz]@0|
+<px+nv1i nN x5t C]+9CKdt}QA_CT,=t.p,cp8\ .Z-
+@9P:  +@'< @(`%UV`F8w>~x2
+,;}M= > <9B`lv; O/?> 
+iMr` -O
+5&'.w>Q1P
+%
+`=R?|%6 k, kn 0  G{/_<<@ 	[eP&(!|KKX+	S%@@
+"&Z4@X,V @X6 U@'p6-u@7p}	#?S9x/Q+	)aS:CA%-Tn=N%;~~_iT")~7+HmjjqhgUoTk(v*>]mVAryas9oAGr1a?_tm6_?qRa_|Hg[?~P)ryM&~O$b'M.a"].WBJE&i*'
+zF*7P^E_] Aw)/8=*"L_{LG$EoH W}2*Be_kWJZC~uzVR$){Qo,Y.Cm].W
+U@f|I.WBr%
+\I]<KAJJu4fUVE4R%u'$-~F2z@VP+~U)/ *.D\R_Ao{M!OVYR/TATkT~k2gU;/s_	2OJ(]q3[U1-bt*A=8nG<MEIy
+6R]"~t-#+}CJJ_~Oy\WN w^5Y'	CvZEJ/9hp,t!<t%pBQR%NBwv:Zm}_s	
+(-rifselL5[bg8-jn}_:z{@P;AQc75v!z]=6!p~i M a^_#jloQ'[7{a{c.Wq},j/aW%}o}g,Zh#x;5-v1Uk^DV>H<EYb/,`}+biSS:Sz|mth^V^>4tWs{^sSXs)BV>5?g-Qg{2;}>5*)gSNVloQzD|S.b-_8,LZcC.()GZO17csvCNr6M{r]BQ#)/rgqw/;si?\~'}";kuN&[kK4;oFya#.(4r5t_[NVo@J*g
+d+~<Sb&6r.N?>_]+eX<E_Sb[|ev
+U;q5igyec4KR>Xo3G\j6coqjt;ta% M.F6G'6>f9;j,
+`/<|d&czeu8D_*<wa|Jb7,o8/e!]Q.CG.<h)3'2cq	=!w)9U['jx#.Zubccn'4NVgY.KcBD|YzwVu~T uu\tu_z/*YYL	_Lb{r<=}E~<I/".;t{`>>Jxgah\&zwqRXsKhSGyGO";tSFXh8M6Q'~O.q/ p>/&w(KgWhCzI%Q0eyP}*['V>g}p8aZ[G<]=h@P	aQiC~43%cDj%Y5JQ# k$oG#olcD;lQ	Dv/p	IQ"x\"O6R2/A|5F>X\2wb9XHk1(c38jy\|8"EdR^6~Jy*\#&#<{JWwXEsQz/l+{S55Yn6VJZ.12"L}FSfWfa(jo;_Lx(YJe!yJv7t'-8`
+bm60bE*rj%A.]:.ruuuBegp4YP8HYVP+ehB=j*E##f+;V4b&Z4#UC"V*/X	u:-@hyh8:ndXEnd6<j7GX]V5:0QF0YhEcQ35:I^+Lbb3eKvSRX0J!#yjk8bJ'CY75'T~Jr2eEh0Om2pZxSX8]y0,:0	m
+[t<.E-hrEWXrE4-6YFlVPVGP8bc6DFbI8|H8!6vt.5b9U#o2G	iLpj,-?k_x<bA3aFa%J2qQuXTFnQ%lB46Dj:y,y=t8aNt _)p6DF}g"_LH:=e0x8wXlg&7%0c5jN`E*kF&GxDyZ3u 3&1cNruDIdi+NvtWef MZahzE[%R*\2c*tn\VtI 6:p6o1m~xX/.z!d(oNcSd$o(&xq$N#3>iXISNx@DdmccS_|oq|Hxo\8iHt<Irbx
+n4b=`q5Iyr"VR<e7cb5;bQNn&^H3HAFJ0Gpakd48[#faBBKmX)b1~ve&b'i8"),Kd|$|)W%-d"4tM*D+6[rS	q8#"QQl@(Y,)%)[bQyLGfb[9[@Ol{
+Ma&tA{]r	K\)O<'"J7$DP:D^o]r# q+Nn+.HOR$CLg<.1Ic~srF'-{4aF2I{njb4eA]L\ n}i)DBDf	S'/arb2F'p w<iEmKex0H?&SahOb/bQ"D )p^OL0fpLO,si\(EA.sA>)skP\Ar,)3EBYq,dLmTN8y#"/u1SR>@C#IE@mgm(fx~J?aU!~so5-bJ#S5N2~{ do0,V>F_gzum;Qgg\/.ST[6U4]RkE.vM.C5XD
+_KcG<vj	}c#W{mtzg<))VfL{N2UWXFtiV;G
+Jtk^At;S_ii>V-8G:\-)8^Bjl{N)&=&jem;,Ksb->#l*JvumgL'CM`7>Nn^%J+[EV#(jmnMdr",y:1K61C~yT%kl) 6mx{Di^Z*GB|;x?X]ZI;7@fVX
+Wyv|dfV`c@/+F_d+BIYdOVV~0 8V5=\%FU5qss1e7Bl/+3c0nGCY},Z34/g|m]csx@<NqF<.a\4?3ALd|?O42"Z/41f:\Os5-&~/}3|k>Vw2ww7][ +~_;~M;ah_gUPKT  l0  PK
+     E8|g'  g'  "  res/drawable-xhdpi/ic_launcher.png PNG
+
+   IHDR   `   `   w8    IDATx}y\Wu{[["[2^[B9$fcp>2!2C:ec&!	x!`.ef-{z%D2~Yw|||||TZ=?,NMqmQ8-<K'shoE D@;[_vkd7>sDfa^Zj]8 y!9q	x=wM{v9wKkd"oZ^ "pz(@kPDA}sG[klQ^:9@@5_ynObi<B=Vi[$( z -Q]JJ%W,~ p-FhGPCj;0j olANczOOTGg~mVK'd Ozgx8jV^ Sp(w.`2Wr~|F]9XC=38?=TnMsYcnnl\rT`P&jm>wch]W(b<^<VnItfa8
+M@Hm}BO<>fr?;GK?w={0tZ fhg1R3.R0C " &K!hEDbDM4#q
+~]3W|{oYgkkg+T81 Q:<4
+P 888jmJ6?VDT6^5%/B}VU*
+1CmLA*X"`0 ~hTQYXDT" YY!!bM$T5N/q)??=FTS/@5~
+}e!s8(c	4J ${C $a;F@ *@1*=e_V0e|GwfWSiJX L	1 06f#$`0's"f vgXvWVysMKet+zWP3XXfp F11qj#x JNV@v
+)Zk6jpooXO8FSxn|o71)uT
+ej`!"X 1,h)406`N vc;g`'I{FF6SG-H!^"|!fF@-spBb!(J?:K:8}tp98Na6N;9[d]S2)S#|5?=*-m$	|^l>^LpbpO[(YN+^%ANX#0'7m|@Hj+g/e05C*g@cPVxDI_@ R&,$9jvslAkqk
+_aC:@im|R>@!k S3U0
+B~\Z"j[0acc(q#,8}cq8rcJ2llT0Xw"=lV*@22
+aKCmn"f-8HDv0)DbC*93&O a33nHol\}U 9t`%`Dt	D\o44^09j6a_q0 !b Q}:DnLHpT%iM	ryE p
+f333xoa6	l9GwC4y;sX(v- +hC0FAkPRvbd0''sib@s?&aqc(L`s122!rCoZW
+ENM~4K:f=yOp=i(~BBYA8-D%\D0bzj6(@4<\#Uz<Gg
+`!PXI!V(J	.UDG!.yWRz!	E`:GkC"@6 8#P@.{zCJ20:[:	9|	=yL_<9yQ;C>kMhB-[^}vK!|)t:4 KwA$iB>`*#nk'; d!(EuGE$ry!fH+N3FV@
+@Gx/i&T<IiJc~k:9	, Xd+FEj7
+ p6D$0 S05rEkvtEpRI~'v(M (&$\)i&! Q 1W\@-_(-\N[{yyAz,nc
+dqmeKMv=X??1G|KAfYHbA,~r>82k|X)O54m](f\oQo6
+o:PDF(7dPM\f!{pt44FK1B~A!hCiZ=^(~?t 'XG(@
+64[ZfRW{Gv<?Y>GxmUE@WZffkt
+Qo>(An))tx s)4m9?GO3\uj4`9`%BQPV(	^=*6tNlm*GQ.}dU {GuP<SBf8vv}4eCUnlYez"Og5>tCu~R Majn=PiC_+u;Uk\VmW]1q(Df(p6i$@#(DYY8K6iR'!x_(JJhPuQa/o/6efZCOdUlK1}0"
+#o|,4oD3AFS{U83c[$bAH6r"j4B4iwvs&6fUp4zEhY4b6yXohacw3nI
+K/$N
+EbY/hW&	U0d5YWQ|(i!C!bzjGRqZc!H% 8CiT=W/7&$Q0toP(T{>tlX.t\NH `Y9	e0XA+F#Tp& J"KqK)QnUN@]27?2$u\[PJuhU
+V(T:tt?ra'aN2T~rWV`cF(l(l]geEK H/AhZC ^4=@{sLaVHSSsdvl	q8t$Ria@DLp
+SIYfUz@b ffyJE,@8t"DXWpD'MQ*\22FOEb]Aj$I ]khCl0/(C"@z,	@2 RQ*mgErhG-D|=cr3	]*<u~G1g3D9^Oom"r\<L2%}`	 #;:]Z o9/g,{5\~Jb6wc}
+A4Ts.OE3*k]BSQ+n
+|N"/O!
+RPtq[aJic\O\r BGy-V-k%R\)}p9u+G}8888M&gP47o*=Q]:-`- /p,$J'ctH:K([-!(0;qME,;g,k^E\\@)X\=k
+'`V4h?gA/5vm
+_qpZ	;#L1yP@W>[ywbi[ 	% lP+_sO
+.@u5~_>@Ja%x=!pb>i4gi>cBd kr
+z1N2,~@ErL%AB[X@B]!	"IZ
+6y#\X>L1tuR}!bzlX{C]HY"r=c6y`C	Y&KdHd(D%a$V+L`aDi-`Q .qk:|Q*E<Ch(*tkh}e\:9%alx2nm G3&Qf#DF24G0e, 7`	idN34 _pGR*)XX#f%*1DeARHzAFSv(C?.,bC=.Jbp(av#7}&v^\tt'H+O/]|(PX_CXJ(BH>FJXvw|Mx/r,9:g1;7=.Sx?F8(_2!a!_kEq!AK/$pcS
+"h# xbY6,.=-8geo/}pMxeg^j#NMO`pa5[W^(:P@@^C)<""$nFXqU3@,>:B;]p=MbvJKW ^q&<woou
+^w>LL`Sp7b%w]_6&%C('d;. =;W:zYT$B\c8+YLR+n-.Z>=l}N<n\8W`wx8}90" :K	@*N	ua(8YS|LGkp
+:XrQ:[p.GE@{%[JZ_o?kXw~+.
+B3M"S|!#P= ugqloS"IT&S'+R	c~kVlDRw~BG/1|AIwN|%B(I'3C".4{A@ZHkO9>NOF  "TWTq~lM6pDJu	][=d#GKJqvJ3BnSNr&l633=,9!SR'nGO.kvY7B{/bd8IVVQR*J(y|MMJg[u($PACi,/\S@HI^as3=>kV
+8Y1]Ar,Z1%H[)7fH#gJ0R&9{	RX<;:!lAMltBdM9&*H $\%BIz=w{(
+*?J7R71] [qf;/*kOm7Ak* p
+1@@H3`:
+1D*
+(UwT3&;VI/ u|w#NB2`p@ "d;@$ 
+^(@a lLWI2we7,H\@)DuWOx _0lcwk,n?&D8zZ\fBQD&[{HfI=fg=vQIG0j&"jlc{$h}Zv23YF$&Ut6&~*1'{wKn)"L5]Q.yXZz,9n+,zI-xTt%Fn/EB <KE9QPJqpy*4-m~C	MgLUMB4hs76v=5DJssIF;`<vyz}}A=go_,Y|z*Dynn'NMc"}x~:.cy(#S^lOBTefAT7EQg6o\-~{Jk	
+v`cnDQLutEoN)/!1:QXT<Jab8no9+.~.*,\&c	a<w?pxV>Zxt	Awwc#%',/`UVGy+L6lhb=6O?/{fvA_V:^0e_CAd!tL1F96Ak(tl<c<u_.z=i:==3;wM?c_(#Y6=$f\s./q{Dd[{ddo|6ZTj8)BQ  	 FT\;Wmq#V2rE
+	}8qp^|G[C wm{?r?c2~sr<%m.p~gZ&"Zi7ZQ;
+?{c>Y#V#79bT*}.(XrL4iw*XteL,l	q>[s1v4VS1LN0Lf=*f[pAA6
+Z	:m	\A&~wyWl[c(^1YbFLl  "IDATDghi[AHr m*S$:a]-]La2%xjpIIM<T(S!S!|/>v{J1&\Jcs#zw*cF`(#]\s%mu$H3&m8>;E2?w
+ |~jQvRBh(un|K/Jn\mMOvk AA'~*O^JS\[~]}JUP(T
+<Y(`f$[UlOK3$ezL[Xga]tZ|_wKTY)DVV:t*=y|r&JYKU
+%x^ZhU |Rd5RP]MYqkv a~%>PmN>|uVT]% d;4-BhP(/=/SZC
+Zt2kc822CA"hV 
+-|r9 
+47RUCvtt=Bc6QIR([W5RDFR hi77Cr<)A"
+%0I-7o]((D#
+aMe0$i}{wG<qZkwtLJk`6tPuRw"0jq:`_pG,E<lQ~B1-
+KV+h:ZF[6mayRG0J4(*@XY0Hi${	#0Fz@(`|=	^j  [laF4EJ':"T$5fy86L	0^&B>UbI'~gQVI2}/XV(u7~12s VJ%+T2:]Rh%*Q02%06k8hQ?7`
+L(.WR}&-f0+@%V~7
+*?$]=@. r M!R-yc4td,{h`<Jg(%TgVD)\d-IWw_R0FyJc5gLJrZWkk1eKi^ #VEB0Hj:Tt0yH};Hi<
+^t4eH"!-1r)saPtOf@t3~@+`{!n:B,a\/x0>BAHXn>`^cAp40CwIi	bBA4UDSd#woV|\?9Qu^OMj-+u}CTG'")bEnILXXXc%-~FR%.Q-(Fs?7.Xgxhq;p#ivUO/U..&+0ZqX}m^h@~!+Wygg :.[L|a{'2oAa+g^z1
+jFG>g>z_P  -*x#[Z6\Kw8hfTEn{e(<-||||||.y``1    IENDB`PK   E8r  p     res/layout/activity_main.xmljA$M`ZT*OJ,57zo _'No&3dI2d9;;'$K..'5]R2epuK>|% w^DCXT-.-IssA$/=)yB}m/j
+2rA%I<|.9e|^aWnBd^=2StuVj=hWpNEos/B5DPz2.&n	Bd!s"~#	{
+rhipcsdKCG|e|,uZGk,0}6JZ#C[k:g~BN3>2Dw4sTu}D6%f|6"	}8CK)nGL:x;Tw{'}knaU1s[0z?c#pq	ulw\mT	=dx=3cYk&K?PKr  p  PK
+     E8a8      resources.arsc            d            H              D   J   S   Z   i   q   {         res/layout/activity_main.xml ""res/drawable-xhdpi/ic_launcher.png WFD Source Sink (IP Address) 19000 connect kill wfd ))No Valid Networks. Try Connect a Network. "f   X     c o m . e x a m p l e . w f d                                                                                                                                                                                                                                               h             4                    $   ,   attr drawable layout string style id      t            l                 )   6   A   J   U   c   q   }                              ic_launcher activity_main app_name 
+
+lbl_Source lbl_Sink lbl_IP lbl_Port lbl_connect lbl_killwfd 		err_no_ip AppBaseTheme AppTheme 
+
+radioGroup radioButton1 radioButton2 
+
+ratingBar1 autoCompleteTextView1 		editText1 button1 button2                           8 L         <   $             @                                                 8 L         <   $                                                    0                                        8          X   $                                              0   @   P   `   p                                                                                   	     	   8 h         X   $       ja                                 	     
+                    8 `         @   $                                            
+                   8 P         @   $                                        
+   n     8 P         @   $                                        
+        0                                         8          X   $                                              0   @   P   `   p                                                                                                   PK   E8#\-       META-INF/MANIFEST.MFmOO0 }5fl$ 2@GB6>hL%^ J	bd4"I&}}m=6)&\Y3[0ddIL#J<KFH;gO9tqMw)<edIrv9^C/JlB_A3FkzrD?U`HOS0/(I|T`oC5.C/C`:i|$D6t}y'PK#\-    PK   E8}A       META-INF/CERT.SFmKo@=	ejt`$J S3}M%|9I"1@aRTRxT(+n"Gw)h<[K VP7|Im:[9#:x9RQ0CbF%1<e.`T_|;MXk'++-eA=Fl}Tw!Y8{hl4/=+
+7O9?}x&7;+%5I28"!]DrV\e+fnNrv=nr3PK}A    PK   E8V       META-INF/CERT.RSA3hb[iA|&Ll|LREX40hbaa2 5N&l(l ps9'de&y}KJ32S@\y)E)0nfbq(k 'k`a`bhjddb`j%klj`i`Vg71* 0#+s#/PaN52V9!'}62_vRTr6{*/roN(0{VdZX6	qpUmWF	sW,v-^,e92yk?{MZpzl!ky<zUNKK<&&8}^j~yo'tZ1~'}wByqcc`94y~_L yeY8kIAr+,3(Ui%_|?m~k"6\ndgza'?^Q"pYGI96mcEO
+]MSz"53-vw6/VT^+?O*SXWi7zumO'KOQ,.CLsMjz}[1{<z+rluor4)-761fcBq Q2E,MmWpRe3-+4w_Yw;k_?6$\E$Y65_<sf
+<)m{,U2J8>UqfVt-:YVu~)s{nL~(w6\LyT;s?G]BoIzQdyjs[Z3x#hF/Zs;\Ou PKV    PK    E8d#d'n  
+                  AndroidManifest.xml  PK    E8T  l0                 classes.dexPK
+ 
+     E8|g'  g'  "               res/drawable-xhdpi/ic_launcher.pngPK    E8r  p               OC  res/layout/activity_main.xmlPK
+ 
+     E8a8                 F  resources.arscPK    E8#\-                 O  META-INF/MANIFEST.MFPK    E8}A                 P  META-INF/CERT.SFPK    E8V                 R  META-INF/CERT.RSAPK        V    
\ No newline at end of file
